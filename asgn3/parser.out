

Unused terminals:

   PROTECTED
   __HALT_COMPILER
   QUOTE
   CONST_BINARY
   GOTO
   NAMESPACE
   __CLASS__
   __LINE__
   CALLABLE
   EXTENDS
   DECLARE
   TRAIT
   ISSET
   INSTEADOF
   ACCESS_OP
   CONST_OCTAL
   INTERFACE
   OR
   FINAL
   COND_COLON
   TRY
   AND
   ENDDECLARE
   NEW
   END_TAG
   EXPONENT
   START_TAG
   CATCH
   __METHOD__
   IMPLEMENTS
   LIST
   PUBLIC
   USE
   CONST
   DIE
   ABSTRACT
   UNSET
   CONST_HEX
   PRIVATE
   CLASS
   __DIR__
   XOR
   __FILE__
   __FUNCTION__
   __TRAIT__
   __NAMESPACE__
   THROW

Grammar

Rule 1     start -> stmt_list
Rule 2     stmt_list -> stmt_list top_stmt
Rule 3     stmt_list -> empty
Rule 4     top_stmt -> stmt
Rule 5     top_stmt -> func_decl
Rule 6     top_stmt -> VAR const_decls SEMICOLON
Rule 7     const_decls -> const_decls COMMA const_decl
Rule 8     const_decls -> const_decl
Rule 9     const_decl -> IDENTIFIER EQUAL expr
Rule 10    const_decl -> IDENTIFIER
Rule 11    func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE
Rule 12    params -> params COMMA param
Rule 13    params -> param
Rule 14    params -> empty
Rule 15    param -> IDENTIFIER
Rule 16    param -> BIT_AND IDENTIFIER
Rule 17    param -> IDENTIFIER EQUAL scalar
Rule 18    param -> BIT_AND IDENTIFIER EQUAL scalar
Rule 19    stmt -> if_stmt
Rule 20    stmt -> alt_if_stmt
Rule 21    if_stmt -> if_stmt_without_else
Rule 22    if_stmt -> if_stmt_without_else ELSE stmt
Rule 23    if_stmt_without_else -> IF LPAREN expr RPAREN stmt
Rule 24    if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
Rule 25    alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON
Rule 26    alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
Rule 27    alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON inner_stmts
Rule 28    alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
Rule 29    stmt -> WHILE LPAREN expr RPAREN while_stmt
Rule 30    while_stmt -> stmt
Rule 31    while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON
Rule 32    stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON
Rule 33    stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
Rule 34    for_expr -> empty
Rule 35    for_expr -> non_empty_for_expr
Rule 36    non_empty_for_expr -> non_empty_for_expr COMMA expr
Rule 37    non_empty_for_expr -> expr
Rule 38    for_stmt -> stmt
Rule 39    for_stmt -> COLON inner_stmts ENDFOR SEMICOLON
Rule 40    stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
Rule 41    foreach_var -> IDENTIFIER
Rule 42    foreach_var -> BIT_AND IDENTIFIER
Rule 43    foreach_arg -> empty
Rule 44    foreach_arg -> DOUBLE_ARROW foreach_var
Rule 45    foreach_stmt -> stmt
Rule 46    foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON
Rule 47    stmt -> SWITCH LPAREN expr RPAREN switch_stmt
Rule 48    switch_stmt -> LBRACE case_stmt RBRACE
Rule 49    switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE
Rule 50    switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON
Rule 51    switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON
Rule 52    case_stmt -> empty
Rule 53    case_stmt -> case_stmt CASE expr case_separator inner_stmts
Rule 54    case_stmt -> case_stmt DEFAULT case_separator inner_stmts
Rule 55    case_separator -> COLON
Rule 56    case_separator -> SEMICOLON
Rule 57    stmt -> BREAK SEMICOLON
Rule 58    stmt -> BREAK expr SEMICOLON
Rule 59    stmt -> CONTINUE SEMICOLON
Rule 60    stmt -> CONTINUE expr SEMICOLON
Rule 61    stmt -> RETURN SEMICOLON
Rule 62    stmt -> RETURN expr SEMICOLON
Rule 63    stmt -> GLOBAL global_var_list SEMICOLON
Rule 64    global_var_list -> global_var_list COMMA IDENTIFIER
Rule 65    global_var_list -> IDENTIFIER
Rule 66    stmt -> STATIC static_var_list SEMICOLON
Rule 67    static_var_list -> static_var_list COMMA static_var
Rule 68    static_var_list -> static_var
Rule 69    static_var -> IDENTIFIER EQUAL scalar
Rule 70    static_var -> IDENTIFIER
Rule 71    stmt -> ECHO echo_expr_list SEMICOLON
Rule 72    echo_expr_list -> echo_expr_list COMMA expr
Rule 73    echo_expr_list -> expr
Rule 74    stmt -> LBRACE inner_stmts RBRACE
Rule 75    stmt -> SEMICOLON
Rule 76    stmt -> expr SEMICOLON
Rule 77    inner_stmts -> inner_stmts inner_stmt
Rule 78    inner_stmts -> empty
Rule 79    inner_stmt -> stmt
Rule 80    inner_stmt -> func_decl
Rule 81    expr -> variable
Rule 82    variable -> base_var
Rule 83    variable -> func_call
Rule 84    func_call -> STRING LPAREN func_params RPAREN
Rule 85    func_params -> func_params COMMA func_param
Rule 86    func_params -> func_param
Rule 87    func_params -> empty
Rule 88    func_param -> expr
Rule 89    func_param -> BIT_AND variable
Rule 90    base_var -> base_var LBRACKET dim_offset RBRACKET
Rule 91    base_var -> base_var LBRACE expr RBRACE
Rule 92    base_var -> IDENTIFIER
Rule 93    dim_offset -> expr
Rule 94    dim_offset -> empty
Rule 95    expr -> variable EQUAL expr
Rule 96    expr -> variable EQUAL BIT_AND expr
Rule 97    expr -> CLONE expr
Rule 98    scalar -> CONST_DECIMAL
Rule 99    scalar -> CONST_DOUBLE
Rule 100   scalar -> CONST_STRING
Rule 101   scalar -> NULL
Rule 102   scalar -> TRUE
Rule 103   scalar -> FALSE
Rule 104   scalar -> PLUS scalar
Rule 105   scalar -> MINUS scalar
Rule 106   scalar -> ARRAY LPAREN scalar_array_pair_list RPAREN
Rule 107   scalar_array_pair_list -> empty
Rule 108   scalar_array_pair_list -> scalar_non_empty_array_pair_list possible_comma
Rule 109   scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar
Rule 110   scalar_non_empty_array_pair_list -> scalar
Rule 111   scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar DOUBLE_ARROW scalar
Rule 112   scalar_non_empty_array_pair_list -> scalar DOUBLE_ARROW scalar
Rule 113   expr -> ARRAY LPAREN array_pair_list RPAREN
Rule 114   array_pair_list -> empty
Rule 115   array_pair_list -> non_empty_array_pair_list possible_comma
Rule 116   possible_comma -> empty
Rule 117   possible_comma -> COMMA
Rule 118   non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND variable
Rule 119   non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr
Rule 120   non_empty_array_pair_list -> BIT_AND variable
Rule 121   non_empty_array_pair_list -> expr
Rule 122   non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW BIT_AND variable
Rule 123   non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW expr
Rule 124   non_empty_array_pair_list -> expr DOUBLE_ARROW BIT_AND variable
Rule 125   non_empty_array_pair_list -> expr DOUBLE_ARROW expr
Rule 126   expr -> variable PLUS_EQ expr
Rule 127   expr -> variable MINUS_EQ expr
Rule 128   expr -> variable MULTIPLY_EQ expr
Rule 129   expr -> variable DIVIDE_EQ expr
Rule 130   expr -> variable DOT_EQ expr
Rule 131   expr -> variable MOD_EQ expr
Rule 132   expr -> expr AND_OP expr
Rule 133   expr -> expr OR_OP expr
Rule 134   expr -> expr BIT_OR expr
Rule 135   expr -> expr BIT_XOR expr
Rule 136   expr -> expr BIT_AND expr
Rule 137   expr -> expr DOT expr
Rule 138   expr -> expr PLUS expr
Rule 139   expr -> expr MINUS expr
Rule 140   expr -> expr MULT expr
Rule 141   expr -> expr DIV expr
Rule 142   expr -> expr BIT_LSHIFT expr
Rule 143   expr -> expr BIT_RSHIFT expr
Rule 144   expr -> expr MOD expr
Rule 145   expr -> expr IDENTICAL expr
Rule 146   expr -> expr NOT_IDENTICAL expr
Rule 147   expr -> expr EQ_EQ expr
Rule 148   expr -> expr NOT_EQ expr
Rule 149   expr -> expr LESSER expr
Rule 150   expr -> expr LESSER_EQ expr
Rule 151   expr -> expr GREATER expr
Rule 152   expr -> expr GREATER_EQ expr
Rule 153   expr -> expr INSTANCEOF expr
Rule 154   expr -> PLUS expr
Rule 155   expr -> MINUS expr
Rule 156   expr -> BIT_NOT expr
Rule 157   expr -> NOT expr
Rule 158   expr -> CONST_DECIMAL
Rule 159   expr -> CONST_DOUBLE
Rule 160   expr -> CONST_STRING
Rule 161   expr -> NULL
Rule 162   expr -> TRUE
Rule 163   expr -> FALSE
Rule 164   expr -> expr COND_OP expr COLON expr
Rule 165   expr -> INC variable
Rule 166   expr -> DEC variable
Rule 167   expr -> variable INC
Rule 168   expr -> variable DEC
Rule 169   expr -> EMPTY LPAREN expr RPAREN
Rule 170   expr -> EVAL LPAREN expr RPAREN
Rule 171   expr -> LPAREN expr RPAREN
Rule 172   expr -> INCLUDE expr
Rule 173   expr -> INCLUDE_ONCE expr
Rule 174   expr -> REQUIRE expr
Rule 175   expr -> REQUIRE_ONCE expr
Rule 176   expr -> EXIT
Rule 177   expr -> EXIT LPAREN RPAREN
Rule 178   expr -> EXIT LPAREN expr RPAREN
Rule 179   expr -> PRINT expr
Rule 180   empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
ACCESS_OP            : 
AND                  : 
AND_OP               : 132
ARRAY                : 106 113
AS                   : 40
BIT_AND              : 16 18 42 89 96 118 120 122 124 136
BIT_LSHIFT           : 142
BIT_NOT              : 156
BIT_OR               : 134
BIT_RSHIFT           : 143
BIT_XOR              : 135
BREAK                : 57 58
CALLABLE             : 
CASE                 : 53
CATCH                : 
CLASS                : 
CLONE                : 97
COLON                : 26 27 28 31 39 46 50 51 55 164
COMMA                : 7 12 36 64 67 72 85 109 111 117 118 119 122 123
COND_COLON           : 
COND_OP              : 164
CONST                : 
CONST_BINARY         : 
CONST_DECIMAL        : 98 158
CONST_DOUBLE         : 99 159
CONST_HEX            : 
CONST_OCTAL          : 
CONST_STRING         : 100 160
CONTINUE             : 59 60
DEC                  : 166 168
DECLARE              : 
DEFAULT              : 54
DIE                  : 
DIV                  : 141
DIVIDE_EQ            : 129
DO                   : 32
DOT                  : 137
DOT_EQ               : 130
DOUBLE_ARROW         : 44 111 112 122 123 124 125
ECHO                 : 71
ELSE                 : 22 26
ELSEIF               : 24 28
EMPTY                : 169
ENDDECLARE           : 
ENDFOR               : 39
ENDFOREACH           : 46
ENDIF                : 25 26
ENDSWITCH            : 50 51
ENDWHILE             : 31
END_TAG              : 
EQUAL                : 9 17 18 69 95 96
EQ_EQ                : 147
EVAL                 : 170
EXIT                 : 176 177 178
EXPONENT             : 
EXTENDS              : 
FALSE                : 103 163
FINAL                : 
FOR                  : 33
FOREACH              : 40
FUNCTION             : 11
GLOBAL               : 63
GOTO                 : 
GREATER              : 151
GREATER_EQ           : 152
IDENTICAL            : 145
IDENTIFIER           : 9 10 15 16 17 18 41 42 64 65 69 70 92
IF                   : 23 27
IMPLEMENTS           : 
INC                  : 165 167
INCLUDE              : 172
INCLUDE_ONCE         : 173
INSTANCEOF           : 153
INSTEADOF            : 
INTERFACE            : 
ISSET                : 
LBRACE               : 11 48 49 74 91
LBRACKET             : 90
LESSER               : 149
LESSER_EQ            : 150
LIST                 : 
LPAREN               : 11 23 24 27 28 29 32 33 40 47 84 106 113 169 170 171 177 178
MINUS                : 105 139 155
MINUS_EQ             : 127
MOD                  : 144
MOD_EQ               : 131
MULT                 : 140
MULTIPLY_EQ          : 128
NAMESPACE            : 
NEW                  : 
NOT                  : 157
NOT_EQ               : 148
NOT_IDENTICAL        : 146
NULL                 : 101 161
OR                   : 
OR_OP                : 133
PLUS                 : 104 138 154
PLUS_EQ              : 126
PRINT                : 179
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
QUOTE                : 
RBRACE               : 11 48 49 74 91
RBRACKET             : 90
REQUIRE              : 174
REQUIRE_ONCE         : 175
RETURN               : 61 62
RPAREN               : 11 23 24 27 28 29 32 33 40 47 84 106 113 169 170 171 177 178
SEMICOLON            : 6 25 26 31 32 33 33 39 46 49 50 51 51 56 57 58 59 60 61 62 63 66 71 75 76
START_TAG            : 
STATIC               : 66
STRING               : 11 84
SWITCH               : 47
THROW                : 
TRAIT                : 
TRUE                 : 102 162
TRY                  : 
UNSET                : 
USE                  : 
VAR                  : 6
WHILE                : 29 32
XOR                  : 
__CLASS__            : 
__DIR__              : 
__FILE__             : 
__FUNCTION__         : 
__HALT_COMPILER      : 
__LINE__             : 
__METHOD__           : 
__NAMESPACE__        : 
__TRAIT__            : 
error                : 

Nonterminals, with rules where they appear

alt_if_stmt          : 20
alt_if_stmt_without_else : 25 26 28
array_pair_list      : 113
base_var             : 82 90 91
case_separator       : 53 54
case_stmt            : 48 49 50 51 53 54
const_decl           : 7 8
const_decls          : 6 7
dim_offset           : 90
echo_expr_list       : 71 72
empty                : 3 14 34 43 52 78 87 94 107 114 116
expr                 : 9 23 24 27 28 29 32 36 37 40 47 53 58 60 62 72 73 76 88 91 93 95 96 97 119 121 122 123 123 124 125 125 126 127 128 129 130 131 132 132 133 133 134 134 135 135 136 136 137 137 138 138 139 139 140 140 141 141 142 142 143 143 144 144 145 145 146 146 147 147 148 148 149 149 150 150 151 151 152 152 153 153 154 155 156 157 164 164 164 169 170 171 172 173 174 175 178 179
for_expr             : 33 33 33
for_stmt             : 33
foreach_arg          : 40
foreach_stmt         : 40
foreach_var          : 40 44
func_call            : 83
func_decl            : 5 80
func_param           : 85 86
func_params          : 84 85
global_var_list      : 63 64
if_stmt              : 19
if_stmt_without_else : 21 22 24
inner_stmt           : 77
inner_stmts          : 11 26 27 28 31 39 46 53 54 74 77
non_empty_array_pair_list : 115 118 119 122 123
non_empty_for_expr   : 35 36
param                : 12 13
params               : 11 12
possible_comma       : 108 115
scalar               : 17 18 69 104 105 109 110 111 111 112 112
scalar_array_pair_list : 106
scalar_non_empty_array_pair_list : 108 109 111
start                : 0
static_var           : 67 68
static_var_list      : 66 67
stmt                 : 4 22 23 24 30 32 38 45 79
stmt_list            : 1 2
switch_stmt          : 47
top_stmt             : 2
variable             : 81 89 95 96 118 120 122 124 126 127 128 129 130 131 165 166 167 168
while_stmt           : 29


Parsing method: LALR


state 0

    (0) S' -> . start
    (1) start -> . stmt_list
    (2) stmt_list -> . stmt_list top_stmt
    (3) stmt_list -> . empty
    (180) empty -> .

    VAR             reduce using rule 180 (empty -> .)
    WHILE           reduce using rule 180 (empty -> .)
    DO              reduce using rule 180 (empty -> .)
    FOR             reduce using rule 180 (empty -> .)
    FOREACH         reduce using rule 180 (empty -> .)
    SWITCH          reduce using rule 180 (empty -> .)
    BREAK           reduce using rule 180 (empty -> .)
    CONTINUE        reduce using rule 180 (empty -> .)
    RETURN          reduce using rule 180 (empty -> .)
    GLOBAL          reduce using rule 180 (empty -> .)
    STATIC          reduce using rule 180 (empty -> .)
    ECHO            reduce using rule 180 (empty -> .)
    LBRACE          reduce using rule 180 (empty -> .)
    SEMICOLON       reduce using rule 180 (empty -> .)
    FUNCTION        reduce using rule 180 (empty -> .)
    CLONE           reduce using rule 180 (empty -> .)
    ARRAY           reduce using rule 180 (empty -> .)
    PLUS            reduce using rule 180 (empty -> .)
    MINUS           reduce using rule 180 (empty -> .)
    BIT_NOT         reduce using rule 180 (empty -> .)
    NOT             reduce using rule 180 (empty -> .)
    CONST_DECIMAL   reduce using rule 180 (empty -> .)
    CONST_DOUBLE    reduce using rule 180 (empty -> .)
    CONST_STRING    reduce using rule 180 (empty -> .)
    NULL            reduce using rule 180 (empty -> .)
    TRUE            reduce using rule 180 (empty -> .)
    FALSE           reduce using rule 180 (empty -> .)
    INC             reduce using rule 180 (empty -> .)
    DEC             reduce using rule 180 (empty -> .)
    EMPTY           reduce using rule 180 (empty -> .)
    EVAL            reduce using rule 180 (empty -> .)
    LPAREN          reduce using rule 180 (empty -> .)
    INCLUDE         reduce using rule 180 (empty -> .)
    INCLUDE_ONCE    reduce using rule 180 (empty -> .)
    REQUIRE         reduce using rule 180 (empty -> .)
    REQUIRE_ONCE    reduce using rule 180 (empty -> .)
    EXIT            reduce using rule 180 (empty -> .)
    PRINT           reduce using rule 180 (empty -> .)
    IF              reduce using rule 180 (empty -> .)
    IDENTIFIER      reduce using rule 180 (empty -> .)
    STRING          reduce using rule 180 (empty -> .)
    $end            reduce using rule 180 (empty -> .)


    stmt_list                      shift and go to state 1
    start                          shift and go to state 2
    empty                          shift and go to state 3

state 1

    (1) start -> stmt_list .
    (2) stmt_list -> stmt_list . top_stmt
    (4) top_stmt -> . stmt
    (5) top_stmt -> . func_decl
    (6) top_stmt -> . VAR const_decls SEMICOLON
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (11) func_decl -> . FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    $end            reduce using rule 1 (start -> stmt_list .)
    VAR             shift and go to state 12
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    FUNCTION        shift and go to state 24
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    func_call                      shift and go to state 40
    func_decl                      shift and go to state 41
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 27
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45
    top_stmt                       shift and go to state 16

state 2

    (0) S' -> start .




state 3

    (3) stmt_list -> empty .

    VAR             reduce using rule 3 (stmt_list -> empty .)
    WHILE           reduce using rule 3 (stmt_list -> empty .)
    DO              reduce using rule 3 (stmt_list -> empty .)
    FOR             reduce using rule 3 (stmt_list -> empty .)
    FOREACH         reduce using rule 3 (stmt_list -> empty .)
    SWITCH          reduce using rule 3 (stmt_list -> empty .)
    BREAK           reduce using rule 3 (stmt_list -> empty .)
    CONTINUE        reduce using rule 3 (stmt_list -> empty .)
    RETURN          reduce using rule 3 (stmt_list -> empty .)
    GLOBAL          reduce using rule 3 (stmt_list -> empty .)
    STATIC          reduce using rule 3 (stmt_list -> empty .)
    ECHO            reduce using rule 3 (stmt_list -> empty .)
    LBRACE          reduce using rule 3 (stmt_list -> empty .)
    SEMICOLON       reduce using rule 3 (stmt_list -> empty .)
    FUNCTION        reduce using rule 3 (stmt_list -> empty .)
    CLONE           reduce using rule 3 (stmt_list -> empty .)
    ARRAY           reduce using rule 3 (stmt_list -> empty .)
    PLUS            reduce using rule 3 (stmt_list -> empty .)
    MINUS           reduce using rule 3 (stmt_list -> empty .)
    BIT_NOT         reduce using rule 3 (stmt_list -> empty .)
    NOT             reduce using rule 3 (stmt_list -> empty .)
    CONST_DECIMAL   reduce using rule 3 (stmt_list -> empty .)
    CONST_DOUBLE    reduce using rule 3 (stmt_list -> empty .)
    CONST_STRING    reduce using rule 3 (stmt_list -> empty .)
    NULL            reduce using rule 3 (stmt_list -> empty .)
    TRUE            reduce using rule 3 (stmt_list -> empty .)
    FALSE           reduce using rule 3 (stmt_list -> empty .)
    INC             reduce using rule 3 (stmt_list -> empty .)
    DEC             reduce using rule 3 (stmt_list -> empty .)
    EMPTY           reduce using rule 3 (stmt_list -> empty .)
    EVAL            reduce using rule 3 (stmt_list -> empty .)
    LPAREN          reduce using rule 3 (stmt_list -> empty .)
    INCLUDE         reduce using rule 3 (stmt_list -> empty .)
    INCLUDE_ONCE    reduce using rule 3 (stmt_list -> empty .)
    REQUIRE         reduce using rule 3 (stmt_list -> empty .)
    REQUIRE_ONCE    reduce using rule 3 (stmt_list -> empty .)
    EXIT            reduce using rule 3 (stmt_list -> empty .)
    PRINT           reduce using rule 3 (stmt_list -> empty .)
    IF              reduce using rule 3 (stmt_list -> empty .)
    IDENTIFIER      reduce using rule 3 (stmt_list -> empty .)
    STRING          reduce using rule 3 (stmt_list -> empty .)
    $end            reduce using rule 3 (stmt_list -> empty .)



state 4

    (25) alt_if_stmt -> alt_if_stmt_without_else . ENDIF SEMICOLON
    (26) alt_if_stmt -> alt_if_stmt_without_else . ELSE COLON inner_stmts ENDIF SEMICOLON
    (28) alt_if_stmt_without_else -> alt_if_stmt_without_else . ELSEIF LPAREN expr RPAREN COLON inner_stmts

    ENDIF           shift and go to state 57
    ELSE            shift and go to state 56
    ELSEIF          shift and go to state 58



state 5

    (162) expr -> TRUE .

    SEMICOLON       reduce using rule 162 (expr -> TRUE .)
    AND_OP          reduce using rule 162 (expr -> TRUE .)
    OR_OP           reduce using rule 162 (expr -> TRUE .)
    BIT_OR          reduce using rule 162 (expr -> TRUE .)
    BIT_XOR         reduce using rule 162 (expr -> TRUE .)
    BIT_AND         reduce using rule 162 (expr -> TRUE .)
    DOT             reduce using rule 162 (expr -> TRUE .)
    PLUS            reduce using rule 162 (expr -> TRUE .)
    MINUS           reduce using rule 162 (expr -> TRUE .)
    MULT            reduce using rule 162 (expr -> TRUE .)
    DIV             reduce using rule 162 (expr -> TRUE .)
    BIT_LSHIFT      reduce using rule 162 (expr -> TRUE .)
    BIT_RSHIFT      reduce using rule 162 (expr -> TRUE .)
    MOD             reduce using rule 162 (expr -> TRUE .)
    IDENTICAL       reduce using rule 162 (expr -> TRUE .)
    NOT_IDENTICAL   reduce using rule 162 (expr -> TRUE .)
    EQ_EQ           reduce using rule 162 (expr -> TRUE .)
    NOT_EQ          reduce using rule 162 (expr -> TRUE .)
    LESSER          reduce using rule 162 (expr -> TRUE .)
    LESSER_EQ       reduce using rule 162 (expr -> TRUE .)
    GREATER         reduce using rule 162 (expr -> TRUE .)
    GREATER_EQ      reduce using rule 162 (expr -> TRUE .)
    INSTANCEOF      reduce using rule 162 (expr -> TRUE .)
    COND_OP         reduce using rule 162 (expr -> TRUE .)
    COMMA           reduce using rule 162 (expr -> TRUE .)
    RPAREN          reduce using rule 162 (expr -> TRUE .)
    AS              reduce using rule 162 (expr -> TRUE .)
    DOUBLE_ARROW    reduce using rule 162 (expr -> TRUE .)
    RBRACE          reduce using rule 162 (expr -> TRUE .)
    RBRACKET        reduce using rule 162 (expr -> TRUE .)
    COLON           reduce using rule 162 (expr -> TRUE .)



state 6

    (155) expr -> MINUS . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 59
    variable                       shift and go to state 53

state 7

    (158) expr -> CONST_DECIMAL .

    SEMICOLON       reduce using rule 158 (expr -> CONST_DECIMAL .)
    AND_OP          reduce using rule 158 (expr -> CONST_DECIMAL .)
    OR_OP           reduce using rule 158 (expr -> CONST_DECIMAL .)
    BIT_OR          reduce using rule 158 (expr -> CONST_DECIMAL .)
    BIT_XOR         reduce using rule 158 (expr -> CONST_DECIMAL .)
    BIT_AND         reduce using rule 158 (expr -> CONST_DECIMAL .)
    DOT             reduce using rule 158 (expr -> CONST_DECIMAL .)
    PLUS            reduce using rule 158 (expr -> CONST_DECIMAL .)
    MINUS           reduce using rule 158 (expr -> CONST_DECIMAL .)
    MULT            reduce using rule 158 (expr -> CONST_DECIMAL .)
    DIV             reduce using rule 158 (expr -> CONST_DECIMAL .)
    BIT_LSHIFT      reduce using rule 158 (expr -> CONST_DECIMAL .)
    BIT_RSHIFT      reduce using rule 158 (expr -> CONST_DECIMAL .)
    MOD             reduce using rule 158 (expr -> CONST_DECIMAL .)
    IDENTICAL       reduce using rule 158 (expr -> CONST_DECIMAL .)
    NOT_IDENTICAL   reduce using rule 158 (expr -> CONST_DECIMAL .)
    EQ_EQ           reduce using rule 158 (expr -> CONST_DECIMAL .)
    NOT_EQ          reduce using rule 158 (expr -> CONST_DECIMAL .)
    LESSER          reduce using rule 158 (expr -> CONST_DECIMAL .)
    LESSER_EQ       reduce using rule 158 (expr -> CONST_DECIMAL .)
    GREATER         reduce using rule 158 (expr -> CONST_DECIMAL .)
    GREATER_EQ      reduce using rule 158 (expr -> CONST_DECIMAL .)
    INSTANCEOF      reduce using rule 158 (expr -> CONST_DECIMAL .)
    COND_OP         reduce using rule 158 (expr -> CONST_DECIMAL .)
    COMMA           reduce using rule 158 (expr -> CONST_DECIMAL .)
    RPAREN          reduce using rule 158 (expr -> CONST_DECIMAL .)
    AS              reduce using rule 158 (expr -> CONST_DECIMAL .)
    DOUBLE_ARROW    reduce using rule 158 (expr -> CONST_DECIMAL .)
    RBRACE          reduce using rule 158 (expr -> CONST_DECIMAL .)
    RBRACKET        reduce using rule 158 (expr -> CONST_DECIMAL .)
    COLON           reduce using rule 158 (expr -> CONST_DECIMAL .)



state 8

    (154) expr -> PLUS . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 60
    variable                       shift and go to state 53

state 9

    (156) expr -> BIT_NOT . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 61
    variable                       shift and go to state 53

state 10

    (40) stmt -> FOREACH . LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt

    LPAREN          shift and go to state 62



state 11

    (170) expr -> EVAL . LPAREN expr RPAREN

    LPAREN          shift and go to state 63



state 12

    (6) top_stmt -> VAR . const_decls SEMICOLON
    (7) const_decls -> . const_decls COMMA const_decl
    (8) const_decls -> . const_decl
    (9) const_decl -> . IDENTIFIER EQUAL expr
    (10) const_decl -> . IDENTIFIER

    IDENTIFIER      shift and go to state 66


    const_decls                    shift and go to state 64
    const_decl                     shift and go to state 65

state 13

    (173) expr -> INCLUDE_ONCE . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 67
    variable                       shift and go to state 53

state 14

    (19) stmt -> if_stmt .

    WHILE           reduce using rule 19 (stmt -> if_stmt .)
    DO              reduce using rule 19 (stmt -> if_stmt .)
    FOR             reduce using rule 19 (stmt -> if_stmt .)
    FOREACH         reduce using rule 19 (stmt -> if_stmt .)
    SWITCH          reduce using rule 19 (stmt -> if_stmt .)
    BREAK           reduce using rule 19 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 19 (stmt -> if_stmt .)
    RETURN          reduce using rule 19 (stmt -> if_stmt .)
    GLOBAL          reduce using rule 19 (stmt -> if_stmt .)
    STATIC          reduce using rule 19 (stmt -> if_stmt .)
    ECHO            reduce using rule 19 (stmt -> if_stmt .)
    LBRACE          reduce using rule 19 (stmt -> if_stmt .)
    SEMICOLON       reduce using rule 19 (stmt -> if_stmt .)
    FUNCTION        reduce using rule 19 (stmt -> if_stmt .)
    CLONE           reduce using rule 19 (stmt -> if_stmt .)
    ARRAY           reduce using rule 19 (stmt -> if_stmt .)
    PLUS            reduce using rule 19 (stmt -> if_stmt .)
    MINUS           reduce using rule 19 (stmt -> if_stmt .)
    BIT_NOT         reduce using rule 19 (stmt -> if_stmt .)
    NOT             reduce using rule 19 (stmt -> if_stmt .)
    CONST_DECIMAL   reduce using rule 19 (stmt -> if_stmt .)
    CONST_DOUBLE    reduce using rule 19 (stmt -> if_stmt .)
    CONST_STRING    reduce using rule 19 (stmt -> if_stmt .)
    NULL            reduce using rule 19 (stmt -> if_stmt .)
    TRUE            reduce using rule 19 (stmt -> if_stmt .)
    FALSE           reduce using rule 19 (stmt -> if_stmt .)
    INC             reduce using rule 19 (stmt -> if_stmt .)
    DEC             reduce using rule 19 (stmt -> if_stmt .)
    EMPTY           reduce using rule 19 (stmt -> if_stmt .)
    EVAL            reduce using rule 19 (stmt -> if_stmt .)
    LPAREN          reduce using rule 19 (stmt -> if_stmt .)
    INCLUDE         reduce using rule 19 (stmt -> if_stmt .)
    INCLUDE_ONCE    reduce using rule 19 (stmt -> if_stmt .)
    REQUIRE         reduce using rule 19 (stmt -> if_stmt .)
    REQUIRE_ONCE    reduce using rule 19 (stmt -> if_stmt .)
    EXIT            reduce using rule 19 (stmt -> if_stmt .)
    PRINT           reduce using rule 19 (stmt -> if_stmt .)
    IF              reduce using rule 19 (stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 19 (stmt -> if_stmt .)
    STRING          reduce using rule 19 (stmt -> if_stmt .)
    ENDIF           reduce using rule 19 (stmt -> if_stmt .)
    ELSE            reduce using rule 19 (stmt -> if_stmt .)
    ELSEIF          reduce using rule 19 (stmt -> if_stmt .)
    RBRACE          reduce using rule 19 (stmt -> if_stmt .)
    VAR             reduce using rule 19 (stmt -> if_stmt .)
    $end            reduce using rule 19 (stmt -> if_stmt .)
    ENDWHILE        reduce using rule 19 (stmt -> if_stmt .)
    ENDFOREACH      reduce using rule 19 (stmt -> if_stmt .)
    CASE            reduce using rule 19 (stmt -> if_stmt .)
    DEFAULT         reduce using rule 19 (stmt -> if_stmt .)
    ENDSWITCH       reduce using rule 19 (stmt -> if_stmt .)
    ENDFOR          reduce using rule 19 (stmt -> if_stmt .)



state 15

    (97) expr -> CLONE . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 68
    variable                       shift and go to state 53

state 16

    (2) stmt_list -> stmt_list top_stmt .

    VAR             reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    WHILE           reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    DO              reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    FOR             reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    FOREACH         reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    SWITCH          reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    BREAK           reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    CONTINUE        reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    RETURN          reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    GLOBAL          reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    STATIC          reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    ECHO            reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    LBRACE          reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    SEMICOLON       reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    FUNCTION        reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    CLONE           reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    ARRAY           reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    PLUS            reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    MINUS           reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    BIT_NOT         reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    NOT             reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    CONST_DECIMAL   reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    CONST_DOUBLE    reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    CONST_STRING    reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    NULL            reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    TRUE            reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    FALSE           reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    INC             reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    DEC             reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    EMPTY           reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    EVAL            reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    LPAREN          reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    INCLUDE         reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    INCLUDE_ONCE    reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    REQUIRE         reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    REQUIRE_ONCE    reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    EXIT            reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    PRINT           reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    IF              reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    IDENTIFIER      reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    STRING          reduce using rule 2 (stmt_list -> stmt_list top_stmt .)
    $end            reduce using rule 2 (stmt_list -> stmt_list top_stmt .)



state 17

    (61) stmt -> RETURN . SEMICOLON
    (62) stmt -> RETURN . expr SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    SEMICOLON       shift and go to state 69
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 70
    variable                       shift and go to state 53

state 18

    (174) expr -> REQUIRE . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 71
    variable                       shift and go to state 53

state 19

    (66) stmt -> STATIC . static_var_list SEMICOLON
    (67) static_var_list -> . static_var_list COMMA static_var
    (68) static_var_list -> . static_var
    (69) static_var -> . IDENTIFIER EQUAL scalar
    (70) static_var -> . IDENTIFIER

    IDENTIFIER      shift and go to state 74


    static_var                     shift and go to state 72
    static_var_list                shift and go to state 73

state 20

    (179) expr -> PRINT . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 75
    variable                       shift and go to state 53

state 21

    (166) expr -> DEC . variable
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    base_var                       shift and go to state 43
    func_call                      shift and go to state 40
    variable                       shift and go to state 76

state 22

    (169) expr -> EMPTY . LPAREN expr RPAREN

    LPAREN          shift and go to state 77



state 23

    (159) expr -> CONST_DOUBLE .

    SEMICOLON       reduce using rule 159 (expr -> CONST_DOUBLE .)
    AND_OP          reduce using rule 159 (expr -> CONST_DOUBLE .)
    OR_OP           reduce using rule 159 (expr -> CONST_DOUBLE .)
    BIT_OR          reduce using rule 159 (expr -> CONST_DOUBLE .)
    BIT_XOR         reduce using rule 159 (expr -> CONST_DOUBLE .)
    BIT_AND         reduce using rule 159 (expr -> CONST_DOUBLE .)
    DOT             reduce using rule 159 (expr -> CONST_DOUBLE .)
    PLUS            reduce using rule 159 (expr -> CONST_DOUBLE .)
    MINUS           reduce using rule 159 (expr -> CONST_DOUBLE .)
    MULT            reduce using rule 159 (expr -> CONST_DOUBLE .)
    DIV             reduce using rule 159 (expr -> CONST_DOUBLE .)
    BIT_LSHIFT      reduce using rule 159 (expr -> CONST_DOUBLE .)
    BIT_RSHIFT      reduce using rule 159 (expr -> CONST_DOUBLE .)
    MOD             reduce using rule 159 (expr -> CONST_DOUBLE .)
    IDENTICAL       reduce using rule 159 (expr -> CONST_DOUBLE .)
    NOT_IDENTICAL   reduce using rule 159 (expr -> CONST_DOUBLE .)
    EQ_EQ           reduce using rule 159 (expr -> CONST_DOUBLE .)
    NOT_EQ          reduce using rule 159 (expr -> CONST_DOUBLE .)
    LESSER          reduce using rule 159 (expr -> CONST_DOUBLE .)
    LESSER_EQ       reduce using rule 159 (expr -> CONST_DOUBLE .)
    GREATER         reduce using rule 159 (expr -> CONST_DOUBLE .)
    GREATER_EQ      reduce using rule 159 (expr -> CONST_DOUBLE .)
    INSTANCEOF      reduce using rule 159 (expr -> CONST_DOUBLE .)
    COND_OP         reduce using rule 159 (expr -> CONST_DOUBLE .)
    COMMA           reduce using rule 159 (expr -> CONST_DOUBLE .)
    RPAREN          reduce using rule 159 (expr -> CONST_DOUBLE .)
    AS              reduce using rule 159 (expr -> CONST_DOUBLE .)
    DOUBLE_ARROW    reduce using rule 159 (expr -> CONST_DOUBLE .)
    RBRACE          reduce using rule 159 (expr -> CONST_DOUBLE .)
    RBRACKET        reduce using rule 159 (expr -> CONST_DOUBLE .)
    COLON           reduce using rule 159 (expr -> CONST_DOUBLE .)



state 24

    (11) func_decl -> FUNCTION . STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE

    STRING          shift and go to state 78



state 25

    (33) stmt -> FOR . LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt

    LPAREN          shift and go to state 79



state 26

    (20) stmt -> alt_if_stmt .

    WHILE           reduce using rule 20 (stmt -> alt_if_stmt .)
    DO              reduce using rule 20 (stmt -> alt_if_stmt .)
    FOR             reduce using rule 20 (stmt -> alt_if_stmt .)
    FOREACH         reduce using rule 20 (stmt -> alt_if_stmt .)
    SWITCH          reduce using rule 20 (stmt -> alt_if_stmt .)
    BREAK           reduce using rule 20 (stmt -> alt_if_stmt .)
    CONTINUE        reduce using rule 20 (stmt -> alt_if_stmt .)
    RETURN          reduce using rule 20 (stmt -> alt_if_stmt .)
    GLOBAL          reduce using rule 20 (stmt -> alt_if_stmt .)
    STATIC          reduce using rule 20 (stmt -> alt_if_stmt .)
    ECHO            reduce using rule 20 (stmt -> alt_if_stmt .)
    LBRACE          reduce using rule 20 (stmt -> alt_if_stmt .)
    SEMICOLON       reduce using rule 20 (stmt -> alt_if_stmt .)
    FUNCTION        reduce using rule 20 (stmt -> alt_if_stmt .)
    CLONE           reduce using rule 20 (stmt -> alt_if_stmt .)
    ARRAY           reduce using rule 20 (stmt -> alt_if_stmt .)
    PLUS            reduce using rule 20 (stmt -> alt_if_stmt .)
    MINUS           reduce using rule 20 (stmt -> alt_if_stmt .)
    BIT_NOT         reduce using rule 20 (stmt -> alt_if_stmt .)
    NOT             reduce using rule 20 (stmt -> alt_if_stmt .)
    CONST_DECIMAL   reduce using rule 20 (stmt -> alt_if_stmt .)
    CONST_DOUBLE    reduce using rule 20 (stmt -> alt_if_stmt .)
    CONST_STRING    reduce using rule 20 (stmt -> alt_if_stmt .)
    NULL            reduce using rule 20 (stmt -> alt_if_stmt .)
    TRUE            reduce using rule 20 (stmt -> alt_if_stmt .)
    FALSE           reduce using rule 20 (stmt -> alt_if_stmt .)
    INC             reduce using rule 20 (stmt -> alt_if_stmt .)
    DEC             reduce using rule 20 (stmt -> alt_if_stmt .)
    EMPTY           reduce using rule 20 (stmt -> alt_if_stmt .)
    EVAL            reduce using rule 20 (stmt -> alt_if_stmt .)
    LPAREN          reduce using rule 20 (stmt -> alt_if_stmt .)
    INCLUDE         reduce using rule 20 (stmt -> alt_if_stmt .)
    INCLUDE_ONCE    reduce using rule 20 (stmt -> alt_if_stmt .)
    REQUIRE         reduce using rule 20 (stmt -> alt_if_stmt .)
    REQUIRE_ONCE    reduce using rule 20 (stmt -> alt_if_stmt .)
    EXIT            reduce using rule 20 (stmt -> alt_if_stmt .)
    PRINT           reduce using rule 20 (stmt -> alt_if_stmt .)
    IF              reduce using rule 20 (stmt -> alt_if_stmt .)
    IDENTIFIER      reduce using rule 20 (stmt -> alt_if_stmt .)
    STRING          reduce using rule 20 (stmt -> alt_if_stmt .)
    ENDIF           reduce using rule 20 (stmt -> alt_if_stmt .)
    ELSE            reduce using rule 20 (stmt -> alt_if_stmt .)
    ELSEIF          reduce using rule 20 (stmt -> alt_if_stmt .)
    RBRACE          reduce using rule 20 (stmt -> alt_if_stmt .)
    VAR             reduce using rule 20 (stmt -> alt_if_stmt .)
    $end            reduce using rule 20 (stmt -> alt_if_stmt .)
    ENDWHILE        reduce using rule 20 (stmt -> alt_if_stmt .)
    ENDFOREACH      reduce using rule 20 (stmt -> alt_if_stmt .)
    CASE            reduce using rule 20 (stmt -> alt_if_stmt .)
    DEFAULT         reduce using rule 20 (stmt -> alt_if_stmt .)
    ENDSWITCH       reduce using rule 20 (stmt -> alt_if_stmt .)
    ENDFOR          reduce using rule 20 (stmt -> alt_if_stmt .)



state 27

    (4) top_stmt -> stmt .

    VAR             reduce using rule 4 (top_stmt -> stmt .)
    WHILE           reduce using rule 4 (top_stmt -> stmt .)
    DO              reduce using rule 4 (top_stmt -> stmt .)
    FOR             reduce using rule 4 (top_stmt -> stmt .)
    FOREACH         reduce using rule 4 (top_stmt -> stmt .)
    SWITCH          reduce using rule 4 (top_stmt -> stmt .)
    BREAK           reduce using rule 4 (top_stmt -> stmt .)
    CONTINUE        reduce using rule 4 (top_stmt -> stmt .)
    RETURN          reduce using rule 4 (top_stmt -> stmt .)
    GLOBAL          reduce using rule 4 (top_stmt -> stmt .)
    STATIC          reduce using rule 4 (top_stmt -> stmt .)
    ECHO            reduce using rule 4 (top_stmt -> stmt .)
    LBRACE          reduce using rule 4 (top_stmt -> stmt .)
    SEMICOLON       reduce using rule 4 (top_stmt -> stmt .)
    FUNCTION        reduce using rule 4 (top_stmt -> stmt .)
    CLONE           reduce using rule 4 (top_stmt -> stmt .)
    ARRAY           reduce using rule 4 (top_stmt -> stmt .)
    PLUS            reduce using rule 4 (top_stmt -> stmt .)
    MINUS           reduce using rule 4 (top_stmt -> stmt .)
    BIT_NOT         reduce using rule 4 (top_stmt -> stmt .)
    NOT             reduce using rule 4 (top_stmt -> stmt .)
    CONST_DECIMAL   reduce using rule 4 (top_stmt -> stmt .)
    CONST_DOUBLE    reduce using rule 4 (top_stmt -> stmt .)
    CONST_STRING    reduce using rule 4 (top_stmt -> stmt .)
    NULL            reduce using rule 4 (top_stmt -> stmt .)
    TRUE            reduce using rule 4 (top_stmt -> stmt .)
    FALSE           reduce using rule 4 (top_stmt -> stmt .)
    INC             reduce using rule 4 (top_stmt -> stmt .)
    DEC             reduce using rule 4 (top_stmt -> stmt .)
    EMPTY           reduce using rule 4 (top_stmt -> stmt .)
    EVAL            reduce using rule 4 (top_stmt -> stmt .)
    LPAREN          reduce using rule 4 (top_stmt -> stmt .)
    INCLUDE         reduce using rule 4 (top_stmt -> stmt .)
    INCLUDE_ONCE    reduce using rule 4 (top_stmt -> stmt .)
    REQUIRE         reduce using rule 4 (top_stmt -> stmt .)
    REQUIRE_ONCE    reduce using rule 4 (top_stmt -> stmt .)
    EXIT            reduce using rule 4 (top_stmt -> stmt .)
    PRINT           reduce using rule 4 (top_stmt -> stmt .)
    IF              reduce using rule 4 (top_stmt -> stmt .)
    IDENTIFIER      reduce using rule 4 (top_stmt -> stmt .)
    STRING          reduce using rule 4 (top_stmt -> stmt .)
    $end            reduce using rule 4 (top_stmt -> stmt .)



state 28

    (71) stmt -> ECHO . echo_expr_list SEMICOLON
    (72) echo_expr_list -> . echo_expr_list COMMA expr
    (73) echo_expr_list -> . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    echo_expr_list                 shift and go to state 80
    expr                           shift and go to state 81
    variable                       shift and go to state 53

state 29

    (175) expr -> REQUIRE_ONCE . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 82
    variable                       shift and go to state 53

state 30

    (74) stmt -> LBRACE . inner_stmts RBRACE
    (77) inner_stmts -> . inner_stmts inner_stmt
    (78) inner_stmts -> . empty
    (180) empty -> .

    RBRACE          reduce using rule 180 (empty -> .)
    WHILE           reduce using rule 180 (empty -> .)
    DO              reduce using rule 180 (empty -> .)
    FOR             reduce using rule 180 (empty -> .)
    FOREACH         reduce using rule 180 (empty -> .)
    SWITCH          reduce using rule 180 (empty -> .)
    BREAK           reduce using rule 180 (empty -> .)
    CONTINUE        reduce using rule 180 (empty -> .)
    RETURN          reduce using rule 180 (empty -> .)
    GLOBAL          reduce using rule 180 (empty -> .)
    STATIC          reduce using rule 180 (empty -> .)
    ECHO            reduce using rule 180 (empty -> .)
    LBRACE          reduce using rule 180 (empty -> .)
    SEMICOLON       reduce using rule 180 (empty -> .)
    FUNCTION        reduce using rule 180 (empty -> .)
    CLONE           reduce using rule 180 (empty -> .)
    ARRAY           reduce using rule 180 (empty -> .)
    PLUS            reduce using rule 180 (empty -> .)
    MINUS           reduce using rule 180 (empty -> .)
    BIT_NOT         reduce using rule 180 (empty -> .)
    NOT             reduce using rule 180 (empty -> .)
    CONST_DECIMAL   reduce using rule 180 (empty -> .)
    CONST_DOUBLE    reduce using rule 180 (empty -> .)
    CONST_STRING    reduce using rule 180 (empty -> .)
    NULL            reduce using rule 180 (empty -> .)
    TRUE            reduce using rule 180 (empty -> .)
    FALSE           reduce using rule 180 (empty -> .)
    INC             reduce using rule 180 (empty -> .)
    DEC             reduce using rule 180 (empty -> .)
    EMPTY           reduce using rule 180 (empty -> .)
    EVAL            reduce using rule 180 (empty -> .)
    LPAREN          reduce using rule 180 (empty -> .)
    INCLUDE         reduce using rule 180 (empty -> .)
    INCLUDE_ONCE    reduce using rule 180 (empty -> .)
    REQUIRE         reduce using rule 180 (empty -> .)
    REQUIRE_ONCE    reduce using rule 180 (empty -> .)
    EXIT            reduce using rule 180 (empty -> .)
    PRINT           reduce using rule 180 (empty -> .)
    IF              reduce using rule 180 (empty -> .)
    IDENTIFIER      reduce using rule 180 (empty -> .)
    STRING          reduce using rule 180 (empty -> .)


    inner_stmts                    shift and go to state 83
    empty                          shift and go to state 84

state 31

    (59) stmt -> CONTINUE . SEMICOLON
    (60) stmt -> CONTINUE . expr SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    SEMICOLON       shift and go to state 85
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 86
    variable                       shift and go to state 53

state 32

    (157) expr -> NOT . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 87
    variable                       shift and go to state 53

state 33

    (63) stmt -> GLOBAL . global_var_list SEMICOLON
    (64) global_var_list -> . global_var_list COMMA IDENTIFIER
    (65) global_var_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 88


    global_var_list                shift and go to state 89

state 34

    (29) stmt -> WHILE . LPAREN expr RPAREN while_stmt

    LPAREN          shift and go to state 90



state 35

    (172) expr -> INCLUDE . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 91
    variable                       shift and go to state 53

state 36

    (75) stmt -> SEMICOLON .

    WHILE           reduce using rule 75 (stmt -> SEMICOLON .)
    DO              reduce using rule 75 (stmt -> SEMICOLON .)
    FOR             reduce using rule 75 (stmt -> SEMICOLON .)
    FOREACH         reduce using rule 75 (stmt -> SEMICOLON .)
    SWITCH          reduce using rule 75 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 75 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 75 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 75 (stmt -> SEMICOLON .)
    GLOBAL          reduce using rule 75 (stmt -> SEMICOLON .)
    STATIC          reduce using rule 75 (stmt -> SEMICOLON .)
    ECHO            reduce using rule 75 (stmt -> SEMICOLON .)
    LBRACE          reduce using rule 75 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 75 (stmt -> SEMICOLON .)
    FUNCTION        reduce using rule 75 (stmt -> SEMICOLON .)
    CLONE           reduce using rule 75 (stmt -> SEMICOLON .)
    ARRAY           reduce using rule 75 (stmt -> SEMICOLON .)
    PLUS            reduce using rule 75 (stmt -> SEMICOLON .)
    MINUS           reduce using rule 75 (stmt -> SEMICOLON .)
    BIT_NOT         reduce using rule 75 (stmt -> SEMICOLON .)
    NOT             reduce using rule 75 (stmt -> SEMICOLON .)
    CONST_DECIMAL   reduce using rule 75 (stmt -> SEMICOLON .)
    CONST_DOUBLE    reduce using rule 75 (stmt -> SEMICOLON .)
    CONST_STRING    reduce using rule 75 (stmt -> SEMICOLON .)
    NULL            reduce using rule 75 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 75 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 75 (stmt -> SEMICOLON .)
    INC             reduce using rule 75 (stmt -> SEMICOLON .)
    DEC             reduce using rule 75 (stmt -> SEMICOLON .)
    EMPTY           reduce using rule 75 (stmt -> SEMICOLON .)
    EVAL            reduce using rule 75 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 75 (stmt -> SEMICOLON .)
    INCLUDE         reduce using rule 75 (stmt -> SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 75 (stmt -> SEMICOLON .)
    REQUIRE         reduce using rule 75 (stmt -> SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 75 (stmt -> SEMICOLON .)
    EXIT            reduce using rule 75 (stmt -> SEMICOLON .)
    PRINT           reduce using rule 75 (stmt -> SEMICOLON .)
    IF              reduce using rule 75 (stmt -> SEMICOLON .)
    IDENTIFIER      reduce using rule 75 (stmt -> SEMICOLON .)
    STRING          reduce using rule 75 (stmt -> SEMICOLON .)
    ENDIF           reduce using rule 75 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 75 (stmt -> SEMICOLON .)
    ELSEIF          reduce using rule 75 (stmt -> SEMICOLON .)
    RBRACE          reduce using rule 75 (stmt -> SEMICOLON .)
    VAR             reduce using rule 75 (stmt -> SEMICOLON .)
    $end            reduce using rule 75 (stmt -> SEMICOLON .)
    ENDWHILE        reduce using rule 75 (stmt -> SEMICOLON .)
    ENDFOREACH      reduce using rule 75 (stmt -> SEMICOLON .)
    CASE            reduce using rule 75 (stmt -> SEMICOLON .)
    DEFAULT         reduce using rule 75 (stmt -> SEMICOLON .)
    ENDSWITCH       reduce using rule 75 (stmt -> SEMICOLON .)
    ENDFOR          reduce using rule 75 (stmt -> SEMICOLON .)



state 37

    (47) stmt -> SWITCH . LPAREN expr RPAREN switch_stmt

    LPAREN          shift and go to state 92



state 38

    (113) expr -> ARRAY . LPAREN array_pair_list RPAREN

    LPAREN          shift and go to state 93



state 39

    (92) base_var -> IDENTIFIER .

    LBRACKET        reduce using rule 92 (base_var -> IDENTIFIER .)
    LBRACE          reduce using rule 92 (base_var -> IDENTIFIER .)
    EQUAL           reduce using rule 92 (base_var -> IDENTIFIER .)
    PLUS_EQ         reduce using rule 92 (base_var -> IDENTIFIER .)
    MINUS_EQ        reduce using rule 92 (base_var -> IDENTIFIER .)
    MULTIPLY_EQ     reduce using rule 92 (base_var -> IDENTIFIER .)
    DIVIDE_EQ       reduce using rule 92 (base_var -> IDENTIFIER .)
    DOT_EQ          reduce using rule 92 (base_var -> IDENTIFIER .)
    MOD_EQ          reduce using rule 92 (base_var -> IDENTIFIER .)
    INC             reduce using rule 92 (base_var -> IDENTIFIER .)
    DEC             reduce using rule 92 (base_var -> IDENTIFIER .)
    AND_OP          reduce using rule 92 (base_var -> IDENTIFIER .)
    OR_OP           reduce using rule 92 (base_var -> IDENTIFIER .)
    BIT_OR          reduce using rule 92 (base_var -> IDENTIFIER .)
    BIT_XOR         reduce using rule 92 (base_var -> IDENTIFIER .)
    BIT_AND         reduce using rule 92 (base_var -> IDENTIFIER .)
    DOT             reduce using rule 92 (base_var -> IDENTIFIER .)
    PLUS            reduce using rule 92 (base_var -> IDENTIFIER .)
    MINUS           reduce using rule 92 (base_var -> IDENTIFIER .)
    MULT            reduce using rule 92 (base_var -> IDENTIFIER .)
    DIV             reduce using rule 92 (base_var -> IDENTIFIER .)
    BIT_LSHIFT      reduce using rule 92 (base_var -> IDENTIFIER .)
    BIT_RSHIFT      reduce using rule 92 (base_var -> IDENTIFIER .)
    MOD             reduce using rule 92 (base_var -> IDENTIFIER .)
    IDENTICAL       reduce using rule 92 (base_var -> IDENTIFIER .)
    NOT_IDENTICAL   reduce using rule 92 (base_var -> IDENTIFIER .)
    EQ_EQ           reduce using rule 92 (base_var -> IDENTIFIER .)
    NOT_EQ          reduce using rule 92 (base_var -> IDENTIFIER .)
    LESSER          reduce using rule 92 (base_var -> IDENTIFIER .)
    LESSER_EQ       reduce using rule 92 (base_var -> IDENTIFIER .)
    GREATER         reduce using rule 92 (base_var -> IDENTIFIER .)
    GREATER_EQ      reduce using rule 92 (base_var -> IDENTIFIER .)
    INSTANCEOF      reduce using rule 92 (base_var -> IDENTIFIER .)
    COND_OP         reduce using rule 92 (base_var -> IDENTIFIER .)
    SEMICOLON       reduce using rule 92 (base_var -> IDENTIFIER .)
    COMMA           reduce using rule 92 (base_var -> IDENTIFIER .)
    RPAREN          reduce using rule 92 (base_var -> IDENTIFIER .)
    AS              reduce using rule 92 (base_var -> IDENTIFIER .)
    DOUBLE_ARROW    reduce using rule 92 (base_var -> IDENTIFIER .)
    RBRACE          reduce using rule 92 (base_var -> IDENTIFIER .)
    RBRACKET        reduce using rule 92 (base_var -> IDENTIFIER .)
    COLON           reduce using rule 92 (base_var -> IDENTIFIER .)



state 40

    (83) variable -> func_call .

    EQUAL           reduce using rule 83 (variable -> func_call .)
    PLUS_EQ         reduce using rule 83 (variable -> func_call .)
    MINUS_EQ        reduce using rule 83 (variable -> func_call .)
    MULTIPLY_EQ     reduce using rule 83 (variable -> func_call .)
    DIVIDE_EQ       reduce using rule 83 (variable -> func_call .)
    DOT_EQ          reduce using rule 83 (variable -> func_call .)
    MOD_EQ          reduce using rule 83 (variable -> func_call .)
    INC             reduce using rule 83 (variable -> func_call .)
    DEC             reduce using rule 83 (variable -> func_call .)
    RPAREN          reduce using rule 83 (variable -> func_call .)
    AND_OP          reduce using rule 83 (variable -> func_call .)
    OR_OP           reduce using rule 83 (variable -> func_call .)
    BIT_OR          reduce using rule 83 (variable -> func_call .)
    BIT_XOR         reduce using rule 83 (variable -> func_call .)
    BIT_AND         reduce using rule 83 (variable -> func_call .)
    DOT             reduce using rule 83 (variable -> func_call .)
    PLUS            reduce using rule 83 (variable -> func_call .)
    MINUS           reduce using rule 83 (variable -> func_call .)
    MULT            reduce using rule 83 (variable -> func_call .)
    DIV             reduce using rule 83 (variable -> func_call .)
    BIT_LSHIFT      reduce using rule 83 (variable -> func_call .)
    BIT_RSHIFT      reduce using rule 83 (variable -> func_call .)
    MOD             reduce using rule 83 (variable -> func_call .)
    IDENTICAL       reduce using rule 83 (variable -> func_call .)
    NOT_IDENTICAL   reduce using rule 83 (variable -> func_call .)
    EQ_EQ           reduce using rule 83 (variable -> func_call .)
    NOT_EQ          reduce using rule 83 (variable -> func_call .)
    LESSER          reduce using rule 83 (variable -> func_call .)
    LESSER_EQ       reduce using rule 83 (variable -> func_call .)
    GREATER         reduce using rule 83 (variable -> func_call .)
    GREATER_EQ      reduce using rule 83 (variable -> func_call .)
    INSTANCEOF      reduce using rule 83 (variable -> func_call .)
    COND_OP         reduce using rule 83 (variable -> func_call .)
    SEMICOLON       reduce using rule 83 (variable -> func_call .)
    COMMA           reduce using rule 83 (variable -> func_call .)
    AS              reduce using rule 83 (variable -> func_call .)
    DOUBLE_ARROW    reduce using rule 83 (variable -> func_call .)
    RBRACE          reduce using rule 83 (variable -> func_call .)
    RBRACKET        reduce using rule 83 (variable -> func_call .)
    COLON           reduce using rule 83 (variable -> func_call .)



state 41

    (5) top_stmt -> func_decl .

    VAR             reduce using rule 5 (top_stmt -> func_decl .)
    WHILE           reduce using rule 5 (top_stmt -> func_decl .)
    DO              reduce using rule 5 (top_stmt -> func_decl .)
    FOR             reduce using rule 5 (top_stmt -> func_decl .)
    FOREACH         reduce using rule 5 (top_stmt -> func_decl .)
    SWITCH          reduce using rule 5 (top_stmt -> func_decl .)
    BREAK           reduce using rule 5 (top_stmt -> func_decl .)
    CONTINUE        reduce using rule 5 (top_stmt -> func_decl .)
    RETURN          reduce using rule 5 (top_stmt -> func_decl .)
    GLOBAL          reduce using rule 5 (top_stmt -> func_decl .)
    STATIC          reduce using rule 5 (top_stmt -> func_decl .)
    ECHO            reduce using rule 5 (top_stmt -> func_decl .)
    LBRACE          reduce using rule 5 (top_stmt -> func_decl .)
    SEMICOLON       reduce using rule 5 (top_stmt -> func_decl .)
    FUNCTION        reduce using rule 5 (top_stmt -> func_decl .)
    CLONE           reduce using rule 5 (top_stmt -> func_decl .)
    ARRAY           reduce using rule 5 (top_stmt -> func_decl .)
    PLUS            reduce using rule 5 (top_stmt -> func_decl .)
    MINUS           reduce using rule 5 (top_stmt -> func_decl .)
    BIT_NOT         reduce using rule 5 (top_stmt -> func_decl .)
    NOT             reduce using rule 5 (top_stmt -> func_decl .)
    CONST_DECIMAL   reduce using rule 5 (top_stmt -> func_decl .)
    CONST_DOUBLE    reduce using rule 5 (top_stmt -> func_decl .)
    CONST_STRING    reduce using rule 5 (top_stmt -> func_decl .)
    NULL            reduce using rule 5 (top_stmt -> func_decl .)
    TRUE            reduce using rule 5 (top_stmt -> func_decl .)
    FALSE           reduce using rule 5 (top_stmt -> func_decl .)
    INC             reduce using rule 5 (top_stmt -> func_decl .)
    DEC             reduce using rule 5 (top_stmt -> func_decl .)
    EMPTY           reduce using rule 5 (top_stmt -> func_decl .)
    EVAL            reduce using rule 5 (top_stmt -> func_decl .)
    LPAREN          reduce using rule 5 (top_stmt -> func_decl .)
    INCLUDE         reduce using rule 5 (top_stmt -> func_decl .)
    INCLUDE_ONCE    reduce using rule 5 (top_stmt -> func_decl .)
    REQUIRE         reduce using rule 5 (top_stmt -> func_decl .)
    REQUIRE_ONCE    reduce using rule 5 (top_stmt -> func_decl .)
    EXIT            reduce using rule 5 (top_stmt -> func_decl .)
    PRINT           reduce using rule 5 (top_stmt -> func_decl .)
    IF              reduce using rule 5 (top_stmt -> func_decl .)
    IDENTIFIER      reduce using rule 5 (top_stmt -> func_decl .)
    STRING          reduce using rule 5 (top_stmt -> func_decl .)
    $end            reduce using rule 5 (top_stmt -> func_decl .)



state 42

    (21) if_stmt -> if_stmt_without_else .
    (22) if_stmt -> if_stmt_without_else . ELSE stmt
    (24) if_stmt_without_else -> if_stmt_without_else . ELSEIF LPAREN expr RPAREN stmt

    ENDFOREACH      reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    WHILE           reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    DO              reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    FOR             reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    FOREACH         reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    SWITCH          reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    BREAK           reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    CONTINUE        reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    RETURN          reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    GLOBAL          reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    STATIC          reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    ECHO            reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    LBRACE          reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    SEMICOLON       reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    FUNCTION        reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    CLONE           reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    ARRAY           reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    PLUS            reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    MINUS           reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    BIT_NOT         reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    NOT             reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    CONST_DECIMAL   reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    CONST_DOUBLE    reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    CONST_STRING    reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    NULL            reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    TRUE            reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    FALSE           reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    INC             reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    DEC             reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    EMPTY           reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    EVAL            reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    LPAREN          reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    INCLUDE         reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    INCLUDE_ONCE    reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    REQUIRE         reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    REQUIRE_ONCE    reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    EXIT            reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    PRINT           reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    IF              reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    IDENTIFIER      reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    STRING          reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    VAR             reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    $end            reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    RBRACE          reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    ENDIF           reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    ENDWHILE        reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    CASE            reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    DEFAULT         reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    ENDSWITCH       reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    ENDFOR          reduce using rule 21 (if_stmt -> if_stmt_without_else .)
    ELSE            shift and go to state 94
    ELSEIF          shift and go to state 95

  ! ELSE            [ reduce using rule 21 (if_stmt -> if_stmt_without_else .) ]
  ! ELSEIF          [ reduce using rule 21 (if_stmt -> if_stmt_without_else .) ]


state 43

    (82) variable -> base_var .
    (90) base_var -> base_var . LBRACKET dim_offset RBRACKET
    (91) base_var -> base_var . LBRACE expr RBRACE

    EQUAL           reduce using rule 82 (variable -> base_var .)
    PLUS_EQ         reduce using rule 82 (variable -> base_var .)
    MINUS_EQ        reduce using rule 82 (variable -> base_var .)
    MULTIPLY_EQ     reduce using rule 82 (variable -> base_var .)
    DIVIDE_EQ       reduce using rule 82 (variable -> base_var .)
    DOT_EQ          reduce using rule 82 (variable -> base_var .)
    MOD_EQ          reduce using rule 82 (variable -> base_var .)
    INC             reduce using rule 82 (variable -> base_var .)
    DEC             reduce using rule 82 (variable -> base_var .)
    RPAREN          reduce using rule 82 (variable -> base_var .)
    AND_OP          reduce using rule 82 (variable -> base_var .)
    OR_OP           reduce using rule 82 (variable -> base_var .)
    BIT_OR          reduce using rule 82 (variable -> base_var .)
    BIT_XOR         reduce using rule 82 (variable -> base_var .)
    BIT_AND         reduce using rule 82 (variable -> base_var .)
    DOT             reduce using rule 82 (variable -> base_var .)
    PLUS            reduce using rule 82 (variable -> base_var .)
    MINUS           reduce using rule 82 (variable -> base_var .)
    MULT            reduce using rule 82 (variable -> base_var .)
    DIV             reduce using rule 82 (variable -> base_var .)
    BIT_LSHIFT      reduce using rule 82 (variable -> base_var .)
    BIT_RSHIFT      reduce using rule 82 (variable -> base_var .)
    MOD             reduce using rule 82 (variable -> base_var .)
    IDENTICAL       reduce using rule 82 (variable -> base_var .)
    NOT_IDENTICAL   reduce using rule 82 (variable -> base_var .)
    EQ_EQ           reduce using rule 82 (variable -> base_var .)
    NOT_EQ          reduce using rule 82 (variable -> base_var .)
    LESSER          reduce using rule 82 (variable -> base_var .)
    LESSER_EQ       reduce using rule 82 (variable -> base_var .)
    GREATER         reduce using rule 82 (variable -> base_var .)
    GREATER_EQ      reduce using rule 82 (variable -> base_var .)
    INSTANCEOF      reduce using rule 82 (variable -> base_var .)
    COND_OP         reduce using rule 82 (variable -> base_var .)
    SEMICOLON       reduce using rule 82 (variable -> base_var .)
    COMMA           reduce using rule 82 (variable -> base_var .)
    AS              reduce using rule 82 (variable -> base_var .)
    DOUBLE_ARROW    reduce using rule 82 (variable -> base_var .)
    RBRACE          reduce using rule 82 (variable -> base_var .)
    RBRACKET        reduce using rule 82 (variable -> base_var .)
    COLON           reduce using rule 82 (variable -> base_var .)
    LBRACKET        shift and go to state 97
    LBRACE          shift and go to state 96



state 44

    (163) expr -> FALSE .

    SEMICOLON       reduce using rule 163 (expr -> FALSE .)
    AND_OP          reduce using rule 163 (expr -> FALSE .)
    OR_OP           reduce using rule 163 (expr -> FALSE .)
    BIT_OR          reduce using rule 163 (expr -> FALSE .)
    BIT_XOR         reduce using rule 163 (expr -> FALSE .)
    BIT_AND         reduce using rule 163 (expr -> FALSE .)
    DOT             reduce using rule 163 (expr -> FALSE .)
    PLUS            reduce using rule 163 (expr -> FALSE .)
    MINUS           reduce using rule 163 (expr -> FALSE .)
    MULT            reduce using rule 163 (expr -> FALSE .)
    DIV             reduce using rule 163 (expr -> FALSE .)
    BIT_LSHIFT      reduce using rule 163 (expr -> FALSE .)
    BIT_RSHIFT      reduce using rule 163 (expr -> FALSE .)
    MOD             reduce using rule 163 (expr -> FALSE .)
    IDENTICAL       reduce using rule 163 (expr -> FALSE .)
    NOT_IDENTICAL   reduce using rule 163 (expr -> FALSE .)
    EQ_EQ           reduce using rule 163 (expr -> FALSE .)
    NOT_EQ          reduce using rule 163 (expr -> FALSE .)
    LESSER          reduce using rule 163 (expr -> FALSE .)
    LESSER_EQ       reduce using rule 163 (expr -> FALSE .)
    GREATER         reduce using rule 163 (expr -> FALSE .)
    GREATER_EQ      reduce using rule 163 (expr -> FALSE .)
    INSTANCEOF      reduce using rule 163 (expr -> FALSE .)
    COND_OP         reduce using rule 163 (expr -> FALSE .)
    COMMA           reduce using rule 163 (expr -> FALSE .)
    RPAREN          reduce using rule 163 (expr -> FALSE .)
    AS              reduce using rule 163 (expr -> FALSE .)
    DOUBLE_ARROW    reduce using rule 163 (expr -> FALSE .)
    RBRACE          reduce using rule 163 (expr -> FALSE .)
    RBRACKET        reduce using rule 163 (expr -> FALSE .)
    COLON           reduce using rule 163 (expr -> FALSE .)



state 45

    (76) stmt -> expr . SEMICOLON
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       shift and go to state 105
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 46

    (160) expr -> CONST_STRING .

    SEMICOLON       reduce using rule 160 (expr -> CONST_STRING .)
    AND_OP          reduce using rule 160 (expr -> CONST_STRING .)
    OR_OP           reduce using rule 160 (expr -> CONST_STRING .)
    BIT_OR          reduce using rule 160 (expr -> CONST_STRING .)
    BIT_XOR         reduce using rule 160 (expr -> CONST_STRING .)
    BIT_AND         reduce using rule 160 (expr -> CONST_STRING .)
    DOT             reduce using rule 160 (expr -> CONST_STRING .)
    PLUS            reduce using rule 160 (expr -> CONST_STRING .)
    MINUS           reduce using rule 160 (expr -> CONST_STRING .)
    MULT            reduce using rule 160 (expr -> CONST_STRING .)
    DIV             reduce using rule 160 (expr -> CONST_STRING .)
    BIT_LSHIFT      reduce using rule 160 (expr -> CONST_STRING .)
    BIT_RSHIFT      reduce using rule 160 (expr -> CONST_STRING .)
    MOD             reduce using rule 160 (expr -> CONST_STRING .)
    IDENTICAL       reduce using rule 160 (expr -> CONST_STRING .)
    NOT_IDENTICAL   reduce using rule 160 (expr -> CONST_STRING .)
    EQ_EQ           reduce using rule 160 (expr -> CONST_STRING .)
    NOT_EQ          reduce using rule 160 (expr -> CONST_STRING .)
    LESSER          reduce using rule 160 (expr -> CONST_STRING .)
    LESSER_EQ       reduce using rule 160 (expr -> CONST_STRING .)
    GREATER         reduce using rule 160 (expr -> CONST_STRING .)
    GREATER_EQ      reduce using rule 160 (expr -> CONST_STRING .)
    INSTANCEOF      reduce using rule 160 (expr -> CONST_STRING .)
    COND_OP         reduce using rule 160 (expr -> CONST_STRING .)
    COMMA           reduce using rule 160 (expr -> CONST_STRING .)
    RPAREN          reduce using rule 160 (expr -> CONST_STRING .)
    AS              reduce using rule 160 (expr -> CONST_STRING .)
    DOUBLE_ARROW    reduce using rule 160 (expr -> CONST_STRING .)
    RBRACE          reduce using rule 160 (expr -> CONST_STRING .)
    RBRACKET        reduce using rule 160 (expr -> CONST_STRING .)
    COLON           reduce using rule 160 (expr -> CONST_STRING .)



state 47

    (57) stmt -> BREAK . SEMICOLON
    (58) stmt -> BREAK . expr SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    SEMICOLON       shift and go to state 122
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 123
    variable                       shift and go to state 53

state 48

    (176) expr -> EXIT .
    (177) expr -> EXIT . LPAREN RPAREN
    (178) expr -> EXIT . LPAREN expr RPAREN

    SEMICOLON       reduce using rule 176 (expr -> EXIT .)
    AND_OP          reduce using rule 176 (expr -> EXIT .)
    OR_OP           reduce using rule 176 (expr -> EXIT .)
    BIT_OR          reduce using rule 176 (expr -> EXIT .)
    BIT_XOR         reduce using rule 176 (expr -> EXIT .)
    BIT_AND         reduce using rule 176 (expr -> EXIT .)
    DOT             reduce using rule 176 (expr -> EXIT .)
    PLUS            reduce using rule 176 (expr -> EXIT .)
    MINUS           reduce using rule 176 (expr -> EXIT .)
    MULT            reduce using rule 176 (expr -> EXIT .)
    DIV             reduce using rule 176 (expr -> EXIT .)
    BIT_LSHIFT      reduce using rule 176 (expr -> EXIT .)
    BIT_RSHIFT      reduce using rule 176 (expr -> EXIT .)
    MOD             reduce using rule 176 (expr -> EXIT .)
    IDENTICAL       reduce using rule 176 (expr -> EXIT .)
    NOT_IDENTICAL   reduce using rule 176 (expr -> EXIT .)
    EQ_EQ           reduce using rule 176 (expr -> EXIT .)
    NOT_EQ          reduce using rule 176 (expr -> EXIT .)
    LESSER          reduce using rule 176 (expr -> EXIT .)
    LESSER_EQ       reduce using rule 176 (expr -> EXIT .)
    GREATER         reduce using rule 176 (expr -> EXIT .)
    GREATER_EQ      reduce using rule 176 (expr -> EXIT .)
    INSTANCEOF      reduce using rule 176 (expr -> EXIT .)
    COND_OP         reduce using rule 176 (expr -> EXIT .)
    COMMA           reduce using rule 176 (expr -> EXIT .)
    RPAREN          reduce using rule 176 (expr -> EXIT .)
    AS              reduce using rule 176 (expr -> EXIT .)
    DOUBLE_ARROW    reduce using rule 176 (expr -> EXIT .)
    RBRACE          reduce using rule 176 (expr -> EXIT .)
    RBRACKET        reduce using rule 176 (expr -> EXIT .)
    COLON           reduce using rule 176 (expr -> EXIT .)
    LPAREN          shift and go to state 124



state 49

    (32) stmt -> DO . stmt WHILE LPAREN expr RPAREN SEMICOLON
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 125
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 50

    (161) expr -> NULL .

    SEMICOLON       reduce using rule 161 (expr -> NULL .)
    AND_OP          reduce using rule 161 (expr -> NULL .)
    OR_OP           reduce using rule 161 (expr -> NULL .)
    BIT_OR          reduce using rule 161 (expr -> NULL .)
    BIT_XOR         reduce using rule 161 (expr -> NULL .)
    BIT_AND         reduce using rule 161 (expr -> NULL .)
    DOT             reduce using rule 161 (expr -> NULL .)
    PLUS            reduce using rule 161 (expr -> NULL .)
    MINUS           reduce using rule 161 (expr -> NULL .)
    MULT            reduce using rule 161 (expr -> NULL .)
    DIV             reduce using rule 161 (expr -> NULL .)
    BIT_LSHIFT      reduce using rule 161 (expr -> NULL .)
    BIT_RSHIFT      reduce using rule 161 (expr -> NULL .)
    MOD             reduce using rule 161 (expr -> NULL .)
    IDENTICAL       reduce using rule 161 (expr -> NULL .)
    NOT_IDENTICAL   reduce using rule 161 (expr -> NULL .)
    EQ_EQ           reduce using rule 161 (expr -> NULL .)
    NOT_EQ          reduce using rule 161 (expr -> NULL .)
    LESSER          reduce using rule 161 (expr -> NULL .)
    LESSER_EQ       reduce using rule 161 (expr -> NULL .)
    GREATER         reduce using rule 161 (expr -> NULL .)
    GREATER_EQ      reduce using rule 161 (expr -> NULL .)
    INSTANCEOF      reduce using rule 161 (expr -> NULL .)
    COND_OP         reduce using rule 161 (expr -> NULL .)
    COMMA           reduce using rule 161 (expr -> NULL .)
    RPAREN          reduce using rule 161 (expr -> NULL .)
    AS              reduce using rule 161 (expr -> NULL .)
    DOUBLE_ARROW    reduce using rule 161 (expr -> NULL .)
    RBRACE          reduce using rule 161 (expr -> NULL .)
    RBRACKET        reduce using rule 161 (expr -> NULL .)
    COLON           reduce using rule 161 (expr -> NULL .)



state 51

    (84) func_call -> STRING . LPAREN func_params RPAREN

    LPAREN          shift and go to state 126



state 52

    (171) expr -> LPAREN . expr RPAREN
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 127
    variable                       shift and go to state 53

state 53

    (81) expr -> variable .
    (95) expr -> variable . EQUAL expr
    (96) expr -> variable . EQUAL BIT_AND expr
    (126) expr -> variable . PLUS_EQ expr
    (127) expr -> variable . MINUS_EQ expr
    (128) expr -> variable . MULTIPLY_EQ expr
    (129) expr -> variable . DIVIDE_EQ expr
    (130) expr -> variable . DOT_EQ expr
    (131) expr -> variable . MOD_EQ expr
    (167) expr -> variable . INC
    (168) expr -> variable . DEC

    SEMICOLON       reduce using rule 81 (expr -> variable .)
    AND_OP          reduce using rule 81 (expr -> variable .)
    OR_OP           reduce using rule 81 (expr -> variable .)
    BIT_OR          reduce using rule 81 (expr -> variable .)
    BIT_XOR         reduce using rule 81 (expr -> variable .)
    BIT_AND         reduce using rule 81 (expr -> variable .)
    DOT             reduce using rule 81 (expr -> variable .)
    PLUS            reduce using rule 81 (expr -> variable .)
    MINUS           reduce using rule 81 (expr -> variable .)
    MULT            reduce using rule 81 (expr -> variable .)
    DIV             reduce using rule 81 (expr -> variable .)
    BIT_LSHIFT      reduce using rule 81 (expr -> variable .)
    BIT_RSHIFT      reduce using rule 81 (expr -> variable .)
    MOD             reduce using rule 81 (expr -> variable .)
    IDENTICAL       reduce using rule 81 (expr -> variable .)
    NOT_IDENTICAL   reduce using rule 81 (expr -> variable .)
    EQ_EQ           reduce using rule 81 (expr -> variable .)
    NOT_EQ          reduce using rule 81 (expr -> variable .)
    LESSER          reduce using rule 81 (expr -> variable .)
    LESSER_EQ       reduce using rule 81 (expr -> variable .)
    GREATER         reduce using rule 81 (expr -> variable .)
    GREATER_EQ      reduce using rule 81 (expr -> variable .)
    INSTANCEOF      reduce using rule 81 (expr -> variable .)
    COND_OP         reduce using rule 81 (expr -> variable .)
    COMMA           reduce using rule 81 (expr -> variable .)
    RPAREN          reduce using rule 81 (expr -> variable .)
    AS              reduce using rule 81 (expr -> variable .)
    DOUBLE_ARROW    reduce using rule 81 (expr -> variable .)
    RBRACE          reduce using rule 81 (expr -> variable .)
    RBRACKET        reduce using rule 81 (expr -> variable .)
    COLON           reduce using rule 81 (expr -> variable .)
    EQUAL           shift and go to state 131
    PLUS_EQ         shift and go to state 132
    MINUS_EQ        shift and go to state 134
    MULTIPLY_EQ     shift and go to state 129
    DIVIDE_EQ       shift and go to state 133
    DOT_EQ          shift and go to state 128
    MOD_EQ          shift and go to state 135
    INC             shift and go to state 136
    DEC             shift and go to state 130



state 54

    (23) if_stmt_without_else -> IF . LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> IF . LPAREN expr RPAREN COLON inner_stmts

    LPAREN          shift and go to state 137



state 55

    (165) expr -> INC . variable
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    base_var                       shift and go to state 43
    func_call                      shift and go to state 40
    variable                       shift and go to state 138

state 56

    (26) alt_if_stmt -> alt_if_stmt_without_else ELSE . COLON inner_stmts ENDIF SEMICOLON

    COLON           shift and go to state 139



state 57

    (25) alt_if_stmt -> alt_if_stmt_without_else ENDIF . SEMICOLON

    SEMICOLON       shift and go to state 140



state 58

    (28) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF . LPAREN expr RPAREN COLON inner_stmts

    LPAREN          shift and go to state 141



state 59

    (155) expr -> MINUS expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 155 (expr -> MINUS expr .)
    AND_OP          reduce using rule 155 (expr -> MINUS expr .)
    OR_OP           reduce using rule 155 (expr -> MINUS expr .)
    BIT_OR          reduce using rule 155 (expr -> MINUS expr .)
    BIT_XOR         reduce using rule 155 (expr -> MINUS expr .)
    BIT_AND         reduce using rule 155 (expr -> MINUS expr .)
    DOT             reduce using rule 155 (expr -> MINUS expr .)
    PLUS            reduce using rule 155 (expr -> MINUS expr .)
    MINUS           reduce using rule 155 (expr -> MINUS expr .)
    BIT_LSHIFT      reduce using rule 155 (expr -> MINUS expr .)
    BIT_RSHIFT      reduce using rule 155 (expr -> MINUS expr .)
    IDENTICAL       reduce using rule 155 (expr -> MINUS expr .)
    NOT_IDENTICAL   reduce using rule 155 (expr -> MINUS expr .)
    EQ_EQ           reduce using rule 155 (expr -> MINUS expr .)
    NOT_EQ          reduce using rule 155 (expr -> MINUS expr .)
    LESSER          reduce using rule 155 (expr -> MINUS expr .)
    LESSER_EQ       reduce using rule 155 (expr -> MINUS expr .)
    GREATER         reduce using rule 155 (expr -> MINUS expr .)
    GREATER_EQ      reduce using rule 155 (expr -> MINUS expr .)
    COND_OP         reduce using rule 155 (expr -> MINUS expr .)
    COMMA           reduce using rule 155 (expr -> MINUS expr .)
    RPAREN          reduce using rule 155 (expr -> MINUS expr .)
    AS              reduce using rule 155 (expr -> MINUS expr .)
    DOUBLE_ARROW    reduce using rule 155 (expr -> MINUS expr .)
    RBRACE          reduce using rule 155 (expr -> MINUS expr .)
    RBRACKET        reduce using rule 155 (expr -> MINUS expr .)
    COLON           reduce using rule 155 (expr -> MINUS expr .)
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    MOD             shift and go to state 121
    INSTANCEOF      shift and go to state 114

  ! MULT            [ reduce using rule 155 (expr -> MINUS expr .) ]
  ! DIV             [ reduce using rule 155 (expr -> MINUS expr .) ]
  ! MOD             [ reduce using rule 155 (expr -> MINUS expr .) ]
  ! INSTANCEOF      [ reduce using rule 155 (expr -> MINUS expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! DOT             [ shift and go to state 108 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 102 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 60

    (154) expr -> PLUS expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 154 (expr -> PLUS expr .)
    AND_OP          reduce using rule 154 (expr -> PLUS expr .)
    OR_OP           reduce using rule 154 (expr -> PLUS expr .)
    BIT_OR          reduce using rule 154 (expr -> PLUS expr .)
    BIT_XOR         reduce using rule 154 (expr -> PLUS expr .)
    BIT_AND         reduce using rule 154 (expr -> PLUS expr .)
    DOT             reduce using rule 154 (expr -> PLUS expr .)
    PLUS            reduce using rule 154 (expr -> PLUS expr .)
    MINUS           reduce using rule 154 (expr -> PLUS expr .)
    BIT_LSHIFT      reduce using rule 154 (expr -> PLUS expr .)
    BIT_RSHIFT      reduce using rule 154 (expr -> PLUS expr .)
    IDENTICAL       reduce using rule 154 (expr -> PLUS expr .)
    NOT_IDENTICAL   reduce using rule 154 (expr -> PLUS expr .)
    EQ_EQ           reduce using rule 154 (expr -> PLUS expr .)
    NOT_EQ          reduce using rule 154 (expr -> PLUS expr .)
    LESSER          reduce using rule 154 (expr -> PLUS expr .)
    LESSER_EQ       reduce using rule 154 (expr -> PLUS expr .)
    GREATER         reduce using rule 154 (expr -> PLUS expr .)
    GREATER_EQ      reduce using rule 154 (expr -> PLUS expr .)
    COND_OP         reduce using rule 154 (expr -> PLUS expr .)
    COMMA           reduce using rule 154 (expr -> PLUS expr .)
    RPAREN          reduce using rule 154 (expr -> PLUS expr .)
    AS              reduce using rule 154 (expr -> PLUS expr .)
    DOUBLE_ARROW    reduce using rule 154 (expr -> PLUS expr .)
    RBRACE          reduce using rule 154 (expr -> PLUS expr .)
    RBRACKET        reduce using rule 154 (expr -> PLUS expr .)
    COLON           reduce using rule 154 (expr -> PLUS expr .)
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    MOD             shift and go to state 121
    INSTANCEOF      shift and go to state 114

  ! MULT            [ reduce using rule 154 (expr -> PLUS expr .) ]
  ! DIV             [ reduce using rule 154 (expr -> PLUS expr .) ]
  ! MOD             [ reduce using rule 154 (expr -> PLUS expr .) ]
  ! INSTANCEOF      [ reduce using rule 154 (expr -> PLUS expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! DOT             [ shift and go to state 108 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 102 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 61

    (156) expr -> BIT_NOT expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 156 (expr -> BIT_NOT expr .)
    AND_OP          reduce using rule 156 (expr -> BIT_NOT expr .)
    OR_OP           reduce using rule 156 (expr -> BIT_NOT expr .)
    BIT_OR          reduce using rule 156 (expr -> BIT_NOT expr .)
    BIT_XOR         reduce using rule 156 (expr -> BIT_NOT expr .)
    BIT_AND         reduce using rule 156 (expr -> BIT_NOT expr .)
    DOT             reduce using rule 156 (expr -> BIT_NOT expr .)
    PLUS            reduce using rule 156 (expr -> BIT_NOT expr .)
    MINUS           reduce using rule 156 (expr -> BIT_NOT expr .)
    MULT            reduce using rule 156 (expr -> BIT_NOT expr .)
    DIV             reduce using rule 156 (expr -> BIT_NOT expr .)
    BIT_LSHIFT      reduce using rule 156 (expr -> BIT_NOT expr .)
    BIT_RSHIFT      reduce using rule 156 (expr -> BIT_NOT expr .)
    MOD             reduce using rule 156 (expr -> BIT_NOT expr .)
    IDENTICAL       reduce using rule 156 (expr -> BIT_NOT expr .)
    NOT_IDENTICAL   reduce using rule 156 (expr -> BIT_NOT expr .)
    EQ_EQ           reduce using rule 156 (expr -> BIT_NOT expr .)
    NOT_EQ          reduce using rule 156 (expr -> BIT_NOT expr .)
    LESSER          reduce using rule 156 (expr -> BIT_NOT expr .)
    LESSER_EQ       reduce using rule 156 (expr -> BIT_NOT expr .)
    GREATER         reduce using rule 156 (expr -> BIT_NOT expr .)
    GREATER_EQ      reduce using rule 156 (expr -> BIT_NOT expr .)
    INSTANCEOF      reduce using rule 156 (expr -> BIT_NOT expr .)
    COND_OP         reduce using rule 156 (expr -> BIT_NOT expr .)
    COMMA           reduce using rule 156 (expr -> BIT_NOT expr .)
    RPAREN          reduce using rule 156 (expr -> BIT_NOT expr .)
    AS              reduce using rule 156 (expr -> BIT_NOT expr .)
    DOUBLE_ARROW    reduce using rule 156 (expr -> BIT_NOT expr .)
    RBRACE          reduce using rule 156 (expr -> BIT_NOT expr .)
    RBRACKET        reduce using rule 156 (expr -> BIT_NOT expr .)
    COLON           reduce using rule 156 (expr -> BIT_NOT expr .)

  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! DOT             [ shift and go to state 108 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 102 ]
  ! MULT            [ shift and go to state 103 ]
  ! DIV             [ shift and go to state 100 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! MOD             [ shift and go to state 121 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! INSTANCEOF      [ shift and go to state 114 ]
  ! COND_OP         [ shift and go to state 116 ]


state 62

    (40) stmt -> FOREACH LPAREN . expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 142
    variable                       shift and go to state 53

state 63

    (170) expr -> EVAL LPAREN . expr RPAREN
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 143
    variable                       shift and go to state 53

state 64

    (6) top_stmt -> VAR const_decls . SEMICOLON
    (7) const_decls -> const_decls . COMMA const_decl

    SEMICOLON       shift and go to state 145
    COMMA           shift and go to state 144



state 65

    (8) const_decls -> const_decl .

    SEMICOLON       reduce using rule 8 (const_decls -> const_decl .)
    COMMA           reduce using rule 8 (const_decls -> const_decl .)



state 66

    (9) const_decl -> IDENTIFIER . EQUAL expr
    (10) const_decl -> IDENTIFIER .

    EQUAL           shift and go to state 146
    SEMICOLON       reduce using rule 10 (const_decl -> IDENTIFIER .)
    COMMA           reduce using rule 10 (const_decl -> IDENTIFIER .)



state 67

    (173) expr -> INCLUDE_ONCE expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 173 (expr -> INCLUDE_ONCE expr .)
    COMMA           reduce using rule 173 (expr -> INCLUDE_ONCE expr .)
    RPAREN          reduce using rule 173 (expr -> INCLUDE_ONCE expr .)
    AS              reduce using rule 173 (expr -> INCLUDE_ONCE expr .)
    DOUBLE_ARROW    reduce using rule 173 (expr -> INCLUDE_ONCE expr .)
    RBRACE          reduce using rule 173 (expr -> INCLUDE_ONCE expr .)
    RBRACKET        reduce using rule 173 (expr -> INCLUDE_ONCE expr .)
    COLON           reduce using rule 173 (expr -> INCLUDE_ONCE expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! OR_OP           [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_OR          [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_XOR         [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_AND         [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! DOT             [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! PLUS            [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! MINUS           [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! MULT            [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! DIV             [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! MOD             [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! IDENTICAL       [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! EQ_EQ           [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! NOT_EQ          [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! LESSER          [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! LESSER_EQ       [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! GREATER         [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! GREATER_EQ      [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! INSTANCEOF      [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]
  ! COND_OP         [ reduce using rule 173 (expr -> INCLUDE_ONCE expr .) ]


state 68

    (97) expr -> CLONE expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 97 (expr -> CLONE expr .)
    AND_OP          reduce using rule 97 (expr -> CLONE expr .)
    OR_OP           reduce using rule 97 (expr -> CLONE expr .)
    BIT_OR          reduce using rule 97 (expr -> CLONE expr .)
    BIT_XOR         reduce using rule 97 (expr -> CLONE expr .)
    BIT_AND         reduce using rule 97 (expr -> CLONE expr .)
    DOT             reduce using rule 97 (expr -> CLONE expr .)
    PLUS            reduce using rule 97 (expr -> CLONE expr .)
    MINUS           reduce using rule 97 (expr -> CLONE expr .)
    MULT            reduce using rule 97 (expr -> CLONE expr .)
    DIV             reduce using rule 97 (expr -> CLONE expr .)
    BIT_LSHIFT      reduce using rule 97 (expr -> CLONE expr .)
    BIT_RSHIFT      reduce using rule 97 (expr -> CLONE expr .)
    MOD             reduce using rule 97 (expr -> CLONE expr .)
    IDENTICAL       reduce using rule 97 (expr -> CLONE expr .)
    NOT_IDENTICAL   reduce using rule 97 (expr -> CLONE expr .)
    EQ_EQ           reduce using rule 97 (expr -> CLONE expr .)
    NOT_EQ          reduce using rule 97 (expr -> CLONE expr .)
    LESSER          reduce using rule 97 (expr -> CLONE expr .)
    LESSER_EQ       reduce using rule 97 (expr -> CLONE expr .)
    GREATER         reduce using rule 97 (expr -> CLONE expr .)
    GREATER_EQ      reduce using rule 97 (expr -> CLONE expr .)
    INSTANCEOF      reduce using rule 97 (expr -> CLONE expr .)
    COND_OP         reduce using rule 97 (expr -> CLONE expr .)
    COMMA           reduce using rule 97 (expr -> CLONE expr .)
    RPAREN          reduce using rule 97 (expr -> CLONE expr .)
    AS              reduce using rule 97 (expr -> CLONE expr .)
    DOUBLE_ARROW    reduce using rule 97 (expr -> CLONE expr .)
    RBRACE          reduce using rule 97 (expr -> CLONE expr .)
    RBRACKET        reduce using rule 97 (expr -> CLONE expr .)
    COLON           reduce using rule 97 (expr -> CLONE expr .)

  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! DOT             [ shift and go to state 108 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 102 ]
  ! MULT            [ shift and go to state 103 ]
  ! DIV             [ shift and go to state 100 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! MOD             [ shift and go to state 121 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! INSTANCEOF      [ shift and go to state 114 ]
  ! COND_OP         [ shift and go to state 116 ]


state 69

    (61) stmt -> RETURN SEMICOLON .

    WHILE           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    DO              reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    FOREACH         reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    SWITCH          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    GLOBAL          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    STATIC          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    ECHO            reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    FUNCTION        reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    CLONE           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    ARRAY           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    PLUS            reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    MINUS           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    BIT_NOT         reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    NOT             reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    CONST_DECIMAL   reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    CONST_DOUBLE    reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    CONST_STRING    reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    NULL            reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    TRUE            reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    FALSE           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    INC             reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    DEC             reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    EMPTY           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    EVAL            reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    INCLUDE         reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    REQUIRE         reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    EXIT            reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    PRINT           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    IDENTIFIER      reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    STRING          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    ENDIF           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    ELSEIF          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    VAR             reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    $end            reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    ENDWHILE        reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    ENDFOREACH      reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    CASE            reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    DEFAULT         reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    ENDSWITCH       reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    ENDFOR          reduce using rule 61 (stmt -> RETURN SEMICOLON .)



state 70

    (62) stmt -> RETURN expr . SEMICOLON
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       shift and go to state 147
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 71

    (174) expr -> REQUIRE expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 174 (expr -> REQUIRE expr .)
    COMMA           reduce using rule 174 (expr -> REQUIRE expr .)
    RPAREN          reduce using rule 174 (expr -> REQUIRE expr .)
    AS              reduce using rule 174 (expr -> REQUIRE expr .)
    DOUBLE_ARROW    reduce using rule 174 (expr -> REQUIRE expr .)
    RBRACE          reduce using rule 174 (expr -> REQUIRE expr .)
    RBRACKET        reduce using rule 174 (expr -> REQUIRE expr .)
    COLON           reduce using rule 174 (expr -> REQUIRE expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! OR_OP           [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! BIT_OR          [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! BIT_XOR         [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! BIT_AND         [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! DOT             [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! PLUS            [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! MINUS           [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! MULT            [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! DIV             [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! MOD             [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! IDENTICAL       [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! EQ_EQ           [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! NOT_EQ          [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! LESSER          [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! LESSER_EQ       [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! GREATER         [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! GREATER_EQ      [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! INSTANCEOF      [ reduce using rule 174 (expr -> REQUIRE expr .) ]
  ! COND_OP         [ reduce using rule 174 (expr -> REQUIRE expr .) ]


state 72

    (68) static_var_list -> static_var .

    SEMICOLON       reduce using rule 68 (static_var_list -> static_var .)
    COMMA           reduce using rule 68 (static_var_list -> static_var .)



state 73

    (66) stmt -> STATIC static_var_list . SEMICOLON
    (67) static_var_list -> static_var_list . COMMA static_var

    SEMICOLON       shift and go to state 149
    COMMA           shift and go to state 148



state 74

    (69) static_var -> IDENTIFIER . EQUAL scalar
    (70) static_var -> IDENTIFIER .

    EQUAL           shift and go to state 150
    SEMICOLON       reduce using rule 70 (static_var -> IDENTIFIER .)
    COMMA           reduce using rule 70 (static_var -> IDENTIFIER .)



state 75

    (179) expr -> PRINT expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 179 (expr -> PRINT expr .)
    BIT_OR          reduce using rule 179 (expr -> PRINT expr .)
    BIT_XOR         reduce using rule 179 (expr -> PRINT expr .)
    BIT_AND         reduce using rule 179 (expr -> PRINT expr .)
    COMMA           reduce using rule 179 (expr -> PRINT expr .)
    RPAREN          reduce using rule 179 (expr -> PRINT expr .)
    AS              reduce using rule 179 (expr -> PRINT expr .)
    DOUBLE_ARROW    reduce using rule 179 (expr -> PRINT expr .)
    RBRACE          reduce using rule 179 (expr -> PRINT expr .)
    RBRACKET        reduce using rule 179 (expr -> PRINT expr .)
    COLON           reduce using rule 179 (expr -> PRINT expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! OR_OP           [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! DOT             [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! PLUS            [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! MINUS           [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! MULT            [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! DIV             [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! MOD             [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! IDENTICAL       [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! EQ_EQ           [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! NOT_EQ          [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! LESSER          [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! LESSER_EQ       [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! GREATER         [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! GREATER_EQ      [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! INSTANCEOF      [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! COND_OP         [ reduce using rule 179 (expr -> PRINT expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]


state 76

    (166) expr -> DEC variable .

    SEMICOLON       reduce using rule 166 (expr -> DEC variable .)
    AND_OP          reduce using rule 166 (expr -> DEC variable .)
    OR_OP           reduce using rule 166 (expr -> DEC variable .)
    BIT_OR          reduce using rule 166 (expr -> DEC variable .)
    BIT_XOR         reduce using rule 166 (expr -> DEC variable .)
    BIT_AND         reduce using rule 166 (expr -> DEC variable .)
    DOT             reduce using rule 166 (expr -> DEC variable .)
    PLUS            reduce using rule 166 (expr -> DEC variable .)
    MINUS           reduce using rule 166 (expr -> DEC variable .)
    MULT            reduce using rule 166 (expr -> DEC variable .)
    DIV             reduce using rule 166 (expr -> DEC variable .)
    BIT_LSHIFT      reduce using rule 166 (expr -> DEC variable .)
    BIT_RSHIFT      reduce using rule 166 (expr -> DEC variable .)
    MOD             reduce using rule 166 (expr -> DEC variable .)
    IDENTICAL       reduce using rule 166 (expr -> DEC variable .)
    NOT_IDENTICAL   reduce using rule 166 (expr -> DEC variable .)
    EQ_EQ           reduce using rule 166 (expr -> DEC variable .)
    NOT_EQ          reduce using rule 166 (expr -> DEC variable .)
    LESSER          reduce using rule 166 (expr -> DEC variable .)
    LESSER_EQ       reduce using rule 166 (expr -> DEC variable .)
    GREATER         reduce using rule 166 (expr -> DEC variable .)
    GREATER_EQ      reduce using rule 166 (expr -> DEC variable .)
    INSTANCEOF      reduce using rule 166 (expr -> DEC variable .)
    COND_OP         reduce using rule 166 (expr -> DEC variable .)
    COMMA           reduce using rule 166 (expr -> DEC variable .)
    RPAREN          reduce using rule 166 (expr -> DEC variable .)
    AS              reduce using rule 166 (expr -> DEC variable .)
    DOUBLE_ARROW    reduce using rule 166 (expr -> DEC variable .)
    RBRACE          reduce using rule 166 (expr -> DEC variable .)
    RBRACKET        reduce using rule 166 (expr -> DEC variable .)
    COLON           reduce using rule 166 (expr -> DEC variable .)



state 77

    (169) expr -> EMPTY LPAREN . expr RPAREN
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 151
    variable                       shift and go to state 53

state 78

    (11) func_decl -> FUNCTION STRING . LPAREN params RPAREN LBRACE inner_stmts RBRACE

    LPAREN          shift and go to state 152



state 79

    (33) stmt -> FOR LPAREN . for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (34) for_expr -> . empty
    (35) for_expr -> . non_empty_for_expr
    (180) empty -> .
    (36) non_empty_for_expr -> . non_empty_for_expr COMMA expr
    (37) non_empty_for_expr -> . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    SEMICOLON       reduce using rule 180 (empty -> .)
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    non_empty_for_expr             shift and go to state 153
    base_var                       shift and go to state 43
    expr                           shift and go to state 155
    for_expr                       shift and go to state 156
    variable                       shift and go to state 53
    empty                          shift and go to state 154

state 80

    (71) stmt -> ECHO echo_expr_list . SEMICOLON
    (72) echo_expr_list -> echo_expr_list . COMMA expr

    SEMICOLON       shift and go to state 158
    COMMA           shift and go to state 157



state 81

    (73) echo_expr_list -> expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 73 (echo_expr_list -> expr .)
    COMMA           reduce using rule 73 (echo_expr_list -> expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 82

    (175) expr -> REQUIRE_ONCE expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 175 (expr -> REQUIRE_ONCE expr .)
    COMMA           reduce using rule 175 (expr -> REQUIRE_ONCE expr .)
    RPAREN          reduce using rule 175 (expr -> REQUIRE_ONCE expr .)
    AS              reduce using rule 175 (expr -> REQUIRE_ONCE expr .)
    DOUBLE_ARROW    reduce using rule 175 (expr -> REQUIRE_ONCE expr .)
    RBRACE          reduce using rule 175 (expr -> REQUIRE_ONCE expr .)
    RBRACKET        reduce using rule 175 (expr -> REQUIRE_ONCE expr .)
    COLON           reduce using rule 175 (expr -> REQUIRE_ONCE expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! OR_OP           [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_OR          [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_XOR         [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_AND         [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! DOT             [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! PLUS            [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! MINUS           [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! MULT            [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! DIV             [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! MOD             [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! IDENTICAL       [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! EQ_EQ           [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! NOT_EQ          [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! LESSER          [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! LESSER_EQ       [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! GREATER         [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! GREATER_EQ      [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! INSTANCEOF      [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]
  ! COND_OP         [ reduce using rule 175 (expr -> REQUIRE_ONCE expr .) ]


state 83

    (74) stmt -> LBRACE inner_stmts . RBRACE
    (77) inner_stmts -> inner_stmts . inner_stmt
    (79) inner_stmt -> . stmt
    (80) inner_stmt -> . func_decl
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (11) func_decl -> . FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    RBRACE          shift and go to state 159
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    FUNCTION        shift and go to state 24
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    inner_stmt                     shift and go to state 162
    func_decl                      shift and go to state 161
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 160
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 84

    (78) inner_stmts -> empty .

    WHILE           reduce using rule 78 (inner_stmts -> empty .)
    DO              reduce using rule 78 (inner_stmts -> empty .)
    FOR             reduce using rule 78 (inner_stmts -> empty .)
    FOREACH         reduce using rule 78 (inner_stmts -> empty .)
    SWITCH          reduce using rule 78 (inner_stmts -> empty .)
    BREAK           reduce using rule 78 (inner_stmts -> empty .)
    CONTINUE        reduce using rule 78 (inner_stmts -> empty .)
    RETURN          reduce using rule 78 (inner_stmts -> empty .)
    GLOBAL          reduce using rule 78 (inner_stmts -> empty .)
    STATIC          reduce using rule 78 (inner_stmts -> empty .)
    ECHO            reduce using rule 78 (inner_stmts -> empty .)
    LBRACE          reduce using rule 78 (inner_stmts -> empty .)
    SEMICOLON       reduce using rule 78 (inner_stmts -> empty .)
    FUNCTION        reduce using rule 78 (inner_stmts -> empty .)
    CLONE           reduce using rule 78 (inner_stmts -> empty .)
    ARRAY           reduce using rule 78 (inner_stmts -> empty .)
    PLUS            reduce using rule 78 (inner_stmts -> empty .)
    MINUS           reduce using rule 78 (inner_stmts -> empty .)
    BIT_NOT         reduce using rule 78 (inner_stmts -> empty .)
    NOT             reduce using rule 78 (inner_stmts -> empty .)
    CONST_DECIMAL   reduce using rule 78 (inner_stmts -> empty .)
    CONST_DOUBLE    reduce using rule 78 (inner_stmts -> empty .)
    CONST_STRING    reduce using rule 78 (inner_stmts -> empty .)
    NULL            reduce using rule 78 (inner_stmts -> empty .)
    TRUE            reduce using rule 78 (inner_stmts -> empty .)
    FALSE           reduce using rule 78 (inner_stmts -> empty .)
    INC             reduce using rule 78 (inner_stmts -> empty .)
    DEC             reduce using rule 78 (inner_stmts -> empty .)
    EMPTY           reduce using rule 78 (inner_stmts -> empty .)
    EVAL            reduce using rule 78 (inner_stmts -> empty .)
    LPAREN          reduce using rule 78 (inner_stmts -> empty .)
    INCLUDE         reduce using rule 78 (inner_stmts -> empty .)
    INCLUDE_ONCE    reduce using rule 78 (inner_stmts -> empty .)
    REQUIRE         reduce using rule 78 (inner_stmts -> empty .)
    REQUIRE_ONCE    reduce using rule 78 (inner_stmts -> empty .)
    EXIT            reduce using rule 78 (inner_stmts -> empty .)
    PRINT           reduce using rule 78 (inner_stmts -> empty .)
    IF              reduce using rule 78 (inner_stmts -> empty .)
    IDENTIFIER      reduce using rule 78 (inner_stmts -> empty .)
    STRING          reduce using rule 78 (inner_stmts -> empty .)
    ENDIF           reduce using rule 78 (inner_stmts -> empty .)
    ELSE            reduce using rule 78 (inner_stmts -> empty .)
    ELSEIF          reduce using rule 78 (inner_stmts -> empty .)
    RBRACE          reduce using rule 78 (inner_stmts -> empty .)
    CASE            reduce using rule 78 (inner_stmts -> empty .)
    DEFAULT         reduce using rule 78 (inner_stmts -> empty .)
    ENDSWITCH       reduce using rule 78 (inner_stmts -> empty .)
    ENDWHILE        reduce using rule 78 (inner_stmts -> empty .)
    ENDFOREACH      reduce using rule 78 (inner_stmts -> empty .)
    ENDFOR          reduce using rule 78 (inner_stmts -> empty .)



state 85

    (59) stmt -> CONTINUE SEMICOLON .

    WHILE           reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    DO              reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    FOREACH         reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    SWITCH          reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    GLOBAL          reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    STATIC          reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    ECHO            reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    FUNCTION        reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    CLONE           reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    ARRAY           reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    PLUS            reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    MINUS           reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    BIT_NOT         reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    NOT             reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    CONST_DECIMAL   reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    CONST_DOUBLE    reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    CONST_STRING    reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    INC             reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    DEC             reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    EMPTY           reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    EVAL            reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    INCLUDE         reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    REQUIRE         reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    EXIT            reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    PRINT           reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    IDENTIFIER      reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    ENDIF           reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    ELSEIF          reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    VAR             reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    $end            reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    ENDWHILE        reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    ENDFOREACH      reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    CASE            reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    DEFAULT         reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    ENDSWITCH       reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)
    ENDFOR          reduce using rule 59 (stmt -> CONTINUE SEMICOLON .)



state 86

    (60) stmt -> CONTINUE expr . SEMICOLON
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       shift and go to state 163
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 87

    (157) expr -> NOT expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 157 (expr -> NOT expr .)
    AND_OP          reduce using rule 157 (expr -> NOT expr .)
    OR_OP           reduce using rule 157 (expr -> NOT expr .)
    BIT_OR          reduce using rule 157 (expr -> NOT expr .)
    BIT_XOR         reduce using rule 157 (expr -> NOT expr .)
    BIT_AND         reduce using rule 157 (expr -> NOT expr .)
    DOT             reduce using rule 157 (expr -> NOT expr .)
    PLUS            reduce using rule 157 (expr -> NOT expr .)
    MINUS           reduce using rule 157 (expr -> NOT expr .)
    MULT            reduce using rule 157 (expr -> NOT expr .)
    DIV             reduce using rule 157 (expr -> NOT expr .)
    BIT_LSHIFT      reduce using rule 157 (expr -> NOT expr .)
    BIT_RSHIFT      reduce using rule 157 (expr -> NOT expr .)
    MOD             reduce using rule 157 (expr -> NOT expr .)
    IDENTICAL       reduce using rule 157 (expr -> NOT expr .)
    NOT_IDENTICAL   reduce using rule 157 (expr -> NOT expr .)
    EQ_EQ           reduce using rule 157 (expr -> NOT expr .)
    NOT_EQ          reduce using rule 157 (expr -> NOT expr .)
    LESSER          reduce using rule 157 (expr -> NOT expr .)
    LESSER_EQ       reduce using rule 157 (expr -> NOT expr .)
    GREATER         reduce using rule 157 (expr -> NOT expr .)
    GREATER_EQ      reduce using rule 157 (expr -> NOT expr .)
    COND_OP         reduce using rule 157 (expr -> NOT expr .)
    COMMA           reduce using rule 157 (expr -> NOT expr .)
    RPAREN          reduce using rule 157 (expr -> NOT expr .)
    AS              reduce using rule 157 (expr -> NOT expr .)
    DOUBLE_ARROW    reduce using rule 157 (expr -> NOT expr .)
    RBRACE          reduce using rule 157 (expr -> NOT expr .)
    RBRACKET        reduce using rule 157 (expr -> NOT expr .)
    COLON           reduce using rule 157 (expr -> NOT expr .)
    INSTANCEOF      shift and go to state 114

  ! INSTANCEOF      [ reduce using rule 157 (expr -> NOT expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! DOT             [ shift and go to state 108 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 102 ]
  ! MULT            [ shift and go to state 103 ]
  ! DIV             [ shift and go to state 100 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! MOD             [ shift and go to state 121 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 88

    (65) global_var_list -> IDENTIFIER .

    SEMICOLON       reduce using rule 65 (global_var_list -> IDENTIFIER .)
    COMMA           reduce using rule 65 (global_var_list -> IDENTIFIER .)



state 89

    (63) stmt -> GLOBAL global_var_list . SEMICOLON
    (64) global_var_list -> global_var_list . COMMA IDENTIFIER

    SEMICOLON       shift and go to state 165
    COMMA           shift and go to state 164



state 90

    (29) stmt -> WHILE LPAREN . expr RPAREN while_stmt
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 166
    variable                       shift and go to state 53

state 91

    (172) expr -> INCLUDE expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 172 (expr -> INCLUDE expr .)
    COMMA           reduce using rule 172 (expr -> INCLUDE expr .)
    RPAREN          reduce using rule 172 (expr -> INCLUDE expr .)
    AS              reduce using rule 172 (expr -> INCLUDE expr .)
    DOUBLE_ARROW    reduce using rule 172 (expr -> INCLUDE expr .)
    RBRACE          reduce using rule 172 (expr -> INCLUDE expr .)
    RBRACKET        reduce using rule 172 (expr -> INCLUDE expr .)
    COLON           reduce using rule 172 (expr -> INCLUDE expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! OR_OP           [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! BIT_OR          [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! BIT_XOR         [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! BIT_AND         [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! DOT             [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! PLUS            [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! MINUS           [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! MULT            [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! DIV             [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! MOD             [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! IDENTICAL       [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! EQ_EQ           [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! NOT_EQ          [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! LESSER          [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! LESSER_EQ       [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! GREATER         [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! GREATER_EQ      [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! INSTANCEOF      [ reduce using rule 172 (expr -> INCLUDE expr .) ]
  ! COND_OP         [ reduce using rule 172 (expr -> INCLUDE expr .) ]


state 92

    (47) stmt -> SWITCH LPAREN . expr RPAREN switch_stmt
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 167
    variable                       shift and go to state 53

state 93

    (113) expr -> ARRAY LPAREN . array_pair_list RPAREN
    (114) array_pair_list -> . empty
    (115) array_pair_list -> . non_empty_array_pair_list possible_comma
    (180) empty -> .
    (118) non_empty_array_pair_list -> . non_empty_array_pair_list COMMA BIT_AND variable
    (119) non_empty_array_pair_list -> . non_empty_array_pair_list COMMA expr
    (120) non_empty_array_pair_list -> . BIT_AND variable
    (121) non_empty_array_pair_list -> . expr
    (122) non_empty_array_pair_list -> . non_empty_array_pair_list COMMA expr DOUBLE_ARROW BIT_AND variable
    (123) non_empty_array_pair_list -> . non_empty_array_pair_list COMMA expr DOUBLE_ARROW expr
    (124) non_empty_array_pair_list -> . expr DOUBLE_ARROW BIT_AND variable
    (125) non_empty_array_pair_list -> . expr DOUBLE_ARROW expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    RPAREN          reduce using rule 180 (empty -> .)
    BIT_AND         shift and go to state 169
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 171
    array_pair_list                shift and go to state 170
    empty                          shift and go to state 172
    variable                       shift and go to state 53
    non_empty_array_pair_list      shift and go to state 168

state 94

    (22) if_stmt -> if_stmt_without_else ELSE . stmt
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 173
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 95

    (24) if_stmt_without_else -> if_stmt_without_else ELSEIF . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 174



state 96

    (91) base_var -> base_var LBRACE . expr RBRACE
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 175
    variable                       shift and go to state 53

state 97

    (90) base_var -> base_var LBRACKET . dim_offset RBRACKET
    (93) dim_offset -> . expr
    (94) dim_offset -> . empty
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (180) empty -> .
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    RBRACKET        reduce using rule 180 (empty -> .)
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    dim_offset                     shift and go to state 177
    expr                           shift and go to state 178
    empty                          shift and go to state 176
    variable                       shift and go to state 53

state 98

    (147) expr -> expr EQ_EQ . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 179
    variable                       shift and go to state 53

state 99

    (152) expr -> expr GREATER_EQ . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 180
    variable                       shift and go to state 53

state 100

    (141) expr -> expr DIV . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 181
    variable                       shift and go to state 53

state 101

    (135) expr -> expr BIT_XOR . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 182
    variable                       shift and go to state 53

state 102

    (139) expr -> expr MINUS . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 183
    variable                       shift and go to state 53

state 103

    (140) expr -> expr MULT . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 184
    variable                       shift and go to state 53

state 104

    (145) expr -> expr IDENTICAL . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 185
    variable                       shift and go to state 53

state 105

    (76) stmt -> expr SEMICOLON .

    WHILE           reduce using rule 76 (stmt -> expr SEMICOLON .)
    DO              reduce using rule 76 (stmt -> expr SEMICOLON .)
    FOR             reduce using rule 76 (stmt -> expr SEMICOLON .)
    FOREACH         reduce using rule 76 (stmt -> expr SEMICOLON .)
    SWITCH          reduce using rule 76 (stmt -> expr SEMICOLON .)
    BREAK           reduce using rule 76 (stmt -> expr SEMICOLON .)
    CONTINUE        reduce using rule 76 (stmt -> expr SEMICOLON .)
    RETURN          reduce using rule 76 (stmt -> expr SEMICOLON .)
    GLOBAL          reduce using rule 76 (stmt -> expr SEMICOLON .)
    STATIC          reduce using rule 76 (stmt -> expr SEMICOLON .)
    ECHO            reduce using rule 76 (stmt -> expr SEMICOLON .)
    LBRACE          reduce using rule 76 (stmt -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 76 (stmt -> expr SEMICOLON .)
    FUNCTION        reduce using rule 76 (stmt -> expr SEMICOLON .)
    CLONE           reduce using rule 76 (stmt -> expr SEMICOLON .)
    ARRAY           reduce using rule 76 (stmt -> expr SEMICOLON .)
    PLUS            reduce using rule 76 (stmt -> expr SEMICOLON .)
    MINUS           reduce using rule 76 (stmt -> expr SEMICOLON .)
    BIT_NOT         reduce using rule 76 (stmt -> expr SEMICOLON .)
    NOT             reduce using rule 76 (stmt -> expr SEMICOLON .)
    CONST_DECIMAL   reduce using rule 76 (stmt -> expr SEMICOLON .)
    CONST_DOUBLE    reduce using rule 76 (stmt -> expr SEMICOLON .)
    CONST_STRING    reduce using rule 76 (stmt -> expr SEMICOLON .)
    NULL            reduce using rule 76 (stmt -> expr SEMICOLON .)
    TRUE            reduce using rule 76 (stmt -> expr SEMICOLON .)
    FALSE           reduce using rule 76 (stmt -> expr SEMICOLON .)
    INC             reduce using rule 76 (stmt -> expr SEMICOLON .)
    DEC             reduce using rule 76 (stmt -> expr SEMICOLON .)
    EMPTY           reduce using rule 76 (stmt -> expr SEMICOLON .)
    EVAL            reduce using rule 76 (stmt -> expr SEMICOLON .)
    LPAREN          reduce using rule 76 (stmt -> expr SEMICOLON .)
    INCLUDE         reduce using rule 76 (stmt -> expr SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 76 (stmt -> expr SEMICOLON .)
    REQUIRE         reduce using rule 76 (stmt -> expr SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 76 (stmt -> expr SEMICOLON .)
    EXIT            reduce using rule 76 (stmt -> expr SEMICOLON .)
    PRINT           reduce using rule 76 (stmt -> expr SEMICOLON .)
    IF              reduce using rule 76 (stmt -> expr SEMICOLON .)
    IDENTIFIER      reduce using rule 76 (stmt -> expr SEMICOLON .)
    STRING          reduce using rule 76 (stmt -> expr SEMICOLON .)
    ENDIF           reduce using rule 76 (stmt -> expr SEMICOLON .)
    ELSE            reduce using rule 76 (stmt -> expr SEMICOLON .)
    ELSEIF          reduce using rule 76 (stmt -> expr SEMICOLON .)
    RBRACE          reduce using rule 76 (stmt -> expr SEMICOLON .)
    VAR             reduce using rule 76 (stmt -> expr SEMICOLON .)
    $end            reduce using rule 76 (stmt -> expr SEMICOLON .)
    ENDWHILE        reduce using rule 76 (stmt -> expr SEMICOLON .)
    ENDFOREACH      reduce using rule 76 (stmt -> expr SEMICOLON .)
    CASE            reduce using rule 76 (stmt -> expr SEMICOLON .)
    DEFAULT         reduce using rule 76 (stmt -> expr SEMICOLON .)
    ENDSWITCH       reduce using rule 76 (stmt -> expr SEMICOLON .)
    ENDFOR          reduce using rule 76 (stmt -> expr SEMICOLON .)



state 106

    (133) expr -> expr OR_OP . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 186
    variable                       shift and go to state 53

state 107

    (138) expr -> expr PLUS . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 187
    variable                       shift and go to state 53

state 108

    (137) expr -> expr DOT . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 188
    variable                       shift and go to state 53

state 109

    (148) expr -> expr NOT_EQ . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 189
    variable                       shift and go to state 53

state 110

    (146) expr -> expr NOT_IDENTICAL . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 190
    variable                       shift and go to state 53

state 111

    (136) expr -> expr BIT_AND . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 191
    variable                       shift and go to state 53

state 112

    (150) expr -> expr LESSER_EQ . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 192
    variable                       shift and go to state 53

state 113

    (132) expr -> expr AND_OP . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 193
    variable                       shift and go to state 53

state 114

    (153) expr -> expr INSTANCEOF . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 194
    variable                       shift and go to state 53

state 115

    (151) expr -> expr GREATER . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 195
    variable                       shift and go to state 53

state 116

    (164) expr -> expr COND_OP . expr COLON expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 196
    variable                       shift and go to state 53

state 117

    (143) expr -> expr BIT_RSHIFT . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 197
    variable                       shift and go to state 53

state 118

    (134) expr -> expr BIT_OR . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 198
    variable                       shift and go to state 53

state 119

    (149) expr -> expr LESSER . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 199
    variable                       shift and go to state 53

state 120

    (142) expr -> expr BIT_LSHIFT . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 200
    variable                       shift and go to state 53

state 121

    (144) expr -> expr MOD . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 201
    variable                       shift and go to state 53

state 122

    (57) stmt -> BREAK SEMICOLON .

    WHILE           reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    DO              reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    FOREACH         reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    SWITCH          reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    GLOBAL          reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    STATIC          reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    ECHO            reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    FUNCTION        reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    CLONE           reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    ARRAY           reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    PLUS            reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    MINUS           reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    BIT_NOT         reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    NOT             reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    CONST_DECIMAL   reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    CONST_DOUBLE    reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    CONST_STRING    reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    INC             reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    DEC             reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    EMPTY           reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    EVAL            reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    INCLUDE         reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    REQUIRE         reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    EXIT            reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    PRINT           reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    IDENTIFIER      reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    STRING          reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    ENDIF           reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    ELSEIF          reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    VAR             reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    $end            reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    ENDWHILE        reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    ENDFOREACH      reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    CASE            reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    DEFAULT         reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    ENDSWITCH       reduce using rule 57 (stmt -> BREAK SEMICOLON .)
    ENDFOR          reduce using rule 57 (stmt -> BREAK SEMICOLON .)



state 123

    (58) stmt -> BREAK expr . SEMICOLON
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       shift and go to state 202
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 124

    (177) expr -> EXIT LPAREN . RPAREN
    (178) expr -> EXIT LPAREN . expr RPAREN
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    RPAREN          shift and go to state 203
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 204
    variable                       shift and go to state 53

state 125

    (32) stmt -> DO stmt . WHILE LPAREN expr RPAREN SEMICOLON

    WHILE           shift and go to state 205



state 126

    (84) func_call -> STRING LPAREN . func_params RPAREN
    (85) func_params -> . func_params COMMA func_param
    (86) func_params -> . func_param
    (87) func_params -> . empty
    (88) func_param -> . expr
    (89) func_param -> . BIT_AND variable
    (180) empty -> .
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    BIT_AND         shift and go to state 209
    RPAREN          reduce using rule 180 (empty -> .)
    COMMA           reduce using rule 180 (empty -> .)
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_params                    shift and go to state 206
    base_var                       shift and go to state 43
    func_param                     shift and go to state 208
    func_call                      shift and go to state 40
    expr                           shift and go to state 210
    empty                          shift and go to state 207
    variable                       shift and go to state 53

state 127

    (171) expr -> LPAREN expr . RPAREN
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RPAREN          shift and go to state 211
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 128

    (130) expr -> variable DOT_EQ . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 212
    variable                       shift and go to state 53

state 129

    (128) expr -> variable MULTIPLY_EQ . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 213
    variable                       shift and go to state 53

state 130

    (168) expr -> variable DEC .

    SEMICOLON       reduce using rule 168 (expr -> variable DEC .)
    AND_OP          reduce using rule 168 (expr -> variable DEC .)
    OR_OP           reduce using rule 168 (expr -> variable DEC .)
    BIT_OR          reduce using rule 168 (expr -> variable DEC .)
    BIT_XOR         reduce using rule 168 (expr -> variable DEC .)
    BIT_AND         reduce using rule 168 (expr -> variable DEC .)
    DOT             reduce using rule 168 (expr -> variable DEC .)
    PLUS            reduce using rule 168 (expr -> variable DEC .)
    MINUS           reduce using rule 168 (expr -> variable DEC .)
    MULT            reduce using rule 168 (expr -> variable DEC .)
    DIV             reduce using rule 168 (expr -> variable DEC .)
    BIT_LSHIFT      reduce using rule 168 (expr -> variable DEC .)
    BIT_RSHIFT      reduce using rule 168 (expr -> variable DEC .)
    MOD             reduce using rule 168 (expr -> variable DEC .)
    IDENTICAL       reduce using rule 168 (expr -> variable DEC .)
    NOT_IDENTICAL   reduce using rule 168 (expr -> variable DEC .)
    EQ_EQ           reduce using rule 168 (expr -> variable DEC .)
    NOT_EQ          reduce using rule 168 (expr -> variable DEC .)
    LESSER          reduce using rule 168 (expr -> variable DEC .)
    LESSER_EQ       reduce using rule 168 (expr -> variable DEC .)
    GREATER         reduce using rule 168 (expr -> variable DEC .)
    GREATER_EQ      reduce using rule 168 (expr -> variable DEC .)
    INSTANCEOF      reduce using rule 168 (expr -> variable DEC .)
    COND_OP         reduce using rule 168 (expr -> variable DEC .)
    COMMA           reduce using rule 168 (expr -> variable DEC .)
    RPAREN          reduce using rule 168 (expr -> variable DEC .)
    AS              reduce using rule 168 (expr -> variable DEC .)
    DOUBLE_ARROW    reduce using rule 168 (expr -> variable DEC .)
    RBRACE          reduce using rule 168 (expr -> variable DEC .)
    RBRACKET        reduce using rule 168 (expr -> variable DEC .)
    COLON           reduce using rule 168 (expr -> variable DEC .)



state 131

    (95) expr -> variable EQUAL . expr
    (96) expr -> variable EQUAL . BIT_AND expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    BIT_AND         shift and go to state 214
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 215
    variable                       shift and go to state 53

state 132

    (126) expr -> variable PLUS_EQ . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 216
    variable                       shift and go to state 53

state 133

    (129) expr -> variable DIVIDE_EQ . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 217
    variable                       shift and go to state 53

state 134

    (127) expr -> variable MINUS_EQ . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 218
    variable                       shift and go to state 53

state 135

    (131) expr -> variable MOD_EQ . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 219
    variable                       shift and go to state 53

state 136

    (167) expr -> variable INC .

    SEMICOLON       reduce using rule 167 (expr -> variable INC .)
    AND_OP          reduce using rule 167 (expr -> variable INC .)
    OR_OP           reduce using rule 167 (expr -> variable INC .)
    BIT_OR          reduce using rule 167 (expr -> variable INC .)
    BIT_XOR         reduce using rule 167 (expr -> variable INC .)
    BIT_AND         reduce using rule 167 (expr -> variable INC .)
    DOT             reduce using rule 167 (expr -> variable INC .)
    PLUS            reduce using rule 167 (expr -> variable INC .)
    MINUS           reduce using rule 167 (expr -> variable INC .)
    MULT            reduce using rule 167 (expr -> variable INC .)
    DIV             reduce using rule 167 (expr -> variable INC .)
    BIT_LSHIFT      reduce using rule 167 (expr -> variable INC .)
    BIT_RSHIFT      reduce using rule 167 (expr -> variable INC .)
    MOD             reduce using rule 167 (expr -> variable INC .)
    IDENTICAL       reduce using rule 167 (expr -> variable INC .)
    NOT_IDENTICAL   reduce using rule 167 (expr -> variable INC .)
    EQ_EQ           reduce using rule 167 (expr -> variable INC .)
    NOT_EQ          reduce using rule 167 (expr -> variable INC .)
    LESSER          reduce using rule 167 (expr -> variable INC .)
    LESSER_EQ       reduce using rule 167 (expr -> variable INC .)
    GREATER         reduce using rule 167 (expr -> variable INC .)
    GREATER_EQ      reduce using rule 167 (expr -> variable INC .)
    INSTANCEOF      reduce using rule 167 (expr -> variable INC .)
    COND_OP         reduce using rule 167 (expr -> variable INC .)
    COMMA           reduce using rule 167 (expr -> variable INC .)
    RPAREN          reduce using rule 167 (expr -> variable INC .)
    AS              reduce using rule 167 (expr -> variable INC .)
    DOUBLE_ARROW    reduce using rule 167 (expr -> variable INC .)
    RBRACE          reduce using rule 167 (expr -> variable INC .)
    RBRACKET        reduce using rule 167 (expr -> variable INC .)
    COLON           reduce using rule 167 (expr -> variable INC .)



state 137

    (23) if_stmt_without_else -> IF LPAREN . expr RPAREN stmt
    (27) alt_if_stmt_without_else -> IF LPAREN . expr RPAREN COLON inner_stmts
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 220
    variable                       shift and go to state 53

state 138

    (165) expr -> INC variable .

    SEMICOLON       reduce using rule 165 (expr -> INC variable .)
    AND_OP          reduce using rule 165 (expr -> INC variable .)
    OR_OP           reduce using rule 165 (expr -> INC variable .)
    BIT_OR          reduce using rule 165 (expr -> INC variable .)
    BIT_XOR         reduce using rule 165 (expr -> INC variable .)
    BIT_AND         reduce using rule 165 (expr -> INC variable .)
    DOT             reduce using rule 165 (expr -> INC variable .)
    PLUS            reduce using rule 165 (expr -> INC variable .)
    MINUS           reduce using rule 165 (expr -> INC variable .)
    MULT            reduce using rule 165 (expr -> INC variable .)
    DIV             reduce using rule 165 (expr -> INC variable .)
    BIT_LSHIFT      reduce using rule 165 (expr -> INC variable .)
    BIT_RSHIFT      reduce using rule 165 (expr -> INC variable .)
    MOD             reduce using rule 165 (expr -> INC variable .)
    IDENTICAL       reduce using rule 165 (expr -> INC variable .)
    NOT_IDENTICAL   reduce using rule 165 (expr -> INC variable .)
    EQ_EQ           reduce using rule 165 (expr -> INC variable .)
    NOT_EQ          reduce using rule 165 (expr -> INC variable .)
    LESSER          reduce using rule 165 (expr -> INC variable .)
    LESSER_EQ       reduce using rule 165 (expr -> INC variable .)
    GREATER         reduce using rule 165 (expr -> INC variable .)
    GREATER_EQ      reduce using rule 165 (expr -> INC variable .)
    INSTANCEOF      reduce using rule 165 (expr -> INC variable .)
    COND_OP         reduce using rule 165 (expr -> INC variable .)
    COMMA           reduce using rule 165 (expr -> INC variable .)
    RPAREN          reduce using rule 165 (expr -> INC variable .)
    AS              reduce using rule 165 (expr -> INC variable .)
    DOUBLE_ARROW    reduce using rule 165 (expr -> INC variable .)
    RBRACE          reduce using rule 165 (expr -> INC variable .)
    RBRACKET        reduce using rule 165 (expr -> INC variable .)
    COLON           reduce using rule 165 (expr -> INC variable .)



state 139

    (26) alt_if_stmt -> alt_if_stmt_without_else ELSE COLON . inner_stmts ENDIF SEMICOLON
    (77) inner_stmts -> . inner_stmts inner_stmt
    (78) inner_stmts -> . empty
    (180) empty -> .

    ENDIF           reduce using rule 180 (empty -> .)
    WHILE           reduce using rule 180 (empty -> .)
    DO              reduce using rule 180 (empty -> .)
    FOR             reduce using rule 180 (empty -> .)
    FOREACH         reduce using rule 180 (empty -> .)
    SWITCH          reduce using rule 180 (empty -> .)
    BREAK           reduce using rule 180 (empty -> .)
    CONTINUE        reduce using rule 180 (empty -> .)
    RETURN          reduce using rule 180 (empty -> .)
    GLOBAL          reduce using rule 180 (empty -> .)
    STATIC          reduce using rule 180 (empty -> .)
    ECHO            reduce using rule 180 (empty -> .)
    LBRACE          reduce using rule 180 (empty -> .)
    SEMICOLON       reduce using rule 180 (empty -> .)
    FUNCTION        reduce using rule 180 (empty -> .)
    CLONE           reduce using rule 180 (empty -> .)
    ARRAY           reduce using rule 180 (empty -> .)
    PLUS            reduce using rule 180 (empty -> .)
    MINUS           reduce using rule 180 (empty -> .)
    BIT_NOT         reduce using rule 180 (empty -> .)
    NOT             reduce using rule 180 (empty -> .)
    CONST_DECIMAL   reduce using rule 180 (empty -> .)
    CONST_DOUBLE    reduce using rule 180 (empty -> .)
    CONST_STRING    reduce using rule 180 (empty -> .)
    NULL            reduce using rule 180 (empty -> .)
    TRUE            reduce using rule 180 (empty -> .)
    FALSE           reduce using rule 180 (empty -> .)
    INC             reduce using rule 180 (empty -> .)
    DEC             reduce using rule 180 (empty -> .)
    EMPTY           reduce using rule 180 (empty -> .)
    EVAL            reduce using rule 180 (empty -> .)
    LPAREN          reduce using rule 180 (empty -> .)
    INCLUDE         reduce using rule 180 (empty -> .)
    INCLUDE_ONCE    reduce using rule 180 (empty -> .)
    REQUIRE         reduce using rule 180 (empty -> .)
    REQUIRE_ONCE    reduce using rule 180 (empty -> .)
    EXIT            reduce using rule 180 (empty -> .)
    PRINT           reduce using rule 180 (empty -> .)
    IF              reduce using rule 180 (empty -> .)
    IDENTIFIER      reduce using rule 180 (empty -> .)
    STRING          reduce using rule 180 (empty -> .)


    inner_stmts                    shift and go to state 221
    empty                          shift and go to state 84

state 140

    (25) alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .

    VAR             reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    WHILE           reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    DO              reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    FOR             reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    FOREACH         reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    SWITCH          reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    BREAK           reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    CONTINUE        reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    RETURN          reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    GLOBAL          reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    STATIC          reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ECHO            reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    LBRACE          reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    SEMICOLON       reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    FUNCTION        reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    CLONE           reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ARRAY           reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    PLUS            reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    MINUS           reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    BIT_NOT         reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    NOT             reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    CONST_DECIMAL   reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    CONST_DOUBLE    reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    CONST_STRING    reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    NULL            reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    TRUE            reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    FALSE           reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    INC             reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    DEC             reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    EMPTY           reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    EVAL            reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    LPAREN          reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    INCLUDE         reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    REQUIRE         reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    EXIT            reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    PRINT           reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    IF              reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    IDENTIFIER      reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    STRING          reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    $end            reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    RBRACE          reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ENDIF           reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ELSE            reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ELSEIF          reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ENDWHILE        reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ENDFOREACH      reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    CASE            reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    DEFAULT         reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ENDSWITCH       reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ENDFOR          reduce using rule 25 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)



state 141

    (28) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF LPAREN . expr RPAREN COLON inner_stmts
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 222
    variable                       shift and go to state 53

state 142

    (40) stmt -> FOREACH LPAREN expr . AS foreach_var foreach_arg RPAREN foreach_stmt
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    AS              shift and go to state 223
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 143

    (170) expr -> EVAL LPAREN expr . RPAREN
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RPAREN          shift and go to state 224
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 144

    (7) const_decls -> const_decls COMMA . const_decl
    (9) const_decl -> . IDENTIFIER EQUAL expr
    (10) const_decl -> . IDENTIFIER

    IDENTIFIER      shift and go to state 66


    const_decl                     shift and go to state 225

state 145

    (6) top_stmt -> VAR const_decls SEMICOLON .

    VAR             reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    WHILE           reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    DO              reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    FOR             reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    FOREACH         reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    SWITCH          reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    BREAK           reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    CONTINUE        reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    RETURN          reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    GLOBAL          reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    STATIC          reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    ECHO            reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    LBRACE          reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    SEMICOLON       reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    FUNCTION        reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    CLONE           reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    ARRAY           reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    PLUS            reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    MINUS           reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    BIT_NOT         reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    NOT             reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    CONST_DECIMAL   reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    CONST_DOUBLE    reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    CONST_STRING    reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    NULL            reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    TRUE            reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    FALSE           reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    INC             reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    DEC             reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    EMPTY           reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    EVAL            reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    LPAREN          reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    INCLUDE         reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    REQUIRE         reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    EXIT            reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    PRINT           reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    IF              reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    IDENTIFIER      reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    STRING          reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)
    $end            reduce using rule 6 (top_stmt -> VAR const_decls SEMICOLON .)



state 146

    (9) const_decl -> IDENTIFIER EQUAL . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 226
    variable                       shift and go to state 53

state 147

    (62) stmt -> RETURN expr SEMICOLON .

    WHILE           reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    DO              reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    FOREACH         reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    SWITCH          reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    BREAK           reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    CONTINUE        reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    GLOBAL          reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    STATIC          reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    ECHO            reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    FUNCTION        reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    CLONE           reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    ARRAY           reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    PLUS            reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    MINUS           reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    BIT_NOT         reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    NOT             reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    CONST_DECIMAL   reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    CONST_DOUBLE    reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    CONST_STRING    reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    NULL            reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    TRUE            reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    FALSE           reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    INC             reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    DEC             reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    EMPTY           reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    EVAL            reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    INCLUDE         reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    REQUIRE         reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    EXIT            reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    PRINT           reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    IF              reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    IDENTIFIER      reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    STRING          reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    ENDIF           reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    ELSEIF          reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    VAR             reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    $end            reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    ENDWHILE        reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    ENDFOREACH      reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    CASE            reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    DEFAULT         reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    ENDSWITCH       reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)
    ENDFOR          reduce using rule 62 (stmt -> RETURN expr SEMICOLON .)



state 148

    (67) static_var_list -> static_var_list COMMA . static_var
    (69) static_var -> . IDENTIFIER EQUAL scalar
    (70) static_var -> . IDENTIFIER

    IDENTIFIER      shift and go to state 74


    static_var                     shift and go to state 227

state 149

    (66) stmt -> STATIC static_var_list SEMICOLON .

    WHILE           reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    DO              reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    FOR             reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    FOREACH         reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    SWITCH          reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    BREAK           reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    CONTINUE        reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    RETURN          reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    GLOBAL          reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    STATIC          reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    ECHO            reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    LBRACE          reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    SEMICOLON       reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    FUNCTION        reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    CLONE           reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    ARRAY           reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    PLUS            reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    MINUS           reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    BIT_NOT         reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    NOT             reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    CONST_DECIMAL   reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    CONST_DOUBLE    reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    CONST_STRING    reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    NULL            reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    TRUE            reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    FALSE           reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    INC             reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    DEC             reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    EMPTY           reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    EVAL            reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    LPAREN          reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    INCLUDE         reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    REQUIRE         reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    EXIT            reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    PRINT           reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    IF              reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    IDENTIFIER      reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    STRING          reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    ENDIF           reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    ELSE            reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    ELSEIF          reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    RBRACE          reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    VAR             reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    $end            reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    ENDWHILE        reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    ENDFOREACH      reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    CASE            reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    DEFAULT         reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    ENDSWITCH       reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)
    ENDFOR          reduce using rule 66 (stmt -> STATIC static_var_list SEMICOLON .)



state 150

    (69) static_var -> IDENTIFIER EQUAL . scalar
    (98) scalar -> . CONST_DECIMAL
    (99) scalar -> . CONST_DOUBLE
    (100) scalar -> . CONST_STRING
    (101) scalar -> . NULL
    (102) scalar -> . TRUE
    (103) scalar -> . FALSE
    (104) scalar -> . PLUS scalar
    (105) scalar -> . MINUS scalar
    (106) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 231
    CONST_DOUBLE    shift and go to state 232
    CONST_STRING    shift and go to state 230
    NULL            shift and go to state 228
    TRUE            shift and go to state 236
    FALSE           shift and go to state 229
    PLUS            shift and go to state 234
    MINUS           shift and go to state 237
    ARRAY           shift and go to state 235


    scalar                         shift and go to state 233

state 151

    (169) expr -> EMPTY LPAREN expr . RPAREN
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RPAREN          shift and go to state 238
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 152

    (11) func_decl -> FUNCTION STRING LPAREN . params RPAREN LBRACE inner_stmts RBRACE
    (12) params -> . params COMMA param
    (13) params -> . param
    (14) params -> . empty
    (15) param -> . IDENTIFIER
    (16) param -> . BIT_AND IDENTIFIER
    (17) param -> . IDENTIFIER EQUAL scalar
    (18) param -> . BIT_AND IDENTIFIER EQUAL scalar
    (180) empty -> .

    IDENTIFIER      shift and go to state 241
    BIT_AND         shift and go to state 239
    RPAREN          reduce using rule 180 (empty -> .)
    COMMA           reduce using rule 180 (empty -> .)


    params                         shift and go to state 242
    empty                          shift and go to state 243
    param                          shift and go to state 240

state 153

    (35) for_expr -> non_empty_for_expr .
    (36) non_empty_for_expr -> non_empty_for_expr . COMMA expr

    SEMICOLON       reduce using rule 35 (for_expr -> non_empty_for_expr .)
    RPAREN          reduce using rule 35 (for_expr -> non_empty_for_expr .)
    COMMA           shift and go to state 244



state 154

    (34) for_expr -> empty .

    SEMICOLON       reduce using rule 34 (for_expr -> empty .)
    RPAREN          reduce using rule 34 (for_expr -> empty .)



state 155

    (37) non_empty_for_expr -> expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    COMMA           reduce using rule 37 (non_empty_for_expr -> expr .)
    RPAREN          reduce using rule 37 (non_empty_for_expr -> expr .)
    SEMICOLON       reduce using rule 37 (non_empty_for_expr -> expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 156

    (33) stmt -> FOR LPAREN for_expr . SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt

    SEMICOLON       shift and go to state 245



state 157

    (72) echo_expr_list -> echo_expr_list COMMA . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 246
    variable                       shift and go to state 53

state 158

    (71) stmt -> ECHO echo_expr_list SEMICOLON .

    WHILE           reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    DO              reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    FOR             reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    FOREACH         reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    SWITCH          reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    BREAK           reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    CONTINUE        reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    RETURN          reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    GLOBAL          reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    STATIC          reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ECHO            reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    LBRACE          reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    SEMICOLON       reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    FUNCTION        reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    CLONE           reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ARRAY           reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    PLUS            reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    MINUS           reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    BIT_NOT         reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    NOT             reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    CONST_DECIMAL   reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    CONST_DOUBLE    reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    CONST_STRING    reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    NULL            reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    TRUE            reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    FALSE           reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    INC             reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    DEC             reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    EMPTY           reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    EVAL            reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    LPAREN          reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    INCLUDE         reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    REQUIRE         reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    EXIT            reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    PRINT           reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    IF              reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    IDENTIFIER      reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    STRING          reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ENDIF           reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ELSE            reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ELSEIF          reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    RBRACE          reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    VAR             reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    $end            reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ENDWHILE        reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ENDFOREACH      reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    CASE            reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    DEFAULT         reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ENDSWITCH       reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ENDFOR          reduce using rule 71 (stmt -> ECHO echo_expr_list SEMICOLON .)



state 159

    (74) stmt -> LBRACE inner_stmts RBRACE .

    WHILE           reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    DO              reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    FOR             reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    FOREACH         reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    SWITCH          reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    BREAK           reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    CONTINUE        reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    RETURN          reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    GLOBAL          reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    STATIC          reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    ECHO            reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    LBRACE          reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    SEMICOLON       reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    FUNCTION        reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    CLONE           reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    ARRAY           reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    PLUS            reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    MINUS           reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    BIT_NOT         reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    NOT             reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    CONST_DECIMAL   reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    CONST_DOUBLE    reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    CONST_STRING    reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    NULL            reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    TRUE            reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    FALSE           reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    INC             reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    DEC             reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    EMPTY           reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    EVAL            reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    LPAREN          reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    INCLUDE         reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    INCLUDE_ONCE    reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    REQUIRE         reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    REQUIRE_ONCE    reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    EXIT            reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    PRINT           reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    IF              reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    IDENTIFIER      reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    STRING          reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    ENDIF           reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    ELSE            reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    ELSEIF          reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    RBRACE          reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    VAR             reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    $end            reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    ENDWHILE        reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    ENDFOREACH      reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    CASE            reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    DEFAULT         reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    ENDSWITCH       reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)
    ENDFOR          reduce using rule 74 (stmt -> LBRACE inner_stmts RBRACE .)



state 160

    (79) inner_stmt -> stmt .

    ENDWHILE        reduce using rule 79 (inner_stmt -> stmt .)
    WHILE           reduce using rule 79 (inner_stmt -> stmt .)
    DO              reduce using rule 79 (inner_stmt -> stmt .)
    FOR             reduce using rule 79 (inner_stmt -> stmt .)
    FOREACH         reduce using rule 79 (inner_stmt -> stmt .)
    SWITCH          reduce using rule 79 (inner_stmt -> stmt .)
    BREAK           reduce using rule 79 (inner_stmt -> stmt .)
    CONTINUE        reduce using rule 79 (inner_stmt -> stmt .)
    RETURN          reduce using rule 79 (inner_stmt -> stmt .)
    GLOBAL          reduce using rule 79 (inner_stmt -> stmt .)
    STATIC          reduce using rule 79 (inner_stmt -> stmt .)
    ECHO            reduce using rule 79 (inner_stmt -> stmt .)
    LBRACE          reduce using rule 79 (inner_stmt -> stmt .)
    SEMICOLON       reduce using rule 79 (inner_stmt -> stmt .)
    FUNCTION        reduce using rule 79 (inner_stmt -> stmt .)
    CLONE           reduce using rule 79 (inner_stmt -> stmt .)
    ARRAY           reduce using rule 79 (inner_stmt -> stmt .)
    PLUS            reduce using rule 79 (inner_stmt -> stmt .)
    MINUS           reduce using rule 79 (inner_stmt -> stmt .)
    BIT_NOT         reduce using rule 79 (inner_stmt -> stmt .)
    NOT             reduce using rule 79 (inner_stmt -> stmt .)
    CONST_DECIMAL   reduce using rule 79 (inner_stmt -> stmt .)
    CONST_DOUBLE    reduce using rule 79 (inner_stmt -> stmt .)
    CONST_STRING    reduce using rule 79 (inner_stmt -> stmt .)
    NULL            reduce using rule 79 (inner_stmt -> stmt .)
    TRUE            reduce using rule 79 (inner_stmt -> stmt .)
    FALSE           reduce using rule 79 (inner_stmt -> stmt .)
    INC             reduce using rule 79 (inner_stmt -> stmt .)
    DEC             reduce using rule 79 (inner_stmt -> stmt .)
    EMPTY           reduce using rule 79 (inner_stmt -> stmt .)
    EVAL            reduce using rule 79 (inner_stmt -> stmt .)
    LPAREN          reduce using rule 79 (inner_stmt -> stmt .)
    INCLUDE         reduce using rule 79 (inner_stmt -> stmt .)
    INCLUDE_ONCE    reduce using rule 79 (inner_stmt -> stmt .)
    REQUIRE         reduce using rule 79 (inner_stmt -> stmt .)
    REQUIRE_ONCE    reduce using rule 79 (inner_stmt -> stmt .)
    EXIT            reduce using rule 79 (inner_stmt -> stmt .)
    PRINT           reduce using rule 79 (inner_stmt -> stmt .)
    IF              reduce using rule 79 (inner_stmt -> stmt .)
    IDENTIFIER      reduce using rule 79 (inner_stmt -> stmt .)
    STRING          reduce using rule 79 (inner_stmt -> stmt .)
    ENDIF           reduce using rule 79 (inner_stmt -> stmt .)
    ELSE            reduce using rule 79 (inner_stmt -> stmt .)
    ELSEIF          reduce using rule 79 (inner_stmt -> stmt .)
    ENDFOREACH      reduce using rule 79 (inner_stmt -> stmt .)
    RBRACE          reduce using rule 79 (inner_stmt -> stmt .)
    CASE            reduce using rule 79 (inner_stmt -> stmt .)
    DEFAULT         reduce using rule 79 (inner_stmt -> stmt .)
    ENDSWITCH       reduce using rule 79 (inner_stmt -> stmt .)
    ENDFOR          reduce using rule 79 (inner_stmt -> stmt .)



state 161

    (80) inner_stmt -> func_decl .

    ENDWHILE        reduce using rule 80 (inner_stmt -> func_decl .)
    WHILE           reduce using rule 80 (inner_stmt -> func_decl .)
    DO              reduce using rule 80 (inner_stmt -> func_decl .)
    FOR             reduce using rule 80 (inner_stmt -> func_decl .)
    FOREACH         reduce using rule 80 (inner_stmt -> func_decl .)
    SWITCH          reduce using rule 80 (inner_stmt -> func_decl .)
    BREAK           reduce using rule 80 (inner_stmt -> func_decl .)
    CONTINUE        reduce using rule 80 (inner_stmt -> func_decl .)
    RETURN          reduce using rule 80 (inner_stmt -> func_decl .)
    GLOBAL          reduce using rule 80 (inner_stmt -> func_decl .)
    STATIC          reduce using rule 80 (inner_stmt -> func_decl .)
    ECHO            reduce using rule 80 (inner_stmt -> func_decl .)
    LBRACE          reduce using rule 80 (inner_stmt -> func_decl .)
    SEMICOLON       reduce using rule 80 (inner_stmt -> func_decl .)
    FUNCTION        reduce using rule 80 (inner_stmt -> func_decl .)
    CLONE           reduce using rule 80 (inner_stmt -> func_decl .)
    ARRAY           reduce using rule 80 (inner_stmt -> func_decl .)
    PLUS            reduce using rule 80 (inner_stmt -> func_decl .)
    MINUS           reduce using rule 80 (inner_stmt -> func_decl .)
    BIT_NOT         reduce using rule 80 (inner_stmt -> func_decl .)
    NOT             reduce using rule 80 (inner_stmt -> func_decl .)
    CONST_DECIMAL   reduce using rule 80 (inner_stmt -> func_decl .)
    CONST_DOUBLE    reduce using rule 80 (inner_stmt -> func_decl .)
    CONST_STRING    reduce using rule 80 (inner_stmt -> func_decl .)
    NULL            reduce using rule 80 (inner_stmt -> func_decl .)
    TRUE            reduce using rule 80 (inner_stmt -> func_decl .)
    FALSE           reduce using rule 80 (inner_stmt -> func_decl .)
    INC             reduce using rule 80 (inner_stmt -> func_decl .)
    DEC             reduce using rule 80 (inner_stmt -> func_decl .)
    EMPTY           reduce using rule 80 (inner_stmt -> func_decl .)
    EVAL            reduce using rule 80 (inner_stmt -> func_decl .)
    LPAREN          reduce using rule 80 (inner_stmt -> func_decl .)
    INCLUDE         reduce using rule 80 (inner_stmt -> func_decl .)
    INCLUDE_ONCE    reduce using rule 80 (inner_stmt -> func_decl .)
    REQUIRE         reduce using rule 80 (inner_stmt -> func_decl .)
    REQUIRE_ONCE    reduce using rule 80 (inner_stmt -> func_decl .)
    EXIT            reduce using rule 80 (inner_stmt -> func_decl .)
    PRINT           reduce using rule 80 (inner_stmt -> func_decl .)
    IF              reduce using rule 80 (inner_stmt -> func_decl .)
    IDENTIFIER      reduce using rule 80 (inner_stmt -> func_decl .)
    STRING          reduce using rule 80 (inner_stmt -> func_decl .)
    ENDIF           reduce using rule 80 (inner_stmt -> func_decl .)
    ELSE            reduce using rule 80 (inner_stmt -> func_decl .)
    ELSEIF          reduce using rule 80 (inner_stmt -> func_decl .)
    ENDFOREACH      reduce using rule 80 (inner_stmt -> func_decl .)
    RBRACE          reduce using rule 80 (inner_stmt -> func_decl .)
    CASE            reduce using rule 80 (inner_stmt -> func_decl .)
    DEFAULT         reduce using rule 80 (inner_stmt -> func_decl .)
    ENDSWITCH       reduce using rule 80 (inner_stmt -> func_decl .)
    ENDFOR          reduce using rule 80 (inner_stmt -> func_decl .)



state 162

    (77) inner_stmts -> inner_stmts inner_stmt .

    WHILE           reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    DO              reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    FOR             reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    FOREACH         reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    SWITCH          reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    BREAK           reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    CONTINUE        reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    RETURN          reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    GLOBAL          reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    STATIC          reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    ECHO            reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    LBRACE          reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    SEMICOLON       reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    FUNCTION        reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    CLONE           reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    ARRAY           reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    PLUS            reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    MINUS           reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    BIT_NOT         reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    NOT             reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    CONST_DECIMAL   reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    CONST_DOUBLE    reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    CONST_STRING    reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    NULL            reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    TRUE            reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    FALSE           reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    INC             reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    DEC             reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    EMPTY           reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    EVAL            reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    LPAREN          reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    INCLUDE         reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    INCLUDE_ONCE    reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    REQUIRE         reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    REQUIRE_ONCE    reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    EXIT            reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    PRINT           reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    IF              reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    IDENTIFIER      reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    STRING          reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    ENDIF           reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    ELSE            reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    ELSEIF          reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    RBRACE          reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    CASE            reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    DEFAULT         reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    ENDSWITCH       reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    ENDWHILE        reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    ENDFOREACH      reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)
    ENDFOR          reduce using rule 77 (inner_stmts -> inner_stmts inner_stmt .)



state 163

    (60) stmt -> CONTINUE expr SEMICOLON .

    WHILE           reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    DO              reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    FOR             reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    FOREACH         reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    SWITCH          reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    BREAK           reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    CONTINUE        reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    RETURN          reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    GLOBAL          reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    STATIC          reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    ECHO            reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    LBRACE          reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    SEMICOLON       reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    FUNCTION        reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    CLONE           reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    ARRAY           reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    PLUS            reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    MINUS           reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    BIT_NOT         reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    NOT             reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    CONST_DECIMAL   reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    CONST_DOUBLE    reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    CONST_STRING    reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    NULL            reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    TRUE            reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    FALSE           reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    INC             reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    DEC             reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    EMPTY           reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    EVAL            reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    LPAREN          reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    INCLUDE         reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    REQUIRE         reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    EXIT            reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    PRINT           reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    IF              reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    IDENTIFIER      reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    STRING          reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    ENDIF           reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    ELSE            reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    ELSEIF          reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    RBRACE          reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    VAR             reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    $end            reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    ENDWHILE        reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    ENDFOREACH      reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    CASE            reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    DEFAULT         reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    ENDSWITCH       reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)
    ENDFOR          reduce using rule 60 (stmt -> CONTINUE expr SEMICOLON .)



state 164

    (64) global_var_list -> global_var_list COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 247



state 165

    (63) stmt -> GLOBAL global_var_list SEMICOLON .

    WHILE           reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    DO              reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    FOR             reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    FOREACH         reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    SWITCH          reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    BREAK           reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    CONTINUE        reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    RETURN          reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    GLOBAL          reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    STATIC          reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ECHO            reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    LBRACE          reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    SEMICOLON       reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    FUNCTION        reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    CLONE           reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ARRAY           reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    PLUS            reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    MINUS           reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    BIT_NOT         reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    NOT             reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    CONST_DECIMAL   reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    CONST_DOUBLE    reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    CONST_STRING    reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    NULL            reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    TRUE            reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    FALSE           reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    INC             reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    DEC             reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    EMPTY           reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    EVAL            reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    LPAREN          reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    INCLUDE         reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    REQUIRE         reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    EXIT            reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    PRINT           reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    IF              reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    IDENTIFIER      reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    STRING          reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ENDIF           reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ELSE            reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ELSEIF          reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    RBRACE          reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    VAR             reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    $end            reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ENDWHILE        reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ENDFOREACH      reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    CASE            reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    DEFAULT         reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ENDSWITCH       reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ENDFOR          reduce using rule 63 (stmt -> GLOBAL global_var_list SEMICOLON .)



state 166

    (29) stmt -> WHILE LPAREN expr . RPAREN while_stmt
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RPAREN          shift and go to state 248
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 167

    (47) stmt -> SWITCH LPAREN expr . RPAREN switch_stmt
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RPAREN          shift and go to state 249
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 168

    (115) array_pair_list -> non_empty_array_pair_list . possible_comma
    (118) non_empty_array_pair_list -> non_empty_array_pair_list . COMMA BIT_AND variable
    (119) non_empty_array_pair_list -> non_empty_array_pair_list . COMMA expr
    (122) non_empty_array_pair_list -> non_empty_array_pair_list . COMMA expr DOUBLE_ARROW BIT_AND variable
    (123) non_empty_array_pair_list -> non_empty_array_pair_list . COMMA expr DOUBLE_ARROW expr
    (116) possible_comma -> . empty
    (117) possible_comma -> . COMMA
    (180) empty -> .

    COMMA           shift and go to state 251
    RPAREN          reduce using rule 180 (empty -> .)


    empty                          shift and go to state 252
    possible_comma                 shift and go to state 250

state 169

    (120) non_empty_array_pair_list -> BIT_AND . variable
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    base_var                       shift and go to state 43
    func_call                      shift and go to state 40
    variable                       shift and go to state 253

state 170

    (113) expr -> ARRAY LPAREN array_pair_list . RPAREN

    RPAREN          shift and go to state 254



state 171

    (121) non_empty_array_pair_list -> expr .
    (124) non_empty_array_pair_list -> expr . DOUBLE_ARROW BIT_AND variable
    (125) non_empty_array_pair_list -> expr . DOUBLE_ARROW expr
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    COMMA           reduce using rule 121 (non_empty_array_pair_list -> expr .)
    RPAREN          reduce using rule 121 (non_empty_array_pair_list -> expr .)
    DOUBLE_ARROW    shift and go to state 255
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 172

    (114) array_pair_list -> empty .

    RPAREN          reduce using rule 114 (array_pair_list -> empty .)



state 173

    (22) if_stmt -> if_stmt_without_else ELSE stmt .

    ENDFOREACH      reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    WHILE           reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    DO              reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    FOR             reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    FOREACH         reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    SWITCH          reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    BREAK           reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    CONTINUE        reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    RETURN          reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    GLOBAL          reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    STATIC          reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    ECHO            reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    LBRACE          reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    SEMICOLON       reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    FUNCTION        reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    CLONE           reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    ARRAY           reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    PLUS            reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    MINUS           reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    BIT_NOT         reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    NOT             reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    CONST_DECIMAL   reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    CONST_DOUBLE    reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    CONST_STRING    reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    NULL            reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    TRUE            reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    FALSE           reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    INC             reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    DEC             reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    EMPTY           reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    EVAL            reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    LPAREN          reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    INCLUDE         reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    INCLUDE_ONCE    reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    REQUIRE         reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    REQUIRE_ONCE    reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    EXIT            reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    PRINT           reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    IF              reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    IDENTIFIER      reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    STRING          reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    VAR             reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    $end            reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    RBRACE          reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    ENDIF           reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    ELSE            reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    ELSEIF          reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    ENDWHILE        reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    CASE            reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    DEFAULT         reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    ENDSWITCH       reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)
    ENDFOR          reduce using rule 22 (if_stmt -> if_stmt_without_else ELSE stmt .)



state 174

    (24) if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN . expr RPAREN stmt
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 256
    variable                       shift and go to state 53

state 175

    (91) base_var -> base_var LBRACE expr . RBRACE
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RBRACE          shift and go to state 257
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 176

    (94) dim_offset -> empty .

    RBRACKET        reduce using rule 94 (dim_offset -> empty .)



state 177

    (90) base_var -> base_var LBRACKET dim_offset . RBRACKET

    RBRACKET        shift and go to state 258



state 178

    (93) dim_offset -> expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RBRACKET        reduce using rule 93 (dim_offset -> expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 179

    (147) expr -> expr EQ_EQ expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 147 (expr -> expr EQ_EQ expr .)
    AND_OP          reduce using rule 147 (expr -> expr EQ_EQ expr .)
    OR_OP           reduce using rule 147 (expr -> expr EQ_EQ expr .)
    BIT_OR          reduce using rule 147 (expr -> expr EQ_EQ expr .)
    BIT_XOR         reduce using rule 147 (expr -> expr EQ_EQ expr .)
    BIT_AND         reduce using rule 147 (expr -> expr EQ_EQ expr .)
    IDENTICAL       reduce using rule 147 (expr -> expr EQ_EQ expr .)
    NOT_IDENTICAL   reduce using rule 147 (expr -> expr EQ_EQ expr .)
    EQ_EQ           reduce using rule 147 (expr -> expr EQ_EQ expr .)
    NOT_EQ          reduce using rule 147 (expr -> expr EQ_EQ expr .)
    COND_OP         reduce using rule 147 (expr -> expr EQ_EQ expr .)
    COMMA           reduce using rule 147 (expr -> expr EQ_EQ expr .)
    RPAREN          reduce using rule 147 (expr -> expr EQ_EQ expr .)
    AS              reduce using rule 147 (expr -> expr EQ_EQ expr .)
    DOUBLE_ARROW    reduce using rule 147 (expr -> expr EQ_EQ expr .)
    RBRACE          reduce using rule 147 (expr -> expr EQ_EQ expr .)
    RBRACKET        reduce using rule 147 (expr -> expr EQ_EQ expr .)
    COLON           reduce using rule 147 (expr -> expr EQ_EQ expr .)
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114

  ! DOT             [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! PLUS            [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! MINUS           [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! MULT            [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! DIV             [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! MOD             [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! LESSER          [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! GREATER         [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 147 (expr -> expr EQ_EQ expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! COND_OP         [ shift and go to state 116 ]


state 180

    (152) expr -> expr GREATER_EQ expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    AND_OP          reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    OR_OP           reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    BIT_OR          reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    BIT_XOR         reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    BIT_AND         reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    IDENTICAL       reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    NOT_IDENTICAL   reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    EQ_EQ           reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    NOT_EQ          reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    LESSER          reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    LESSER_EQ       reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    GREATER         reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    GREATER_EQ      reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    COND_OP         reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    COMMA           reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    RPAREN          reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    AS              reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    DOUBLE_ARROW    reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    RBRACE          reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    RBRACKET        reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    COLON           reduce using rule 152 (expr -> expr GREATER_EQ expr .)
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    INSTANCEOF      shift and go to state 114

  ! DOT             [ reduce using rule 152 (expr -> expr GREATER_EQ expr .) ]
  ! PLUS            [ reduce using rule 152 (expr -> expr GREATER_EQ expr .) ]
  ! MINUS           [ reduce using rule 152 (expr -> expr GREATER_EQ expr .) ]
  ! MULT            [ reduce using rule 152 (expr -> expr GREATER_EQ expr .) ]
  ! DIV             [ reduce using rule 152 (expr -> expr GREATER_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 152 (expr -> expr GREATER_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 152 (expr -> expr GREATER_EQ expr .) ]
  ! MOD             [ reduce using rule 152 (expr -> expr GREATER_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 152 (expr -> expr GREATER_EQ expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 181

    (141) expr -> expr DIV expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 141 (expr -> expr DIV expr .)
    AND_OP          reduce using rule 141 (expr -> expr DIV expr .)
    OR_OP           reduce using rule 141 (expr -> expr DIV expr .)
    BIT_OR          reduce using rule 141 (expr -> expr DIV expr .)
    BIT_XOR         reduce using rule 141 (expr -> expr DIV expr .)
    BIT_AND         reduce using rule 141 (expr -> expr DIV expr .)
    DOT             reduce using rule 141 (expr -> expr DIV expr .)
    PLUS            reduce using rule 141 (expr -> expr DIV expr .)
    MINUS           reduce using rule 141 (expr -> expr DIV expr .)
    MULT            reduce using rule 141 (expr -> expr DIV expr .)
    DIV             reduce using rule 141 (expr -> expr DIV expr .)
    BIT_LSHIFT      reduce using rule 141 (expr -> expr DIV expr .)
    BIT_RSHIFT      reduce using rule 141 (expr -> expr DIV expr .)
    MOD             reduce using rule 141 (expr -> expr DIV expr .)
    IDENTICAL       reduce using rule 141 (expr -> expr DIV expr .)
    NOT_IDENTICAL   reduce using rule 141 (expr -> expr DIV expr .)
    EQ_EQ           reduce using rule 141 (expr -> expr DIV expr .)
    NOT_EQ          reduce using rule 141 (expr -> expr DIV expr .)
    LESSER          reduce using rule 141 (expr -> expr DIV expr .)
    LESSER_EQ       reduce using rule 141 (expr -> expr DIV expr .)
    GREATER         reduce using rule 141 (expr -> expr DIV expr .)
    GREATER_EQ      reduce using rule 141 (expr -> expr DIV expr .)
    COND_OP         reduce using rule 141 (expr -> expr DIV expr .)
    COMMA           reduce using rule 141 (expr -> expr DIV expr .)
    RPAREN          reduce using rule 141 (expr -> expr DIV expr .)
    AS              reduce using rule 141 (expr -> expr DIV expr .)
    DOUBLE_ARROW    reduce using rule 141 (expr -> expr DIV expr .)
    RBRACE          reduce using rule 141 (expr -> expr DIV expr .)
    RBRACKET        reduce using rule 141 (expr -> expr DIV expr .)
    COLON           reduce using rule 141 (expr -> expr DIV expr .)
    INSTANCEOF      shift and go to state 114

  ! INSTANCEOF      [ reduce using rule 141 (expr -> expr DIV expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! DOT             [ shift and go to state 108 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 102 ]
  ! MULT            [ shift and go to state 103 ]
  ! DIV             [ shift and go to state 100 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! MOD             [ shift and go to state 121 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 182

    (135) expr -> expr BIT_XOR expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 135 (expr -> expr BIT_XOR expr .)
    BIT_OR          reduce using rule 135 (expr -> expr BIT_XOR expr .)
    BIT_XOR         reduce using rule 135 (expr -> expr BIT_XOR expr .)
    COMMA           reduce using rule 135 (expr -> expr BIT_XOR expr .)
    RPAREN          reduce using rule 135 (expr -> expr BIT_XOR expr .)
    AS              reduce using rule 135 (expr -> expr BIT_XOR expr .)
    DOUBLE_ARROW    reduce using rule 135 (expr -> expr BIT_XOR expr .)
    RBRACE          reduce using rule 135 (expr -> expr BIT_XOR expr .)
    RBRACKET        reduce using rule 135 (expr -> expr BIT_XOR expr .)
    COLON           reduce using rule 135 (expr -> expr BIT_XOR expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! OR_OP           [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! BIT_AND         [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! DOT             [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! PLUS            [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! MINUS           [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! MULT            [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! DIV             [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! MOD             [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! IDENTICAL       [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! EQ_EQ           [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! NOT_EQ          [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! LESSER          [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! LESSER_EQ       [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! GREATER         [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! GREATER_EQ      [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! INSTANCEOF      [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! COND_OP         [ reduce using rule 135 (expr -> expr BIT_XOR expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]


state 183

    (139) expr -> expr MINUS expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 139 (expr -> expr MINUS expr .)
    AND_OP          reduce using rule 139 (expr -> expr MINUS expr .)
    OR_OP           reduce using rule 139 (expr -> expr MINUS expr .)
    BIT_OR          reduce using rule 139 (expr -> expr MINUS expr .)
    BIT_XOR         reduce using rule 139 (expr -> expr MINUS expr .)
    BIT_AND         reduce using rule 139 (expr -> expr MINUS expr .)
    DOT             reduce using rule 139 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 139 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 139 (expr -> expr MINUS expr .)
    BIT_LSHIFT      reduce using rule 139 (expr -> expr MINUS expr .)
    BIT_RSHIFT      reduce using rule 139 (expr -> expr MINUS expr .)
    IDENTICAL       reduce using rule 139 (expr -> expr MINUS expr .)
    NOT_IDENTICAL   reduce using rule 139 (expr -> expr MINUS expr .)
    EQ_EQ           reduce using rule 139 (expr -> expr MINUS expr .)
    NOT_EQ          reduce using rule 139 (expr -> expr MINUS expr .)
    LESSER          reduce using rule 139 (expr -> expr MINUS expr .)
    LESSER_EQ       reduce using rule 139 (expr -> expr MINUS expr .)
    GREATER         reduce using rule 139 (expr -> expr MINUS expr .)
    GREATER_EQ      reduce using rule 139 (expr -> expr MINUS expr .)
    COND_OP         reduce using rule 139 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 139 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 139 (expr -> expr MINUS expr .)
    AS              reduce using rule 139 (expr -> expr MINUS expr .)
    DOUBLE_ARROW    reduce using rule 139 (expr -> expr MINUS expr .)
    RBRACE          reduce using rule 139 (expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 139 (expr -> expr MINUS expr .)
    COLON           reduce using rule 139 (expr -> expr MINUS expr .)
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    MOD             shift and go to state 121
    INSTANCEOF      shift and go to state 114

  ! MULT            [ reduce using rule 139 (expr -> expr MINUS expr .) ]
  ! DIV             [ reduce using rule 139 (expr -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 139 (expr -> expr MINUS expr .) ]
  ! INSTANCEOF      [ reduce using rule 139 (expr -> expr MINUS expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! DOT             [ shift and go to state 108 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 102 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 184

    (140) expr -> expr MULT expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 140 (expr -> expr MULT expr .)
    AND_OP          reduce using rule 140 (expr -> expr MULT expr .)
    OR_OP           reduce using rule 140 (expr -> expr MULT expr .)
    BIT_OR          reduce using rule 140 (expr -> expr MULT expr .)
    BIT_XOR         reduce using rule 140 (expr -> expr MULT expr .)
    BIT_AND         reduce using rule 140 (expr -> expr MULT expr .)
    DOT             reduce using rule 140 (expr -> expr MULT expr .)
    PLUS            reduce using rule 140 (expr -> expr MULT expr .)
    MINUS           reduce using rule 140 (expr -> expr MULT expr .)
    MULT            reduce using rule 140 (expr -> expr MULT expr .)
    DIV             reduce using rule 140 (expr -> expr MULT expr .)
    BIT_LSHIFT      reduce using rule 140 (expr -> expr MULT expr .)
    BIT_RSHIFT      reduce using rule 140 (expr -> expr MULT expr .)
    MOD             reduce using rule 140 (expr -> expr MULT expr .)
    IDENTICAL       reduce using rule 140 (expr -> expr MULT expr .)
    NOT_IDENTICAL   reduce using rule 140 (expr -> expr MULT expr .)
    EQ_EQ           reduce using rule 140 (expr -> expr MULT expr .)
    NOT_EQ          reduce using rule 140 (expr -> expr MULT expr .)
    LESSER          reduce using rule 140 (expr -> expr MULT expr .)
    LESSER_EQ       reduce using rule 140 (expr -> expr MULT expr .)
    GREATER         reduce using rule 140 (expr -> expr MULT expr .)
    GREATER_EQ      reduce using rule 140 (expr -> expr MULT expr .)
    COND_OP         reduce using rule 140 (expr -> expr MULT expr .)
    COMMA           reduce using rule 140 (expr -> expr MULT expr .)
    RPAREN          reduce using rule 140 (expr -> expr MULT expr .)
    AS              reduce using rule 140 (expr -> expr MULT expr .)
    DOUBLE_ARROW    reduce using rule 140 (expr -> expr MULT expr .)
    RBRACE          reduce using rule 140 (expr -> expr MULT expr .)
    RBRACKET        reduce using rule 140 (expr -> expr MULT expr .)
    COLON           reduce using rule 140 (expr -> expr MULT expr .)
    INSTANCEOF      shift and go to state 114

  ! INSTANCEOF      [ reduce using rule 140 (expr -> expr MULT expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! DOT             [ shift and go to state 108 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 102 ]
  ! MULT            [ shift and go to state 103 ]
  ! DIV             [ shift and go to state 100 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! MOD             [ shift and go to state 121 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 185

    (145) expr -> expr IDENTICAL expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 145 (expr -> expr IDENTICAL expr .)
    AND_OP          reduce using rule 145 (expr -> expr IDENTICAL expr .)
    OR_OP           reduce using rule 145 (expr -> expr IDENTICAL expr .)
    BIT_OR          reduce using rule 145 (expr -> expr IDENTICAL expr .)
    BIT_XOR         reduce using rule 145 (expr -> expr IDENTICAL expr .)
    BIT_AND         reduce using rule 145 (expr -> expr IDENTICAL expr .)
    IDENTICAL       reduce using rule 145 (expr -> expr IDENTICAL expr .)
    NOT_IDENTICAL   reduce using rule 145 (expr -> expr IDENTICAL expr .)
    EQ_EQ           reduce using rule 145 (expr -> expr IDENTICAL expr .)
    NOT_EQ          reduce using rule 145 (expr -> expr IDENTICAL expr .)
    COND_OP         reduce using rule 145 (expr -> expr IDENTICAL expr .)
    COMMA           reduce using rule 145 (expr -> expr IDENTICAL expr .)
    RPAREN          reduce using rule 145 (expr -> expr IDENTICAL expr .)
    AS              reduce using rule 145 (expr -> expr IDENTICAL expr .)
    DOUBLE_ARROW    reduce using rule 145 (expr -> expr IDENTICAL expr .)
    RBRACE          reduce using rule 145 (expr -> expr IDENTICAL expr .)
    RBRACKET        reduce using rule 145 (expr -> expr IDENTICAL expr .)
    COLON           reduce using rule 145 (expr -> expr IDENTICAL expr .)
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114

  ! DOT             [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! PLUS            [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! MINUS           [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! MULT            [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! DIV             [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! MOD             [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! LESSER          [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! LESSER_EQ       [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! GREATER         [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! GREATER_EQ      [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! INSTANCEOF      [ reduce using rule 145 (expr -> expr IDENTICAL expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! COND_OP         [ shift and go to state 116 ]


state 186

    (133) expr -> expr OR_OP expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 133 (expr -> expr OR_OP expr .)
    OR_OP           reduce using rule 133 (expr -> expr OR_OP expr .)
    BIT_OR          reduce using rule 133 (expr -> expr OR_OP expr .)
    BIT_XOR         reduce using rule 133 (expr -> expr OR_OP expr .)
    BIT_AND         reduce using rule 133 (expr -> expr OR_OP expr .)
    COND_OP         reduce using rule 133 (expr -> expr OR_OP expr .)
    COMMA           reduce using rule 133 (expr -> expr OR_OP expr .)
    RPAREN          reduce using rule 133 (expr -> expr OR_OP expr .)
    AS              reduce using rule 133 (expr -> expr OR_OP expr .)
    DOUBLE_ARROW    reduce using rule 133 (expr -> expr OR_OP expr .)
    RBRACE          reduce using rule 133 (expr -> expr OR_OP expr .)
    RBRACKET        reduce using rule 133 (expr -> expr OR_OP expr .)
    COLON           reduce using rule 133 (expr -> expr OR_OP expr .)
    AND_OP          shift and go to state 113
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114

  ! AND_OP          [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! DOT             [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! PLUS            [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! MINUS           [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! MULT            [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! DIV             [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! MOD             [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! IDENTICAL       [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! EQ_EQ           [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! NOT_EQ          [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! LESSER          [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! LESSER_EQ       [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! GREATER         [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! GREATER_EQ      [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! INSTANCEOF      [ reduce using rule 133 (expr -> expr OR_OP expr .) ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! COND_OP         [ shift and go to state 116 ]


state 187

    (138) expr -> expr PLUS expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 138 (expr -> expr PLUS expr .)
    AND_OP          reduce using rule 138 (expr -> expr PLUS expr .)
    OR_OP           reduce using rule 138 (expr -> expr PLUS expr .)
    BIT_OR          reduce using rule 138 (expr -> expr PLUS expr .)
    BIT_XOR         reduce using rule 138 (expr -> expr PLUS expr .)
    BIT_AND         reduce using rule 138 (expr -> expr PLUS expr .)
    DOT             reduce using rule 138 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 138 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 138 (expr -> expr PLUS expr .)
    BIT_LSHIFT      reduce using rule 138 (expr -> expr PLUS expr .)
    BIT_RSHIFT      reduce using rule 138 (expr -> expr PLUS expr .)
    IDENTICAL       reduce using rule 138 (expr -> expr PLUS expr .)
    NOT_IDENTICAL   reduce using rule 138 (expr -> expr PLUS expr .)
    EQ_EQ           reduce using rule 138 (expr -> expr PLUS expr .)
    NOT_EQ          reduce using rule 138 (expr -> expr PLUS expr .)
    LESSER          reduce using rule 138 (expr -> expr PLUS expr .)
    LESSER_EQ       reduce using rule 138 (expr -> expr PLUS expr .)
    GREATER         reduce using rule 138 (expr -> expr PLUS expr .)
    GREATER_EQ      reduce using rule 138 (expr -> expr PLUS expr .)
    COND_OP         reduce using rule 138 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 138 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 138 (expr -> expr PLUS expr .)
    AS              reduce using rule 138 (expr -> expr PLUS expr .)
    DOUBLE_ARROW    reduce using rule 138 (expr -> expr PLUS expr .)
    RBRACE          reduce using rule 138 (expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 138 (expr -> expr PLUS expr .)
    COLON           reduce using rule 138 (expr -> expr PLUS expr .)
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    MOD             shift and go to state 121
    INSTANCEOF      shift and go to state 114

  ! MULT            [ reduce using rule 138 (expr -> expr PLUS expr .) ]
  ! DIV             [ reduce using rule 138 (expr -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 138 (expr -> expr PLUS expr .) ]
  ! INSTANCEOF      [ reduce using rule 138 (expr -> expr PLUS expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! DOT             [ shift and go to state 108 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 102 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 188

    (137) expr -> expr DOT expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 137 (expr -> expr DOT expr .)
    AND_OP          reduce using rule 137 (expr -> expr DOT expr .)
    OR_OP           reduce using rule 137 (expr -> expr DOT expr .)
    BIT_OR          reduce using rule 137 (expr -> expr DOT expr .)
    BIT_XOR         reduce using rule 137 (expr -> expr DOT expr .)
    BIT_AND         reduce using rule 137 (expr -> expr DOT expr .)
    DOT             reduce using rule 137 (expr -> expr DOT expr .)
    PLUS            reduce using rule 137 (expr -> expr DOT expr .)
    MINUS           reduce using rule 137 (expr -> expr DOT expr .)
    BIT_LSHIFT      reduce using rule 137 (expr -> expr DOT expr .)
    BIT_RSHIFT      reduce using rule 137 (expr -> expr DOT expr .)
    IDENTICAL       reduce using rule 137 (expr -> expr DOT expr .)
    NOT_IDENTICAL   reduce using rule 137 (expr -> expr DOT expr .)
    EQ_EQ           reduce using rule 137 (expr -> expr DOT expr .)
    NOT_EQ          reduce using rule 137 (expr -> expr DOT expr .)
    LESSER          reduce using rule 137 (expr -> expr DOT expr .)
    LESSER_EQ       reduce using rule 137 (expr -> expr DOT expr .)
    GREATER         reduce using rule 137 (expr -> expr DOT expr .)
    GREATER_EQ      reduce using rule 137 (expr -> expr DOT expr .)
    COND_OP         reduce using rule 137 (expr -> expr DOT expr .)
    COMMA           reduce using rule 137 (expr -> expr DOT expr .)
    RPAREN          reduce using rule 137 (expr -> expr DOT expr .)
    AS              reduce using rule 137 (expr -> expr DOT expr .)
    DOUBLE_ARROW    reduce using rule 137 (expr -> expr DOT expr .)
    RBRACE          reduce using rule 137 (expr -> expr DOT expr .)
    RBRACKET        reduce using rule 137 (expr -> expr DOT expr .)
    COLON           reduce using rule 137 (expr -> expr DOT expr .)
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    MOD             shift and go to state 121
    INSTANCEOF      shift and go to state 114

  ! MULT            [ reduce using rule 137 (expr -> expr DOT expr .) ]
  ! DIV             [ reduce using rule 137 (expr -> expr DOT expr .) ]
  ! MOD             [ reduce using rule 137 (expr -> expr DOT expr .) ]
  ! INSTANCEOF      [ reduce using rule 137 (expr -> expr DOT expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! DOT             [ shift and go to state 108 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 102 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 189

    (148) expr -> expr NOT_EQ expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 148 (expr -> expr NOT_EQ expr .)
    AND_OP          reduce using rule 148 (expr -> expr NOT_EQ expr .)
    OR_OP           reduce using rule 148 (expr -> expr NOT_EQ expr .)
    BIT_OR          reduce using rule 148 (expr -> expr NOT_EQ expr .)
    BIT_XOR         reduce using rule 148 (expr -> expr NOT_EQ expr .)
    BIT_AND         reduce using rule 148 (expr -> expr NOT_EQ expr .)
    IDENTICAL       reduce using rule 148 (expr -> expr NOT_EQ expr .)
    NOT_IDENTICAL   reduce using rule 148 (expr -> expr NOT_EQ expr .)
    EQ_EQ           reduce using rule 148 (expr -> expr NOT_EQ expr .)
    NOT_EQ          reduce using rule 148 (expr -> expr NOT_EQ expr .)
    COND_OP         reduce using rule 148 (expr -> expr NOT_EQ expr .)
    COMMA           reduce using rule 148 (expr -> expr NOT_EQ expr .)
    RPAREN          reduce using rule 148 (expr -> expr NOT_EQ expr .)
    AS              reduce using rule 148 (expr -> expr NOT_EQ expr .)
    DOUBLE_ARROW    reduce using rule 148 (expr -> expr NOT_EQ expr .)
    RBRACE          reduce using rule 148 (expr -> expr NOT_EQ expr .)
    RBRACKET        reduce using rule 148 (expr -> expr NOT_EQ expr .)
    COLON           reduce using rule 148 (expr -> expr NOT_EQ expr .)
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114

  ! DOT             [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! PLUS            [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! MINUS           [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! MULT            [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! DIV             [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! MOD             [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! LESSER          [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! GREATER         [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 148 (expr -> expr NOT_EQ expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! COND_OP         [ shift and go to state 116 ]


state 190

    (146) expr -> expr NOT_IDENTICAL expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    AND_OP          reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    OR_OP           reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    BIT_OR          reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    BIT_XOR         reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    BIT_AND         reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    IDENTICAL       reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    NOT_IDENTICAL   reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    EQ_EQ           reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    NOT_EQ          reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    COND_OP         reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    COMMA           reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    RPAREN          reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    AS              reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    DOUBLE_ARROW    reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    RBRACE          reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    RBRACKET        reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    COLON           reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .)
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114

  ! DOT             [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! PLUS            [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! MINUS           [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! MULT            [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! DIV             [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! MOD             [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! LESSER          [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! LESSER_EQ       [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! GREATER         [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! GREATER_EQ      [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! INSTANCEOF      [ reduce using rule 146 (expr -> expr NOT_IDENTICAL expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! COND_OP         [ shift and go to state 116 ]


state 191

    (136) expr -> expr BIT_AND expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 136 (expr -> expr BIT_AND expr .)
    BIT_OR          reduce using rule 136 (expr -> expr BIT_AND expr .)
    BIT_XOR         reduce using rule 136 (expr -> expr BIT_AND expr .)
    BIT_AND         reduce using rule 136 (expr -> expr BIT_AND expr .)
    COMMA           reduce using rule 136 (expr -> expr BIT_AND expr .)
    RPAREN          reduce using rule 136 (expr -> expr BIT_AND expr .)
    AS              reduce using rule 136 (expr -> expr BIT_AND expr .)
    DOUBLE_ARROW    reduce using rule 136 (expr -> expr BIT_AND expr .)
    RBRACE          reduce using rule 136 (expr -> expr BIT_AND expr .)
    RBRACKET        reduce using rule 136 (expr -> expr BIT_AND expr .)
    COLON           reduce using rule 136 (expr -> expr BIT_AND expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! OR_OP           [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! DOT             [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! PLUS            [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! MINUS           [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! MULT            [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! DIV             [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! MOD             [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! IDENTICAL       [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! EQ_EQ           [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! NOT_EQ          [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! LESSER          [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! LESSER_EQ       [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! GREATER         [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! GREATER_EQ      [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! INSTANCEOF      [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! COND_OP         [ reduce using rule 136 (expr -> expr BIT_AND expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]


state 192

    (150) expr -> expr LESSER_EQ expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    AND_OP          reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    OR_OP           reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    BIT_OR          reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    BIT_XOR         reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    BIT_AND         reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    IDENTICAL       reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    NOT_IDENTICAL   reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    EQ_EQ           reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    NOT_EQ          reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    LESSER          reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    LESSER_EQ       reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    GREATER         reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    GREATER_EQ      reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    COND_OP         reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    COMMA           reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    RPAREN          reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    AS              reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    DOUBLE_ARROW    reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    RBRACE          reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    RBRACKET        reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    COLON           reduce using rule 150 (expr -> expr LESSER_EQ expr .)
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    INSTANCEOF      shift and go to state 114

  ! DOT             [ reduce using rule 150 (expr -> expr LESSER_EQ expr .) ]
  ! PLUS            [ reduce using rule 150 (expr -> expr LESSER_EQ expr .) ]
  ! MINUS           [ reduce using rule 150 (expr -> expr LESSER_EQ expr .) ]
  ! MULT            [ reduce using rule 150 (expr -> expr LESSER_EQ expr .) ]
  ! DIV             [ reduce using rule 150 (expr -> expr LESSER_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 150 (expr -> expr LESSER_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 150 (expr -> expr LESSER_EQ expr .) ]
  ! MOD             [ reduce using rule 150 (expr -> expr LESSER_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 150 (expr -> expr LESSER_EQ expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 193

    (132) expr -> expr AND_OP expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 132 (expr -> expr AND_OP expr .)
    AND_OP          reduce using rule 132 (expr -> expr AND_OP expr .)
    OR_OP           reduce using rule 132 (expr -> expr AND_OP expr .)
    BIT_OR          reduce using rule 132 (expr -> expr AND_OP expr .)
    BIT_XOR         reduce using rule 132 (expr -> expr AND_OP expr .)
    BIT_AND         reduce using rule 132 (expr -> expr AND_OP expr .)
    COND_OP         reduce using rule 132 (expr -> expr AND_OP expr .)
    COMMA           reduce using rule 132 (expr -> expr AND_OP expr .)
    RPAREN          reduce using rule 132 (expr -> expr AND_OP expr .)
    AS              reduce using rule 132 (expr -> expr AND_OP expr .)
    DOUBLE_ARROW    reduce using rule 132 (expr -> expr AND_OP expr .)
    RBRACE          reduce using rule 132 (expr -> expr AND_OP expr .)
    RBRACKET        reduce using rule 132 (expr -> expr AND_OP expr .)
    COLON           reduce using rule 132 (expr -> expr AND_OP expr .)
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114

  ! DOT             [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! PLUS            [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! MINUS           [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! MULT            [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! DIV             [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! MOD             [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! IDENTICAL       [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! EQ_EQ           [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! NOT_EQ          [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! LESSER          [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! LESSER_EQ       [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! GREATER         [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! GREATER_EQ      [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! INSTANCEOF      [ reduce using rule 132 (expr -> expr AND_OP expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! COND_OP         [ shift and go to state 116 ]


state 194

    (153) expr -> expr INSTANCEOF expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    AND_OP          reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    OR_OP           reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    BIT_OR          reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    BIT_XOR         reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    BIT_AND         reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    DOT             reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    PLUS            reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    MINUS           reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    MULT            reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    DIV             reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    BIT_LSHIFT      reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    BIT_RSHIFT      reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    MOD             reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    IDENTICAL       reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    NOT_IDENTICAL   reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    EQ_EQ           reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    NOT_EQ          reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    LESSER          reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    LESSER_EQ       reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    GREATER         reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    GREATER_EQ      reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    INSTANCEOF      reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    COND_OP         reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    COMMA           reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    RPAREN          reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    AS              reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    DOUBLE_ARROW    reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    RBRACE          reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    RBRACKET        reduce using rule 153 (expr -> expr INSTANCEOF expr .)
    COLON           reduce using rule 153 (expr -> expr INSTANCEOF expr .)

  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! DOT             [ shift and go to state 108 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 102 ]
  ! MULT            [ shift and go to state 103 ]
  ! DIV             [ shift and go to state 100 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! MOD             [ shift and go to state 121 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! INSTANCEOF      [ shift and go to state 114 ]
  ! COND_OP         [ shift and go to state 116 ]


state 195

    (151) expr -> expr GREATER expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 151 (expr -> expr GREATER expr .)
    AND_OP          reduce using rule 151 (expr -> expr GREATER expr .)
    OR_OP           reduce using rule 151 (expr -> expr GREATER expr .)
    BIT_OR          reduce using rule 151 (expr -> expr GREATER expr .)
    BIT_XOR         reduce using rule 151 (expr -> expr GREATER expr .)
    BIT_AND         reduce using rule 151 (expr -> expr GREATER expr .)
    IDENTICAL       reduce using rule 151 (expr -> expr GREATER expr .)
    NOT_IDENTICAL   reduce using rule 151 (expr -> expr GREATER expr .)
    EQ_EQ           reduce using rule 151 (expr -> expr GREATER expr .)
    NOT_EQ          reduce using rule 151 (expr -> expr GREATER expr .)
    LESSER          reduce using rule 151 (expr -> expr GREATER expr .)
    LESSER_EQ       reduce using rule 151 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 151 (expr -> expr GREATER expr .)
    GREATER_EQ      reduce using rule 151 (expr -> expr GREATER expr .)
    COND_OP         reduce using rule 151 (expr -> expr GREATER expr .)
    COMMA           reduce using rule 151 (expr -> expr GREATER expr .)
    RPAREN          reduce using rule 151 (expr -> expr GREATER expr .)
    AS              reduce using rule 151 (expr -> expr GREATER expr .)
    DOUBLE_ARROW    reduce using rule 151 (expr -> expr GREATER expr .)
    RBRACE          reduce using rule 151 (expr -> expr GREATER expr .)
    RBRACKET        reduce using rule 151 (expr -> expr GREATER expr .)
    COLON           reduce using rule 151 (expr -> expr GREATER expr .)
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    INSTANCEOF      shift and go to state 114

  ! DOT             [ reduce using rule 151 (expr -> expr GREATER expr .) ]
  ! PLUS            [ reduce using rule 151 (expr -> expr GREATER expr .) ]
  ! MINUS           [ reduce using rule 151 (expr -> expr GREATER expr .) ]
  ! MULT            [ reduce using rule 151 (expr -> expr GREATER expr .) ]
  ! DIV             [ reduce using rule 151 (expr -> expr GREATER expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 151 (expr -> expr GREATER expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 151 (expr -> expr GREATER expr .) ]
  ! MOD             [ reduce using rule 151 (expr -> expr GREATER expr .) ]
  ! INSTANCEOF      [ reduce using rule 151 (expr -> expr GREATER expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 196

    (164) expr -> expr COND_OP expr . COLON expr
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    COLON           shift and go to state 259
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 197

    (143) expr -> expr BIT_RSHIFT expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    AND_OP          reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    OR_OP           reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    BIT_OR          reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    BIT_XOR         reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    BIT_AND         reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    BIT_LSHIFT      reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    BIT_RSHIFT      reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    IDENTICAL       reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    NOT_IDENTICAL   reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    EQ_EQ           reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    NOT_EQ          reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    LESSER          reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    LESSER_EQ       reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    GREATER         reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    GREATER_EQ      reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    COND_OP         reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    COMMA           reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    RPAREN          reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    AS              reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    DOUBLE_ARROW    reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    RBRACE          reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    RBRACKET        reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    COLON           reduce using rule 143 (expr -> expr BIT_RSHIFT expr .)
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    MOD             shift and go to state 121
    INSTANCEOF      shift and go to state 114

  ! DOT             [ reduce using rule 143 (expr -> expr BIT_RSHIFT expr .) ]
  ! PLUS            [ reduce using rule 143 (expr -> expr BIT_RSHIFT expr .) ]
  ! MINUS           [ reduce using rule 143 (expr -> expr BIT_RSHIFT expr .) ]
  ! MULT            [ reduce using rule 143 (expr -> expr BIT_RSHIFT expr .) ]
  ! DIV             [ reduce using rule 143 (expr -> expr BIT_RSHIFT expr .) ]
  ! MOD             [ reduce using rule 143 (expr -> expr BIT_RSHIFT expr .) ]
  ! INSTANCEOF      [ reduce using rule 143 (expr -> expr BIT_RSHIFT expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 198

    (134) expr -> expr BIT_OR expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 134 (expr -> expr BIT_OR expr .)
    BIT_OR          reduce using rule 134 (expr -> expr BIT_OR expr .)
    COMMA           reduce using rule 134 (expr -> expr BIT_OR expr .)
    RPAREN          reduce using rule 134 (expr -> expr BIT_OR expr .)
    AS              reduce using rule 134 (expr -> expr BIT_OR expr .)
    DOUBLE_ARROW    reduce using rule 134 (expr -> expr BIT_OR expr .)
    RBRACE          reduce using rule 134 (expr -> expr BIT_OR expr .)
    RBRACKET        reduce using rule 134 (expr -> expr BIT_OR expr .)
    COLON           reduce using rule 134 (expr -> expr BIT_OR expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! OR_OP           [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! BIT_XOR         [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! BIT_AND         [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! DOT             [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! PLUS            [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! MINUS           [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! MULT            [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! DIV             [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! MOD             [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! IDENTICAL       [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! EQ_EQ           [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! NOT_EQ          [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! LESSER          [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! LESSER_EQ       [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! GREATER         [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! GREATER_EQ      [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! INSTANCEOF      [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! COND_OP         [ reduce using rule 134 (expr -> expr BIT_OR expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]


state 199

    (149) expr -> expr LESSER expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 149 (expr -> expr LESSER expr .)
    AND_OP          reduce using rule 149 (expr -> expr LESSER expr .)
    OR_OP           reduce using rule 149 (expr -> expr LESSER expr .)
    BIT_OR          reduce using rule 149 (expr -> expr LESSER expr .)
    BIT_XOR         reduce using rule 149 (expr -> expr LESSER expr .)
    BIT_AND         reduce using rule 149 (expr -> expr LESSER expr .)
    IDENTICAL       reduce using rule 149 (expr -> expr LESSER expr .)
    NOT_IDENTICAL   reduce using rule 149 (expr -> expr LESSER expr .)
    EQ_EQ           reduce using rule 149 (expr -> expr LESSER expr .)
    NOT_EQ          reduce using rule 149 (expr -> expr LESSER expr .)
    LESSER          reduce using rule 149 (expr -> expr LESSER expr .)
    LESSER_EQ       reduce using rule 149 (expr -> expr LESSER expr .)
    GREATER         reduce using rule 149 (expr -> expr LESSER expr .)
    GREATER_EQ      reduce using rule 149 (expr -> expr LESSER expr .)
    COND_OP         reduce using rule 149 (expr -> expr LESSER expr .)
    COMMA           reduce using rule 149 (expr -> expr LESSER expr .)
    RPAREN          reduce using rule 149 (expr -> expr LESSER expr .)
    AS              reduce using rule 149 (expr -> expr LESSER expr .)
    DOUBLE_ARROW    reduce using rule 149 (expr -> expr LESSER expr .)
    RBRACE          reduce using rule 149 (expr -> expr LESSER expr .)
    RBRACKET        reduce using rule 149 (expr -> expr LESSER expr .)
    COLON           reduce using rule 149 (expr -> expr LESSER expr .)
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    INSTANCEOF      shift and go to state 114

  ! DOT             [ reduce using rule 149 (expr -> expr LESSER expr .) ]
  ! PLUS            [ reduce using rule 149 (expr -> expr LESSER expr .) ]
  ! MINUS           [ reduce using rule 149 (expr -> expr LESSER expr .) ]
  ! MULT            [ reduce using rule 149 (expr -> expr LESSER expr .) ]
  ! DIV             [ reduce using rule 149 (expr -> expr LESSER expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 149 (expr -> expr LESSER expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 149 (expr -> expr LESSER expr .) ]
  ! MOD             [ reduce using rule 149 (expr -> expr LESSER expr .) ]
  ! INSTANCEOF      [ reduce using rule 149 (expr -> expr LESSER expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 200

    (142) expr -> expr BIT_LSHIFT expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    AND_OP          reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    OR_OP           reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    BIT_OR          reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    BIT_XOR         reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    BIT_AND         reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    BIT_LSHIFT      reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    BIT_RSHIFT      reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    IDENTICAL       reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    NOT_IDENTICAL   reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    EQ_EQ           reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    NOT_EQ          reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    LESSER          reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    LESSER_EQ       reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    GREATER         reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    GREATER_EQ      reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    COND_OP         reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    COMMA           reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    RPAREN          reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    AS              reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    DOUBLE_ARROW    reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    RBRACE          reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    RBRACKET        reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    COLON           reduce using rule 142 (expr -> expr BIT_LSHIFT expr .)
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    MOD             shift and go to state 121
    INSTANCEOF      shift and go to state 114

  ! DOT             [ reduce using rule 142 (expr -> expr BIT_LSHIFT expr .) ]
  ! PLUS            [ reduce using rule 142 (expr -> expr BIT_LSHIFT expr .) ]
  ! MINUS           [ reduce using rule 142 (expr -> expr BIT_LSHIFT expr .) ]
  ! MULT            [ reduce using rule 142 (expr -> expr BIT_LSHIFT expr .) ]
  ! DIV             [ reduce using rule 142 (expr -> expr BIT_LSHIFT expr .) ]
  ! MOD             [ reduce using rule 142 (expr -> expr BIT_LSHIFT expr .) ]
  ! INSTANCEOF      [ reduce using rule 142 (expr -> expr BIT_LSHIFT expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 201

    (144) expr -> expr MOD expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 144 (expr -> expr MOD expr .)
    AND_OP          reduce using rule 144 (expr -> expr MOD expr .)
    OR_OP           reduce using rule 144 (expr -> expr MOD expr .)
    BIT_OR          reduce using rule 144 (expr -> expr MOD expr .)
    BIT_XOR         reduce using rule 144 (expr -> expr MOD expr .)
    BIT_AND         reduce using rule 144 (expr -> expr MOD expr .)
    DOT             reduce using rule 144 (expr -> expr MOD expr .)
    PLUS            reduce using rule 144 (expr -> expr MOD expr .)
    MINUS           reduce using rule 144 (expr -> expr MOD expr .)
    MULT            reduce using rule 144 (expr -> expr MOD expr .)
    DIV             reduce using rule 144 (expr -> expr MOD expr .)
    BIT_LSHIFT      reduce using rule 144 (expr -> expr MOD expr .)
    BIT_RSHIFT      reduce using rule 144 (expr -> expr MOD expr .)
    MOD             reduce using rule 144 (expr -> expr MOD expr .)
    IDENTICAL       reduce using rule 144 (expr -> expr MOD expr .)
    NOT_IDENTICAL   reduce using rule 144 (expr -> expr MOD expr .)
    EQ_EQ           reduce using rule 144 (expr -> expr MOD expr .)
    NOT_EQ          reduce using rule 144 (expr -> expr MOD expr .)
    LESSER          reduce using rule 144 (expr -> expr MOD expr .)
    LESSER_EQ       reduce using rule 144 (expr -> expr MOD expr .)
    GREATER         reduce using rule 144 (expr -> expr MOD expr .)
    GREATER_EQ      reduce using rule 144 (expr -> expr MOD expr .)
    COND_OP         reduce using rule 144 (expr -> expr MOD expr .)
    COMMA           reduce using rule 144 (expr -> expr MOD expr .)
    RPAREN          reduce using rule 144 (expr -> expr MOD expr .)
    AS              reduce using rule 144 (expr -> expr MOD expr .)
    DOUBLE_ARROW    reduce using rule 144 (expr -> expr MOD expr .)
    RBRACE          reduce using rule 144 (expr -> expr MOD expr .)
    RBRACKET        reduce using rule 144 (expr -> expr MOD expr .)
    COLON           reduce using rule 144 (expr -> expr MOD expr .)
    INSTANCEOF      shift and go to state 114

  ! INSTANCEOF      [ reduce using rule 144 (expr -> expr MOD expr .) ]
  ! AND_OP          [ shift and go to state 113 ]
  ! OR_OP           [ shift and go to state 106 ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! DOT             [ shift and go to state 108 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 102 ]
  ! MULT            [ shift and go to state 103 ]
  ! DIV             [ shift and go to state 100 ]
  ! BIT_LSHIFT      [ shift and go to state 120 ]
  ! BIT_RSHIFT      [ shift and go to state 117 ]
  ! MOD             [ shift and go to state 121 ]
  ! IDENTICAL       [ shift and go to state 104 ]
  ! NOT_IDENTICAL   [ shift and go to state 110 ]
  ! EQ_EQ           [ shift and go to state 98 ]
  ! NOT_EQ          [ shift and go to state 109 ]
  ! LESSER          [ shift and go to state 119 ]
  ! LESSER_EQ       [ shift and go to state 112 ]
  ! GREATER         [ shift and go to state 115 ]
  ! GREATER_EQ      [ shift and go to state 99 ]
  ! COND_OP         [ shift and go to state 116 ]


state 202

    (58) stmt -> BREAK expr SEMICOLON .

    WHILE           reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    DO              reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    FOR             reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    FOREACH         reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    SWITCH          reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    BREAK           reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    CONTINUE        reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    RETURN          reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    GLOBAL          reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    STATIC          reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    ECHO            reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    LBRACE          reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    SEMICOLON       reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    FUNCTION        reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    CLONE           reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    ARRAY           reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    PLUS            reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    MINUS           reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    BIT_NOT         reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    NOT             reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    CONST_DECIMAL   reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    CONST_DOUBLE    reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    CONST_STRING    reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    NULL            reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    TRUE            reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    FALSE           reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    INC             reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    DEC             reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    EMPTY           reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    EVAL            reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    LPAREN          reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    INCLUDE         reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    REQUIRE         reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    EXIT            reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    PRINT           reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    IF              reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    IDENTIFIER      reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    STRING          reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    ENDIF           reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    ELSE            reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    ELSEIF          reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    RBRACE          reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    VAR             reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    $end            reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    ENDWHILE        reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    ENDFOREACH      reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    CASE            reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    DEFAULT         reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    ENDSWITCH       reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)
    ENDFOR          reduce using rule 58 (stmt -> BREAK expr SEMICOLON .)



state 203

    (177) expr -> EXIT LPAREN RPAREN .

    SEMICOLON       reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    AND_OP          reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    OR_OP           reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    BIT_OR          reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    BIT_XOR         reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    BIT_AND         reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    DOT             reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    PLUS            reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    MINUS           reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    MULT            reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    DIV             reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    BIT_LSHIFT      reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    BIT_RSHIFT      reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    MOD             reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    IDENTICAL       reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    NOT_IDENTICAL   reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    EQ_EQ           reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    NOT_EQ          reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    LESSER          reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    LESSER_EQ       reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    GREATER         reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    GREATER_EQ      reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    INSTANCEOF      reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    COND_OP         reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    COMMA           reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    RPAREN          reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    AS              reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    DOUBLE_ARROW    reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    RBRACE          reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    RBRACKET        reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)
    COLON           reduce using rule 177 (expr -> EXIT LPAREN RPAREN .)



state 204

    (178) expr -> EXIT LPAREN expr . RPAREN
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RPAREN          shift and go to state 260
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 205

    (32) stmt -> DO stmt WHILE . LPAREN expr RPAREN SEMICOLON

    LPAREN          shift and go to state 261



state 206

    (84) func_call -> STRING LPAREN func_params . RPAREN
    (85) func_params -> func_params . COMMA func_param

    RPAREN          shift and go to state 262
    COMMA           shift and go to state 263



state 207

    (87) func_params -> empty .

    RPAREN          reduce using rule 87 (func_params -> empty .)
    COMMA           reduce using rule 87 (func_params -> empty .)



state 208

    (86) func_params -> func_param .

    RPAREN          reduce using rule 86 (func_params -> func_param .)
    COMMA           reduce using rule 86 (func_params -> func_param .)



state 209

    (89) func_param -> BIT_AND . variable
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    base_var                       shift and go to state 43
    func_call                      shift and go to state 40
    variable                       shift and go to state 264

state 210

    (88) func_param -> expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RPAREN          reduce using rule 88 (func_param -> expr .)
    COMMA           reduce using rule 88 (func_param -> expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 211

    (171) expr -> LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    AND_OP          reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    OR_OP           reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    BIT_OR          reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    BIT_XOR         reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    BIT_AND         reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    DOT             reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    MULT            reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    DIV             reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    BIT_LSHIFT      reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    BIT_RSHIFT      reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    IDENTICAL       reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    NOT_IDENTICAL   reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    EQ_EQ           reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    LESSER          reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    LESSER_EQ       reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    INSTANCEOF      reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    COND_OP         reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    AS              reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    DOUBLE_ARROW    reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 171 (expr -> LPAREN expr RPAREN .)
    COLON           reduce using rule 171 (expr -> LPAREN expr RPAREN .)



state 212

    (130) expr -> variable DOT_EQ expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 130 (expr -> variable DOT_EQ expr .)
    BIT_OR          reduce using rule 130 (expr -> variable DOT_EQ expr .)
    BIT_XOR         reduce using rule 130 (expr -> variable DOT_EQ expr .)
    BIT_AND         reduce using rule 130 (expr -> variable DOT_EQ expr .)
    COMMA           reduce using rule 130 (expr -> variable DOT_EQ expr .)
    RPAREN          reduce using rule 130 (expr -> variable DOT_EQ expr .)
    AS              reduce using rule 130 (expr -> variable DOT_EQ expr .)
    DOUBLE_ARROW    reduce using rule 130 (expr -> variable DOT_EQ expr .)
    RBRACE          reduce using rule 130 (expr -> variable DOT_EQ expr .)
    RBRACKET        reduce using rule 130 (expr -> variable DOT_EQ expr .)
    COLON           reduce using rule 130 (expr -> variable DOT_EQ expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! OR_OP           [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! DOT             [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! PLUS            [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! MINUS           [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! MULT            [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! DIV             [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! MOD             [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! LESSER          [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! GREATER         [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! COND_OP         [ reduce using rule 130 (expr -> variable DOT_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]


state 213

    (128) expr -> variable MULTIPLY_EQ expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .)
    BIT_OR          reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .)
    BIT_XOR         reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .)
    BIT_AND         reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .)
    COMMA           reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .)
    RPAREN          reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .)
    AS              reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .)
    DOUBLE_ARROW    reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .)
    RBRACE          reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .)
    RBRACKET        reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .)
    COLON           reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! OR_OP           [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! DOT             [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! PLUS            [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! MINUS           [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! MULT            [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! DIV             [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! MOD             [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! LESSER          [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! GREATER         [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! COND_OP         [ reduce using rule 128 (expr -> variable MULTIPLY_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]


state 214

    (96) expr -> variable EQUAL BIT_AND . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 265
    variable                       shift and go to state 53

state 215

    (95) expr -> variable EQUAL expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 95 (expr -> variable EQUAL expr .)
    BIT_OR          reduce using rule 95 (expr -> variable EQUAL expr .)
    BIT_XOR         reduce using rule 95 (expr -> variable EQUAL expr .)
    BIT_AND         reduce using rule 95 (expr -> variable EQUAL expr .)
    COMMA           reduce using rule 95 (expr -> variable EQUAL expr .)
    RPAREN          reduce using rule 95 (expr -> variable EQUAL expr .)
    AS              reduce using rule 95 (expr -> variable EQUAL expr .)
    DOUBLE_ARROW    reduce using rule 95 (expr -> variable EQUAL expr .)
    RBRACE          reduce using rule 95 (expr -> variable EQUAL expr .)
    RBRACKET        reduce using rule 95 (expr -> variable EQUAL expr .)
    COLON           reduce using rule 95 (expr -> variable EQUAL expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! OR_OP           [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! DOT             [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! PLUS            [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! MINUS           [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! MULT            [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! DIV             [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! MOD             [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! IDENTICAL       [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! EQ_EQ           [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! NOT_EQ          [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! LESSER          [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! LESSER_EQ       [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! GREATER         [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! GREATER_EQ      [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! INSTANCEOF      [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! COND_OP         [ reduce using rule 95 (expr -> variable EQUAL expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]


state 216

    (126) expr -> variable PLUS_EQ expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 126 (expr -> variable PLUS_EQ expr .)
    BIT_OR          reduce using rule 126 (expr -> variable PLUS_EQ expr .)
    BIT_XOR         reduce using rule 126 (expr -> variable PLUS_EQ expr .)
    BIT_AND         reduce using rule 126 (expr -> variable PLUS_EQ expr .)
    COMMA           reduce using rule 126 (expr -> variable PLUS_EQ expr .)
    RPAREN          reduce using rule 126 (expr -> variable PLUS_EQ expr .)
    AS              reduce using rule 126 (expr -> variable PLUS_EQ expr .)
    DOUBLE_ARROW    reduce using rule 126 (expr -> variable PLUS_EQ expr .)
    RBRACE          reduce using rule 126 (expr -> variable PLUS_EQ expr .)
    RBRACKET        reduce using rule 126 (expr -> variable PLUS_EQ expr .)
    COLON           reduce using rule 126 (expr -> variable PLUS_EQ expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! OR_OP           [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! DOT             [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! PLUS            [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! MINUS           [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! MULT            [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! DIV             [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! MOD             [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! LESSER          [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! GREATER         [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! COND_OP         [ reduce using rule 126 (expr -> variable PLUS_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]


state 217

    (129) expr -> variable DIVIDE_EQ expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 129 (expr -> variable DIVIDE_EQ expr .)
    BIT_OR          reduce using rule 129 (expr -> variable DIVIDE_EQ expr .)
    BIT_XOR         reduce using rule 129 (expr -> variable DIVIDE_EQ expr .)
    BIT_AND         reduce using rule 129 (expr -> variable DIVIDE_EQ expr .)
    COMMA           reduce using rule 129 (expr -> variable DIVIDE_EQ expr .)
    RPAREN          reduce using rule 129 (expr -> variable DIVIDE_EQ expr .)
    AS              reduce using rule 129 (expr -> variable DIVIDE_EQ expr .)
    DOUBLE_ARROW    reduce using rule 129 (expr -> variable DIVIDE_EQ expr .)
    RBRACE          reduce using rule 129 (expr -> variable DIVIDE_EQ expr .)
    RBRACKET        reduce using rule 129 (expr -> variable DIVIDE_EQ expr .)
    COLON           reduce using rule 129 (expr -> variable DIVIDE_EQ expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! OR_OP           [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! DOT             [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! PLUS            [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! MINUS           [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! MULT            [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! DIV             [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! MOD             [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! LESSER          [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! GREATER         [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! COND_OP         [ reduce using rule 129 (expr -> variable DIVIDE_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]


state 218

    (127) expr -> variable MINUS_EQ expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 127 (expr -> variable MINUS_EQ expr .)
    BIT_OR          reduce using rule 127 (expr -> variable MINUS_EQ expr .)
    BIT_XOR         reduce using rule 127 (expr -> variable MINUS_EQ expr .)
    BIT_AND         reduce using rule 127 (expr -> variable MINUS_EQ expr .)
    COMMA           reduce using rule 127 (expr -> variable MINUS_EQ expr .)
    RPAREN          reduce using rule 127 (expr -> variable MINUS_EQ expr .)
    AS              reduce using rule 127 (expr -> variable MINUS_EQ expr .)
    DOUBLE_ARROW    reduce using rule 127 (expr -> variable MINUS_EQ expr .)
    RBRACE          reduce using rule 127 (expr -> variable MINUS_EQ expr .)
    RBRACKET        reduce using rule 127 (expr -> variable MINUS_EQ expr .)
    COLON           reduce using rule 127 (expr -> variable MINUS_EQ expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! OR_OP           [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! DOT             [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! PLUS            [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! MINUS           [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! MULT            [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! DIV             [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! MOD             [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! LESSER          [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! GREATER         [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! COND_OP         [ reduce using rule 127 (expr -> variable MINUS_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]


state 219

    (131) expr -> variable MOD_EQ expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 131 (expr -> variable MOD_EQ expr .)
    BIT_OR          reduce using rule 131 (expr -> variable MOD_EQ expr .)
    BIT_XOR         reduce using rule 131 (expr -> variable MOD_EQ expr .)
    BIT_AND         reduce using rule 131 (expr -> variable MOD_EQ expr .)
    COMMA           reduce using rule 131 (expr -> variable MOD_EQ expr .)
    RPAREN          reduce using rule 131 (expr -> variable MOD_EQ expr .)
    AS              reduce using rule 131 (expr -> variable MOD_EQ expr .)
    DOUBLE_ARROW    reduce using rule 131 (expr -> variable MOD_EQ expr .)
    RBRACE          reduce using rule 131 (expr -> variable MOD_EQ expr .)
    RBRACKET        reduce using rule 131 (expr -> variable MOD_EQ expr .)
    COLON           reduce using rule 131 (expr -> variable MOD_EQ expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! OR_OP           [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! DOT             [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! PLUS            [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! MINUS           [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! MULT            [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! DIV             [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! MOD             [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! LESSER          [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! GREATER         [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! COND_OP         [ reduce using rule 131 (expr -> variable MOD_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]


state 220

    (23) if_stmt_without_else -> IF LPAREN expr . RPAREN stmt
    (27) alt_if_stmt_without_else -> IF LPAREN expr . RPAREN COLON inner_stmts
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RPAREN          shift and go to state 266
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 221

    (26) alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts . ENDIF SEMICOLON
    (77) inner_stmts -> inner_stmts . inner_stmt
    (79) inner_stmt -> . stmt
    (80) inner_stmt -> . func_decl
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (11) func_decl -> . FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    ENDIF           shift and go to state 267
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    FUNCTION        shift and go to state 24
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    inner_stmt                     shift and go to state 162
    func_decl                      shift and go to state 161
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 160
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 222

    (28) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF LPAREN expr . RPAREN COLON inner_stmts
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RPAREN          shift and go to state 268
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 223

    (40) stmt -> FOREACH LPAREN expr AS . foreach_var foreach_arg RPAREN foreach_stmt
    (41) foreach_var -> . IDENTIFIER
    (42) foreach_var -> . BIT_AND IDENTIFIER

    IDENTIFIER      shift and go to state 271
    BIT_AND         shift and go to state 269


    foreach_var                    shift and go to state 270

state 224

    (170) expr -> EVAL LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    AND_OP          reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    OR_OP           reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_OR          reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_XOR         reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_AND         reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    DOT             reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    PLUS            reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    MINUS           reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    MULT            reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    DIV             reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_LSHIFT      reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_RSHIFT      reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    MOD             reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    IDENTICAL       reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    NOT_IDENTICAL   reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    EQ_EQ           reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    LESSER          reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    LESSER_EQ       reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    GREATER         reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    INSTANCEOF      reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    COND_OP         reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    COMMA           reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    RPAREN          reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    AS              reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    DOUBLE_ARROW    reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    RBRACE          reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)
    COLON           reduce using rule 170 (expr -> EVAL LPAREN expr RPAREN .)



state 225

    (7) const_decls -> const_decls COMMA const_decl .

    SEMICOLON       reduce using rule 7 (const_decls -> const_decls COMMA const_decl .)
    COMMA           reduce using rule 7 (const_decls -> const_decls COMMA const_decl .)



state 226

    (9) const_decl -> IDENTIFIER EQUAL expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 9 (const_decl -> IDENTIFIER EQUAL expr .)
    COMMA           reduce using rule 9 (const_decl -> IDENTIFIER EQUAL expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 227

    (67) static_var_list -> static_var_list COMMA static_var .

    SEMICOLON       reduce using rule 67 (static_var_list -> static_var_list COMMA static_var .)
    COMMA           reduce using rule 67 (static_var_list -> static_var_list COMMA static_var .)



state 228

    (101) scalar -> NULL .

    RPAREN          reduce using rule 101 (scalar -> NULL .)
    COMMA           reduce using rule 101 (scalar -> NULL .)
    DOUBLE_ARROW    reduce using rule 101 (scalar -> NULL .)
    SEMICOLON       reduce using rule 101 (scalar -> NULL .)



state 229

    (103) scalar -> FALSE .

    RPAREN          reduce using rule 103 (scalar -> FALSE .)
    COMMA           reduce using rule 103 (scalar -> FALSE .)
    DOUBLE_ARROW    reduce using rule 103 (scalar -> FALSE .)
    SEMICOLON       reduce using rule 103 (scalar -> FALSE .)



state 230

    (100) scalar -> CONST_STRING .

    RPAREN          reduce using rule 100 (scalar -> CONST_STRING .)
    COMMA           reduce using rule 100 (scalar -> CONST_STRING .)
    DOUBLE_ARROW    reduce using rule 100 (scalar -> CONST_STRING .)
    SEMICOLON       reduce using rule 100 (scalar -> CONST_STRING .)



state 231

    (98) scalar -> CONST_DECIMAL .

    RPAREN          reduce using rule 98 (scalar -> CONST_DECIMAL .)
    COMMA           reduce using rule 98 (scalar -> CONST_DECIMAL .)
    DOUBLE_ARROW    reduce using rule 98 (scalar -> CONST_DECIMAL .)
    SEMICOLON       reduce using rule 98 (scalar -> CONST_DECIMAL .)



state 232

    (99) scalar -> CONST_DOUBLE .

    RPAREN          reduce using rule 99 (scalar -> CONST_DOUBLE .)
    COMMA           reduce using rule 99 (scalar -> CONST_DOUBLE .)
    DOUBLE_ARROW    reduce using rule 99 (scalar -> CONST_DOUBLE .)
    SEMICOLON       reduce using rule 99 (scalar -> CONST_DOUBLE .)



state 233

    (69) static_var -> IDENTIFIER EQUAL scalar .

    SEMICOLON       reduce using rule 69 (static_var -> IDENTIFIER EQUAL scalar .)
    COMMA           reduce using rule 69 (static_var -> IDENTIFIER EQUAL scalar .)



state 234

    (104) scalar -> PLUS . scalar
    (98) scalar -> . CONST_DECIMAL
    (99) scalar -> . CONST_DOUBLE
    (100) scalar -> . CONST_STRING
    (101) scalar -> . NULL
    (102) scalar -> . TRUE
    (103) scalar -> . FALSE
    (104) scalar -> . PLUS scalar
    (105) scalar -> . MINUS scalar
    (106) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 231
    CONST_DOUBLE    shift and go to state 232
    CONST_STRING    shift and go to state 230
    NULL            shift and go to state 228
    TRUE            shift and go to state 236
    FALSE           shift and go to state 229
    PLUS            shift and go to state 234
    MINUS           shift and go to state 237
    ARRAY           shift and go to state 235


    scalar                         shift and go to state 272

state 235

    (106) scalar -> ARRAY . LPAREN scalar_array_pair_list RPAREN

    LPAREN          shift and go to state 273



state 236

    (102) scalar -> TRUE .

    RPAREN          reduce using rule 102 (scalar -> TRUE .)
    COMMA           reduce using rule 102 (scalar -> TRUE .)
    DOUBLE_ARROW    reduce using rule 102 (scalar -> TRUE .)
    SEMICOLON       reduce using rule 102 (scalar -> TRUE .)



state 237

    (105) scalar -> MINUS . scalar
    (98) scalar -> . CONST_DECIMAL
    (99) scalar -> . CONST_DOUBLE
    (100) scalar -> . CONST_STRING
    (101) scalar -> . NULL
    (102) scalar -> . TRUE
    (103) scalar -> . FALSE
    (104) scalar -> . PLUS scalar
    (105) scalar -> . MINUS scalar
    (106) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 231
    CONST_DOUBLE    shift and go to state 232
    CONST_STRING    shift and go to state 230
    NULL            shift and go to state 228
    TRUE            shift and go to state 236
    FALSE           shift and go to state 229
    PLUS            shift and go to state 234
    MINUS           shift and go to state 237
    ARRAY           shift and go to state 235


    scalar                         shift and go to state 274

state 238

    (169) expr -> EMPTY LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    AND_OP          reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    OR_OP           reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_OR          reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_XOR         reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_AND         reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    DOT             reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    PLUS            reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    MINUS           reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    MULT            reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    DIV             reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_LSHIFT      reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_RSHIFT      reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    MOD             reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    IDENTICAL       reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    NOT_IDENTICAL   reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    EQ_EQ           reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    LESSER          reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    LESSER_EQ       reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    GREATER         reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    INSTANCEOF      reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    COND_OP         reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    COMMA           reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    RPAREN          reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    AS              reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    DOUBLE_ARROW    reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    RBRACE          reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)
    COLON           reduce using rule 169 (expr -> EMPTY LPAREN expr RPAREN .)



state 239

    (16) param -> BIT_AND . IDENTIFIER
    (18) param -> BIT_AND . IDENTIFIER EQUAL scalar

    IDENTIFIER      shift and go to state 275



state 240

    (13) params -> param .

    RPAREN          reduce using rule 13 (params -> param .)
    COMMA           reduce using rule 13 (params -> param .)



state 241

    (15) param -> IDENTIFIER .
    (17) param -> IDENTIFIER . EQUAL scalar

    RPAREN          reduce using rule 15 (param -> IDENTIFIER .)
    COMMA           reduce using rule 15 (param -> IDENTIFIER .)
    EQUAL           shift and go to state 276



state 242

    (11) func_decl -> FUNCTION STRING LPAREN params . RPAREN LBRACE inner_stmts RBRACE
    (12) params -> params . COMMA param

    RPAREN          shift and go to state 277
    COMMA           shift and go to state 278



state 243

    (14) params -> empty .

    RPAREN          reduce using rule 14 (params -> empty .)
    COMMA           reduce using rule 14 (params -> empty .)



state 244

    (36) non_empty_for_expr -> non_empty_for_expr COMMA . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 279
    variable                       shift and go to state 53

state 245

    (33) stmt -> FOR LPAREN for_expr SEMICOLON . for_expr SEMICOLON for_expr RPAREN for_stmt
    (34) for_expr -> . empty
    (35) for_expr -> . non_empty_for_expr
    (180) empty -> .
    (36) non_empty_for_expr -> . non_empty_for_expr COMMA expr
    (37) non_empty_for_expr -> . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    SEMICOLON       reduce using rule 180 (empty -> .)
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    non_empty_for_expr             shift and go to state 153
    base_var                       shift and go to state 43
    expr                           shift and go to state 155
    for_expr                       shift and go to state 280
    variable                       shift and go to state 53
    empty                          shift and go to state 154

state 246

    (72) echo_expr_list -> echo_expr_list COMMA expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 72 (echo_expr_list -> echo_expr_list COMMA expr .)
    COMMA           reduce using rule 72 (echo_expr_list -> echo_expr_list COMMA expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 247

    (64) global_var_list -> global_var_list COMMA IDENTIFIER .

    SEMICOLON       reduce using rule 64 (global_var_list -> global_var_list COMMA IDENTIFIER .)
    COMMA           reduce using rule 64 (global_var_list -> global_var_list COMMA IDENTIFIER .)



state 248

    (29) stmt -> WHILE LPAREN expr RPAREN . while_stmt
    (30) while_stmt -> . stmt
    (31) while_stmt -> . COLON inner_stmts ENDWHILE SEMICOLON
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    COLON           shift and go to state 281
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 282
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45
    while_stmt                     shift and go to state 283

state 249

    (47) stmt -> SWITCH LPAREN expr RPAREN . switch_stmt
    (48) switch_stmt -> . LBRACE case_stmt RBRACE
    (49) switch_stmt -> . LBRACE SEMICOLON case_stmt RBRACE
    (50) switch_stmt -> . COLON case_stmt ENDSWITCH SEMICOLON
    (51) switch_stmt -> . COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON

    LBRACE          shift and go to state 284
    COLON           shift and go to state 285


    switch_stmt                    shift and go to state 286

state 250

    (115) array_pair_list -> non_empty_array_pair_list possible_comma .

    RPAREN          reduce using rule 115 (array_pair_list -> non_empty_array_pair_list possible_comma .)



state 251

    (118) non_empty_array_pair_list -> non_empty_array_pair_list COMMA . BIT_AND variable
    (119) non_empty_array_pair_list -> non_empty_array_pair_list COMMA . expr
    (122) non_empty_array_pair_list -> non_empty_array_pair_list COMMA . expr DOUBLE_ARROW BIT_AND variable
    (123) non_empty_array_pair_list -> non_empty_array_pair_list COMMA . expr DOUBLE_ARROW expr
    (117) possible_comma -> COMMA .
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    BIT_AND         shift and go to state 287
    RPAREN          reduce using rule 117 (possible_comma -> COMMA .)
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 288
    variable                       shift and go to state 53

state 252

    (116) possible_comma -> empty .

    RPAREN          reduce using rule 116 (possible_comma -> empty .)



state 253

    (120) non_empty_array_pair_list -> BIT_AND variable .

    COMMA           reduce using rule 120 (non_empty_array_pair_list -> BIT_AND variable .)
    RPAREN          reduce using rule 120 (non_empty_array_pair_list -> BIT_AND variable .)



state 254

    (113) expr -> ARRAY LPAREN array_pair_list RPAREN .

    SEMICOLON       reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    AND_OP          reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    OR_OP           reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_OR          reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_XOR         reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_AND         reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    DOT             reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    PLUS            reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    MINUS           reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    MULT            reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    DIV             reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_LSHIFT      reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_RSHIFT      reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    MOD             reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    IDENTICAL       reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    NOT_IDENTICAL   reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    EQ_EQ           reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    NOT_EQ          reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    LESSER          reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    LESSER_EQ       reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    GREATER         reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    GREATER_EQ      reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    INSTANCEOF      reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    COND_OP         reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    COMMA           reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    RPAREN          reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    AS              reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    DOUBLE_ARROW    reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    RBRACE          reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    RBRACKET        reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    COLON           reduce using rule 113 (expr -> ARRAY LPAREN array_pair_list RPAREN .)



state 255

    (124) non_empty_array_pair_list -> expr DOUBLE_ARROW . BIT_AND variable
    (125) non_empty_array_pair_list -> expr DOUBLE_ARROW . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    BIT_AND         shift and go to state 289
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 290
    variable                       shift and go to state 53

state 256

    (24) if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr . RPAREN stmt
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RPAREN          shift and go to state 291
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 257

    (91) base_var -> base_var LBRACE expr RBRACE .

    LBRACKET        reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    LBRACE          reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    EQUAL           reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    PLUS_EQ         reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    MINUS_EQ        reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    MULTIPLY_EQ     reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    DIVIDE_EQ       reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    DOT_EQ          reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    MOD_EQ          reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    INC             reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    DEC             reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    AND_OP          reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    OR_OP           reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    BIT_OR          reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    BIT_XOR         reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    BIT_AND         reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    DOT             reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    PLUS            reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    MINUS           reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    MULT            reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    DIV             reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    BIT_LSHIFT      reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    BIT_RSHIFT      reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    MOD             reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    IDENTICAL       reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    NOT_IDENTICAL   reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    EQ_EQ           reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    NOT_EQ          reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    LESSER          reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    LESSER_EQ       reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    GREATER         reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    GREATER_EQ      reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    INSTANCEOF      reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    COND_OP         reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    SEMICOLON       reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    COMMA           reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    RPAREN          reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    AS              reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    DOUBLE_ARROW    reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    RBRACE          reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    RBRACKET        reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)
    COLON           reduce using rule 91 (base_var -> base_var LBRACE expr RBRACE .)



state 258

    (90) base_var -> base_var LBRACKET dim_offset RBRACKET .

    LBRACKET        reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    LBRACE          reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    EQUAL           reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    PLUS_EQ         reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    MINUS_EQ        reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    MULTIPLY_EQ     reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    DIVIDE_EQ       reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    DOT_EQ          reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    MOD_EQ          reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    INC             reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    DEC             reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    AND_OP          reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    OR_OP           reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    BIT_OR          reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    BIT_XOR         reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    BIT_AND         reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    DOT             reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    PLUS            reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    MINUS           reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    MULT            reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    DIV             reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    BIT_LSHIFT      reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    BIT_RSHIFT      reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    MOD             reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    IDENTICAL       reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    NOT_IDENTICAL   reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    EQ_EQ           reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    NOT_EQ          reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    LESSER          reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    LESSER_EQ       reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    GREATER         reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    GREATER_EQ      reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    INSTANCEOF      reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    COND_OP         reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    SEMICOLON       reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    COMMA           reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    RPAREN          reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    AS              reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    DOUBLE_ARROW    reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    RBRACE          reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    RBRACKET        reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    COLON           reduce using rule 90 (base_var -> base_var LBRACKET dim_offset RBRACKET .)



state 259

    (164) expr -> expr COND_OP expr COLON . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 292
    variable                       shift and go to state 53

state 260

    (178) expr -> EXIT LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    AND_OP          reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    OR_OP           reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_OR          reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_XOR         reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_AND         reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    DOT             reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    PLUS            reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    MINUS           reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    MULT            reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    DIV             reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_LSHIFT      reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_RSHIFT      reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    MOD             reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    IDENTICAL       reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    NOT_IDENTICAL   reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    EQ_EQ           reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    LESSER          reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    LESSER_EQ       reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    GREATER         reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    INSTANCEOF      reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    COND_OP         reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    COMMA           reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    RPAREN          reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    AS              reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    DOUBLE_ARROW    reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    RBRACE          reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)
    COLON           reduce using rule 178 (expr -> EXIT LPAREN expr RPAREN .)



state 261

    (32) stmt -> DO stmt WHILE LPAREN . expr RPAREN SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 293
    variable                       shift and go to state 53

state 262

    (84) func_call -> STRING LPAREN func_params RPAREN .

    EQUAL           reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    PLUS_EQ         reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    MINUS_EQ        reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    MULTIPLY_EQ     reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    DIVIDE_EQ       reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    DOT_EQ          reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    MOD_EQ          reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    INC             reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    DEC             reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    AND_OP          reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    OR_OP           reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    BIT_OR          reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    BIT_XOR         reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    BIT_AND         reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    DOT             reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    PLUS            reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    MINUS           reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    MULT            reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    DIV             reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    BIT_LSHIFT      reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    BIT_RSHIFT      reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    MOD             reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    IDENTICAL       reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    NOT_IDENTICAL   reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    EQ_EQ           reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    NOT_EQ          reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    LESSER          reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    LESSER_EQ       reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    GREATER         reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    GREATER_EQ      reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    INSTANCEOF      reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    COND_OP         reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    SEMICOLON       reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    COMMA           reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    RPAREN          reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    AS              reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    DOUBLE_ARROW    reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    RBRACE          reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    RBRACKET        reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)
    COLON           reduce using rule 84 (func_call -> STRING LPAREN func_params RPAREN .)



state 263

    (85) func_params -> func_params COMMA . func_param
    (88) func_param -> . expr
    (89) func_param -> . BIT_AND variable
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    BIT_AND         shift and go to state 209
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    base_var                       shift and go to state 43
    func_param                     shift and go to state 294
    func_call                      shift and go to state 40
    expr                           shift and go to state 210
    variable                       shift and go to state 53

state 264

    (89) func_param -> BIT_AND variable .

    RPAREN          reduce using rule 89 (func_param -> BIT_AND variable .)
    COMMA           reduce using rule 89 (func_param -> BIT_AND variable .)



state 265

    (96) expr -> variable EQUAL BIT_AND expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .)
    BIT_OR          reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .)
    BIT_XOR         reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .)
    BIT_AND         reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .)
    COMMA           reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .)
    RPAREN          reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .)
    AS              reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .)
    DOUBLE_ARROW    reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .)
    RBRACE          reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .)
    RBRACKET        reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .)
    COLON           reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116

  ! AND_OP          [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! OR_OP           [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! DOT             [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! PLUS            [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! MINUS           [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! MULT            [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! DIV             [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! MOD             [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! IDENTICAL       [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! EQ_EQ           [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! NOT_EQ          [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! LESSER          [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! LESSER_EQ       [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! GREATER         [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! GREATER_EQ      [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! INSTANCEOF      [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! COND_OP         [ reduce using rule 96 (expr -> variable EQUAL BIT_AND expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]


state 266

    (23) if_stmt_without_else -> IF LPAREN expr RPAREN . stmt
    (27) alt_if_stmt_without_else -> IF LPAREN expr RPAREN . COLON inner_stmts
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    COLON           shift and go to state 295
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 296
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 267

    (26) alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF . SEMICOLON

    SEMICOLON       shift and go to state 297



state 268

    (28) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN . COLON inner_stmts

    COLON           shift and go to state 298



state 269

    (42) foreach_var -> BIT_AND . IDENTIFIER

    IDENTIFIER      shift and go to state 299



state 270

    (40) stmt -> FOREACH LPAREN expr AS foreach_var . foreach_arg RPAREN foreach_stmt
    (43) foreach_arg -> . empty
    (44) foreach_arg -> . DOUBLE_ARROW foreach_var
    (180) empty -> .

    DOUBLE_ARROW    shift and go to state 300
    RPAREN          reduce using rule 180 (empty -> .)


    foreach_arg                    shift and go to state 301
    empty                          shift and go to state 302

state 271

    (41) foreach_var -> IDENTIFIER .

    DOUBLE_ARROW    reduce using rule 41 (foreach_var -> IDENTIFIER .)
    RPAREN          reduce using rule 41 (foreach_var -> IDENTIFIER .)



state 272

    (104) scalar -> PLUS scalar .

    RPAREN          reduce using rule 104 (scalar -> PLUS scalar .)
    COMMA           reduce using rule 104 (scalar -> PLUS scalar .)
    DOUBLE_ARROW    reduce using rule 104 (scalar -> PLUS scalar .)
    SEMICOLON       reduce using rule 104 (scalar -> PLUS scalar .)



state 273

    (106) scalar -> ARRAY LPAREN . scalar_array_pair_list RPAREN
    (107) scalar_array_pair_list -> . empty
    (108) scalar_array_pair_list -> . scalar_non_empty_array_pair_list possible_comma
    (180) empty -> .
    (109) scalar_non_empty_array_pair_list -> . scalar_non_empty_array_pair_list COMMA scalar
    (110) scalar_non_empty_array_pair_list -> . scalar
    (111) scalar_non_empty_array_pair_list -> . scalar_non_empty_array_pair_list COMMA scalar DOUBLE_ARROW scalar
    (112) scalar_non_empty_array_pair_list -> . scalar DOUBLE_ARROW scalar
    (98) scalar -> . CONST_DECIMAL
    (99) scalar -> . CONST_DOUBLE
    (100) scalar -> . CONST_STRING
    (101) scalar -> . NULL
    (102) scalar -> . TRUE
    (103) scalar -> . FALSE
    (104) scalar -> . PLUS scalar
    (105) scalar -> . MINUS scalar
    (106) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    RPAREN          reduce using rule 180 (empty -> .)
    CONST_DECIMAL   shift and go to state 231
    CONST_DOUBLE    shift and go to state 232
    CONST_STRING    shift and go to state 230
    NULL            shift and go to state 228
    TRUE            shift and go to state 236
    FALSE           shift and go to state 229
    PLUS            shift and go to state 234
    MINUS           shift and go to state 237
    ARRAY           shift and go to state 235


    scalar                         shift and go to state 304
    scalar_non_empty_array_pair_list shift and go to state 303
    empty                          shift and go to state 306
    scalar_array_pair_list         shift and go to state 305

state 274

    (105) scalar -> MINUS scalar .

    RPAREN          reduce using rule 105 (scalar -> MINUS scalar .)
    COMMA           reduce using rule 105 (scalar -> MINUS scalar .)
    DOUBLE_ARROW    reduce using rule 105 (scalar -> MINUS scalar .)
    SEMICOLON       reduce using rule 105 (scalar -> MINUS scalar .)



state 275

    (16) param -> BIT_AND IDENTIFIER .
    (18) param -> BIT_AND IDENTIFIER . EQUAL scalar

    RPAREN          reduce using rule 16 (param -> BIT_AND IDENTIFIER .)
    COMMA           reduce using rule 16 (param -> BIT_AND IDENTIFIER .)
    EQUAL           shift and go to state 307



state 276

    (17) param -> IDENTIFIER EQUAL . scalar
    (98) scalar -> . CONST_DECIMAL
    (99) scalar -> . CONST_DOUBLE
    (100) scalar -> . CONST_STRING
    (101) scalar -> . NULL
    (102) scalar -> . TRUE
    (103) scalar -> . FALSE
    (104) scalar -> . PLUS scalar
    (105) scalar -> . MINUS scalar
    (106) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 231
    CONST_DOUBLE    shift and go to state 232
    CONST_STRING    shift and go to state 230
    NULL            shift and go to state 228
    TRUE            shift and go to state 236
    FALSE           shift and go to state 229
    PLUS            shift and go to state 234
    MINUS           shift and go to state 237
    ARRAY           shift and go to state 235


    scalar                         shift and go to state 308

state 277

    (11) func_decl -> FUNCTION STRING LPAREN params RPAREN . LBRACE inner_stmts RBRACE

    LBRACE          shift and go to state 309



state 278

    (12) params -> params COMMA . param
    (15) param -> . IDENTIFIER
    (16) param -> . BIT_AND IDENTIFIER
    (17) param -> . IDENTIFIER EQUAL scalar
    (18) param -> . BIT_AND IDENTIFIER EQUAL scalar

    IDENTIFIER      shift and go to state 241
    BIT_AND         shift and go to state 239


    param                          shift and go to state 310

state 279

    (36) non_empty_for_expr -> non_empty_for_expr COMMA expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    COMMA           reduce using rule 36 (non_empty_for_expr -> non_empty_for_expr COMMA expr .)
    RPAREN          reduce using rule 36 (non_empty_for_expr -> non_empty_for_expr COMMA expr .)
    SEMICOLON       reduce using rule 36 (non_empty_for_expr -> non_empty_for_expr COMMA expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 280

    (33) stmt -> FOR LPAREN for_expr SEMICOLON for_expr . SEMICOLON for_expr RPAREN for_stmt

    SEMICOLON       shift and go to state 311



state 281

    (31) while_stmt -> COLON . inner_stmts ENDWHILE SEMICOLON
    (77) inner_stmts -> . inner_stmts inner_stmt
    (78) inner_stmts -> . empty
    (180) empty -> .

    ENDWHILE        reduce using rule 180 (empty -> .)
    WHILE           reduce using rule 180 (empty -> .)
    DO              reduce using rule 180 (empty -> .)
    FOR             reduce using rule 180 (empty -> .)
    FOREACH         reduce using rule 180 (empty -> .)
    SWITCH          reduce using rule 180 (empty -> .)
    BREAK           reduce using rule 180 (empty -> .)
    CONTINUE        reduce using rule 180 (empty -> .)
    RETURN          reduce using rule 180 (empty -> .)
    GLOBAL          reduce using rule 180 (empty -> .)
    STATIC          reduce using rule 180 (empty -> .)
    ECHO            reduce using rule 180 (empty -> .)
    LBRACE          reduce using rule 180 (empty -> .)
    SEMICOLON       reduce using rule 180 (empty -> .)
    FUNCTION        reduce using rule 180 (empty -> .)
    CLONE           reduce using rule 180 (empty -> .)
    ARRAY           reduce using rule 180 (empty -> .)
    PLUS            reduce using rule 180 (empty -> .)
    MINUS           reduce using rule 180 (empty -> .)
    BIT_NOT         reduce using rule 180 (empty -> .)
    NOT             reduce using rule 180 (empty -> .)
    CONST_DECIMAL   reduce using rule 180 (empty -> .)
    CONST_DOUBLE    reduce using rule 180 (empty -> .)
    CONST_STRING    reduce using rule 180 (empty -> .)
    NULL            reduce using rule 180 (empty -> .)
    TRUE            reduce using rule 180 (empty -> .)
    FALSE           reduce using rule 180 (empty -> .)
    INC             reduce using rule 180 (empty -> .)
    DEC             reduce using rule 180 (empty -> .)
    EMPTY           reduce using rule 180 (empty -> .)
    EVAL            reduce using rule 180 (empty -> .)
    LPAREN          reduce using rule 180 (empty -> .)
    INCLUDE         reduce using rule 180 (empty -> .)
    INCLUDE_ONCE    reduce using rule 180 (empty -> .)
    REQUIRE         reduce using rule 180 (empty -> .)
    REQUIRE_ONCE    reduce using rule 180 (empty -> .)
    EXIT            reduce using rule 180 (empty -> .)
    PRINT           reduce using rule 180 (empty -> .)
    IF              reduce using rule 180 (empty -> .)
    IDENTIFIER      reduce using rule 180 (empty -> .)
    STRING          reduce using rule 180 (empty -> .)


    inner_stmts                    shift and go to state 312
    empty                          shift and go to state 84

state 282

    (30) while_stmt -> stmt .

    VAR             reduce using rule 30 (while_stmt -> stmt .)
    WHILE           reduce using rule 30 (while_stmt -> stmt .)
    DO              reduce using rule 30 (while_stmt -> stmt .)
    FOR             reduce using rule 30 (while_stmt -> stmt .)
    FOREACH         reduce using rule 30 (while_stmt -> stmt .)
    SWITCH          reduce using rule 30 (while_stmt -> stmt .)
    BREAK           reduce using rule 30 (while_stmt -> stmt .)
    CONTINUE        reduce using rule 30 (while_stmt -> stmt .)
    RETURN          reduce using rule 30 (while_stmt -> stmt .)
    GLOBAL          reduce using rule 30 (while_stmt -> stmt .)
    STATIC          reduce using rule 30 (while_stmt -> stmt .)
    ECHO            reduce using rule 30 (while_stmt -> stmt .)
    LBRACE          reduce using rule 30 (while_stmt -> stmt .)
    SEMICOLON       reduce using rule 30 (while_stmt -> stmt .)
    FUNCTION        reduce using rule 30 (while_stmt -> stmt .)
    CLONE           reduce using rule 30 (while_stmt -> stmt .)
    ARRAY           reduce using rule 30 (while_stmt -> stmt .)
    PLUS            reduce using rule 30 (while_stmt -> stmt .)
    MINUS           reduce using rule 30 (while_stmt -> stmt .)
    BIT_NOT         reduce using rule 30 (while_stmt -> stmt .)
    NOT             reduce using rule 30 (while_stmt -> stmt .)
    CONST_DECIMAL   reduce using rule 30 (while_stmt -> stmt .)
    CONST_DOUBLE    reduce using rule 30 (while_stmt -> stmt .)
    CONST_STRING    reduce using rule 30 (while_stmt -> stmt .)
    NULL            reduce using rule 30 (while_stmt -> stmt .)
    TRUE            reduce using rule 30 (while_stmt -> stmt .)
    FALSE           reduce using rule 30 (while_stmt -> stmt .)
    INC             reduce using rule 30 (while_stmt -> stmt .)
    DEC             reduce using rule 30 (while_stmt -> stmt .)
    EMPTY           reduce using rule 30 (while_stmt -> stmt .)
    EVAL            reduce using rule 30 (while_stmt -> stmt .)
    LPAREN          reduce using rule 30 (while_stmt -> stmt .)
    INCLUDE         reduce using rule 30 (while_stmt -> stmt .)
    INCLUDE_ONCE    reduce using rule 30 (while_stmt -> stmt .)
    REQUIRE         reduce using rule 30 (while_stmt -> stmt .)
    REQUIRE_ONCE    reduce using rule 30 (while_stmt -> stmt .)
    EXIT            reduce using rule 30 (while_stmt -> stmt .)
    PRINT           reduce using rule 30 (while_stmt -> stmt .)
    IF              reduce using rule 30 (while_stmt -> stmt .)
    IDENTIFIER      reduce using rule 30 (while_stmt -> stmt .)
    STRING          reduce using rule 30 (while_stmt -> stmt .)
    $end            reduce using rule 30 (while_stmt -> stmt .)
    RBRACE          reduce using rule 30 (while_stmt -> stmt .)
    ENDIF           reduce using rule 30 (while_stmt -> stmt .)
    ELSE            reduce using rule 30 (while_stmt -> stmt .)
    ELSEIF          reduce using rule 30 (while_stmt -> stmt .)
    ENDWHILE        reduce using rule 30 (while_stmt -> stmt .)
    ENDFOREACH      reduce using rule 30 (while_stmt -> stmt .)
    CASE            reduce using rule 30 (while_stmt -> stmt .)
    DEFAULT         reduce using rule 30 (while_stmt -> stmt .)
    ENDSWITCH       reduce using rule 30 (while_stmt -> stmt .)
    ENDFOR          reduce using rule 30 (while_stmt -> stmt .)



state 283

    (29) stmt -> WHILE LPAREN expr RPAREN while_stmt .

    WHILE           reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    DO              reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    FOR             reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    FOREACH         reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    SWITCH          reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    BREAK           reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    CONTINUE        reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    RETURN          reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    GLOBAL          reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    STATIC          reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    ECHO            reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    LBRACE          reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    SEMICOLON       reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    FUNCTION        reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    CLONE           reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    ARRAY           reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    PLUS            reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    MINUS           reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    BIT_NOT         reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    NOT             reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    CONST_DECIMAL   reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    CONST_DOUBLE    reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    CONST_STRING    reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    NULL            reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    TRUE            reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    FALSE           reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    INC             reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    DEC             reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    EMPTY           reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    EVAL            reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    LPAREN          reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    INCLUDE         reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    INCLUDE_ONCE    reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    REQUIRE         reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    REQUIRE_ONCE    reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    EXIT            reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    PRINT           reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    IF              reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    IDENTIFIER      reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    STRING          reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    ENDIF           reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    ELSE            reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    ELSEIF          reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    RBRACE          reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    VAR             reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    $end            reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    ENDWHILE        reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    ENDFOREACH      reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    CASE            reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    DEFAULT         reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    ENDSWITCH       reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)
    ENDFOR          reduce using rule 29 (stmt -> WHILE LPAREN expr RPAREN while_stmt .)



state 284

    (48) switch_stmt -> LBRACE . case_stmt RBRACE
    (49) switch_stmt -> LBRACE . SEMICOLON case_stmt RBRACE
    (52) case_stmt -> . empty
    (53) case_stmt -> . case_stmt CASE expr case_separator inner_stmts
    (54) case_stmt -> . case_stmt DEFAULT case_separator inner_stmts
    (180) empty -> .

    SEMICOLON       shift and go to state 314
    RBRACE          reduce using rule 180 (empty -> .)
    CASE            reduce using rule 180 (empty -> .)
    DEFAULT         reduce using rule 180 (empty -> .)


    case_stmt                      shift and go to state 313
    empty                          shift and go to state 315

state 285

    (50) switch_stmt -> COLON . case_stmt ENDSWITCH SEMICOLON
    (51) switch_stmt -> COLON . SEMICOLON case_stmt ENDSWITCH SEMICOLON
    (52) case_stmt -> . empty
    (53) case_stmt -> . case_stmt CASE expr case_separator inner_stmts
    (54) case_stmt -> . case_stmt DEFAULT case_separator inner_stmts
    (180) empty -> .

    SEMICOLON       shift and go to state 317
    ENDSWITCH       reduce using rule 180 (empty -> .)
    CASE            reduce using rule 180 (empty -> .)
    DEFAULT         reduce using rule 180 (empty -> .)


    case_stmt                      shift and go to state 316
    empty                          shift and go to state 315

state 286

    (47) stmt -> SWITCH LPAREN expr RPAREN switch_stmt .

    WHILE           reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    DO              reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    FOR             reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    FOREACH         reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    SWITCH          reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    BREAK           reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    CONTINUE        reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    RETURN          reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    GLOBAL          reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    STATIC          reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    ECHO            reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    LBRACE          reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    SEMICOLON       reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    FUNCTION        reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    CLONE           reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    ARRAY           reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    PLUS            reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    MINUS           reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    BIT_NOT         reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    NOT             reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    CONST_DECIMAL   reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    CONST_DOUBLE    reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    CONST_STRING    reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    NULL            reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    TRUE            reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    FALSE           reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    INC             reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    DEC             reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    EMPTY           reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    EVAL            reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    LPAREN          reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    INCLUDE         reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    INCLUDE_ONCE    reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    REQUIRE         reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    REQUIRE_ONCE    reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    EXIT            reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    PRINT           reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    IF              reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    IDENTIFIER      reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    STRING          reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    ENDIF           reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    ELSE            reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    ELSEIF          reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    RBRACE          reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    VAR             reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    $end            reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    ENDWHILE        reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    ENDFOREACH      reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    CASE            reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    DEFAULT         reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    ENDSWITCH       reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)
    ENDFOR          reduce using rule 47 (stmt -> SWITCH LPAREN expr RPAREN switch_stmt .)



state 287

    (118) non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND . variable
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    variable                       shift and go to state 318

state 288

    (119) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr .
    (122) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr . DOUBLE_ARROW BIT_AND variable
    (123) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr . DOUBLE_ARROW expr
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    COMMA           reduce using rule 119 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr .)
    RPAREN          reduce using rule 119 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr .)
    DOUBLE_ARROW    shift and go to state 319
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 289

    (124) non_empty_array_pair_list -> expr DOUBLE_ARROW BIT_AND . variable
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    variable                       shift and go to state 320

state 290

    (125) non_empty_array_pair_list -> expr DOUBLE_ARROW expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    COMMA           reduce using rule 125 (non_empty_array_pair_list -> expr DOUBLE_ARROW expr .)
    RPAREN          reduce using rule 125 (non_empty_array_pair_list -> expr DOUBLE_ARROW expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 291

    (24) if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN . stmt
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 321
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 292

    (164) expr -> expr COND_OP expr COLON expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    SEMICOLON       reduce using rule 164 (expr -> expr COND_OP expr COLON expr .)
    BIT_OR          reduce using rule 164 (expr -> expr COND_OP expr COLON expr .)
    BIT_XOR         reduce using rule 164 (expr -> expr COND_OP expr COLON expr .)
    BIT_AND         reduce using rule 164 (expr -> expr COND_OP expr COLON expr .)
    COND_OP         reduce using rule 164 (expr -> expr COND_OP expr COLON expr .)
    COMMA           reduce using rule 164 (expr -> expr COND_OP expr COLON expr .)
    RPAREN          reduce using rule 164 (expr -> expr COND_OP expr COLON expr .)
    AS              reduce using rule 164 (expr -> expr COND_OP expr COLON expr .)
    DOUBLE_ARROW    reduce using rule 164 (expr -> expr COND_OP expr COLON expr .)
    RBRACE          reduce using rule 164 (expr -> expr COND_OP expr COLON expr .)
    RBRACKET        reduce using rule 164 (expr -> expr COND_OP expr COLON expr .)
    COLON           reduce using rule 164 (expr -> expr COND_OP expr COLON expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114

  ! AND_OP          [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! OR_OP           [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! DOT             [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! PLUS            [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! MINUS           [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! MULT            [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! DIV             [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! MOD             [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! IDENTICAL       [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! EQ_EQ           [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! NOT_EQ          [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! LESSER          [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! LESSER_EQ       [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! GREATER         [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! GREATER_EQ      [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! INSTANCEOF      [ reduce using rule 164 (expr -> expr COND_OP expr COLON expr .) ]
  ! BIT_OR          [ shift and go to state 118 ]
  ! BIT_XOR         [ shift and go to state 101 ]
  ! BIT_AND         [ shift and go to state 111 ]
  ! COND_OP         [ shift and go to state 116 ]


state 293

    (32) stmt -> DO stmt WHILE LPAREN expr . RPAREN SEMICOLON
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    RPAREN          shift and go to state 322
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 294

    (85) func_params -> func_params COMMA func_param .

    RPAREN          reduce using rule 85 (func_params -> func_params COMMA func_param .)
    COMMA           reduce using rule 85 (func_params -> func_params COMMA func_param .)



state 295

    (27) alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON . inner_stmts
    (77) inner_stmts -> . inner_stmts inner_stmt
    (78) inner_stmts -> . empty
    (180) empty -> .

    WHILE           reduce using rule 180 (empty -> .)
    DO              reduce using rule 180 (empty -> .)
    FOR             reduce using rule 180 (empty -> .)
    FOREACH         reduce using rule 180 (empty -> .)
    SWITCH          reduce using rule 180 (empty -> .)
    BREAK           reduce using rule 180 (empty -> .)
    CONTINUE        reduce using rule 180 (empty -> .)
    RETURN          reduce using rule 180 (empty -> .)
    GLOBAL          reduce using rule 180 (empty -> .)
    STATIC          reduce using rule 180 (empty -> .)
    ECHO            reduce using rule 180 (empty -> .)
    LBRACE          reduce using rule 180 (empty -> .)
    SEMICOLON       reduce using rule 180 (empty -> .)
    FUNCTION        reduce using rule 180 (empty -> .)
    CLONE           reduce using rule 180 (empty -> .)
    ARRAY           reduce using rule 180 (empty -> .)
    PLUS            reduce using rule 180 (empty -> .)
    MINUS           reduce using rule 180 (empty -> .)
    BIT_NOT         reduce using rule 180 (empty -> .)
    NOT             reduce using rule 180 (empty -> .)
    CONST_DECIMAL   reduce using rule 180 (empty -> .)
    CONST_DOUBLE    reduce using rule 180 (empty -> .)
    CONST_STRING    reduce using rule 180 (empty -> .)
    NULL            reduce using rule 180 (empty -> .)
    TRUE            reduce using rule 180 (empty -> .)
    FALSE           reduce using rule 180 (empty -> .)
    INC             reduce using rule 180 (empty -> .)
    DEC             reduce using rule 180 (empty -> .)
    EMPTY           reduce using rule 180 (empty -> .)
    EVAL            reduce using rule 180 (empty -> .)
    LPAREN          reduce using rule 180 (empty -> .)
    INCLUDE         reduce using rule 180 (empty -> .)
    INCLUDE_ONCE    reduce using rule 180 (empty -> .)
    REQUIRE         reduce using rule 180 (empty -> .)
    REQUIRE_ONCE    reduce using rule 180 (empty -> .)
    EXIT            reduce using rule 180 (empty -> .)
    PRINT           reduce using rule 180 (empty -> .)
    IF              reduce using rule 180 (empty -> .)
    IDENTIFIER      reduce using rule 180 (empty -> .)
    STRING          reduce using rule 180 (empty -> .)
    ENDIF           reduce using rule 180 (empty -> .)
    ELSE            reduce using rule 180 (empty -> .)
    ELSEIF          reduce using rule 180 (empty -> .)


    inner_stmts                    shift and go to state 323
    empty                          shift and go to state 84

state 296

    (23) if_stmt_without_else -> IF LPAREN expr RPAREN stmt .

    VAR             reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    DO              reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    FOREACH         reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    SWITCH          reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    GLOBAL          reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    STATIC          reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    ECHO            reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    FUNCTION        reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    CLONE           reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    ARRAY           reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    PLUS            reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    MINUS           reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    BIT_NOT         reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    NOT             reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    CONST_DECIMAL   reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    CONST_DOUBLE    reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    CONST_STRING    reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    INC             reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    DEC             reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    EMPTY           reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    EVAL            reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    INCLUDE         reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    INCLUDE_ONCE    reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    REQUIRE         reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    REQUIRE_ONCE    reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    EXIT            reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    PRINT           reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    IF              reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    STRING          reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    $end            reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    ENDIF           reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    ELSEIF          reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    ENDWHILE        reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    ENDFOREACH      reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    CASE            reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    DEFAULT         reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    ENDSWITCH       reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)
    ENDFOR          reduce using rule 23 (if_stmt_without_else -> IF LPAREN expr RPAREN stmt .)



state 297

    (26) alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .

    VAR             reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    WHILE           reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    DO              reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    FOR             reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    FOREACH         reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    SWITCH          reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    BREAK           reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    CONTINUE        reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    RETURN          reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    GLOBAL          reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    STATIC          reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    ECHO            reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    LBRACE          reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    SEMICOLON       reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    FUNCTION        reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    CLONE           reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    ARRAY           reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    PLUS            reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    MINUS           reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    BIT_NOT         reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    NOT             reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    CONST_DECIMAL   reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    CONST_DOUBLE    reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    CONST_STRING    reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    NULL            reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    TRUE            reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    FALSE           reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    INC             reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    DEC             reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    EMPTY           reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    EVAL            reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    LPAREN          reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    INCLUDE         reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    REQUIRE         reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    EXIT            reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    PRINT           reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    IF              reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    IDENTIFIER      reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    STRING          reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    $end            reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    RBRACE          reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    ENDIF           reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    ELSE            reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    ELSEIF          reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    ENDWHILE        reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    ENDFOREACH      reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    CASE            reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    DEFAULT         reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    ENDSWITCH       reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)
    ENDFOR          reduce using rule 26 (alt_if_stmt -> alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON .)



state 298

    (28) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON . inner_stmts
    (77) inner_stmts -> . inner_stmts inner_stmt
    (78) inner_stmts -> . empty
    (180) empty -> .

    WHILE           reduce using rule 180 (empty -> .)
    DO              reduce using rule 180 (empty -> .)
    FOR             reduce using rule 180 (empty -> .)
    FOREACH         reduce using rule 180 (empty -> .)
    SWITCH          reduce using rule 180 (empty -> .)
    BREAK           reduce using rule 180 (empty -> .)
    CONTINUE        reduce using rule 180 (empty -> .)
    RETURN          reduce using rule 180 (empty -> .)
    GLOBAL          reduce using rule 180 (empty -> .)
    STATIC          reduce using rule 180 (empty -> .)
    ECHO            reduce using rule 180 (empty -> .)
    LBRACE          reduce using rule 180 (empty -> .)
    SEMICOLON       reduce using rule 180 (empty -> .)
    FUNCTION        reduce using rule 180 (empty -> .)
    CLONE           reduce using rule 180 (empty -> .)
    ARRAY           reduce using rule 180 (empty -> .)
    PLUS            reduce using rule 180 (empty -> .)
    MINUS           reduce using rule 180 (empty -> .)
    BIT_NOT         reduce using rule 180 (empty -> .)
    NOT             reduce using rule 180 (empty -> .)
    CONST_DECIMAL   reduce using rule 180 (empty -> .)
    CONST_DOUBLE    reduce using rule 180 (empty -> .)
    CONST_STRING    reduce using rule 180 (empty -> .)
    NULL            reduce using rule 180 (empty -> .)
    TRUE            reduce using rule 180 (empty -> .)
    FALSE           reduce using rule 180 (empty -> .)
    INC             reduce using rule 180 (empty -> .)
    DEC             reduce using rule 180 (empty -> .)
    EMPTY           reduce using rule 180 (empty -> .)
    EVAL            reduce using rule 180 (empty -> .)
    LPAREN          reduce using rule 180 (empty -> .)
    INCLUDE         reduce using rule 180 (empty -> .)
    INCLUDE_ONCE    reduce using rule 180 (empty -> .)
    REQUIRE         reduce using rule 180 (empty -> .)
    REQUIRE_ONCE    reduce using rule 180 (empty -> .)
    EXIT            reduce using rule 180 (empty -> .)
    PRINT           reduce using rule 180 (empty -> .)
    IF              reduce using rule 180 (empty -> .)
    IDENTIFIER      reduce using rule 180 (empty -> .)
    STRING          reduce using rule 180 (empty -> .)
    ENDIF           reduce using rule 180 (empty -> .)
    ELSE            reduce using rule 180 (empty -> .)
    ELSEIF          reduce using rule 180 (empty -> .)


    inner_stmts                    shift and go to state 324
    empty                          shift and go to state 84

state 299

    (42) foreach_var -> BIT_AND IDENTIFIER .

    DOUBLE_ARROW    reduce using rule 42 (foreach_var -> BIT_AND IDENTIFIER .)
    RPAREN          reduce using rule 42 (foreach_var -> BIT_AND IDENTIFIER .)



state 300

    (44) foreach_arg -> DOUBLE_ARROW . foreach_var
    (41) foreach_var -> . IDENTIFIER
    (42) foreach_var -> . BIT_AND IDENTIFIER

    IDENTIFIER      shift and go to state 271
    BIT_AND         shift and go to state 269


    foreach_var                    shift and go to state 325

state 301

    (40) stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg . RPAREN foreach_stmt

    RPAREN          shift and go to state 326



state 302

    (43) foreach_arg -> empty .

    RPAREN          reduce using rule 43 (foreach_arg -> empty .)



state 303

    (108) scalar_array_pair_list -> scalar_non_empty_array_pair_list . possible_comma
    (109) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list . COMMA scalar
    (111) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list . COMMA scalar DOUBLE_ARROW scalar
    (116) possible_comma -> . empty
    (117) possible_comma -> . COMMA
    (180) empty -> .

    COMMA           shift and go to state 328
    RPAREN          reduce using rule 180 (empty -> .)


    empty                          shift and go to state 252
    possible_comma                 shift and go to state 327

state 304

    (110) scalar_non_empty_array_pair_list -> scalar .
    (112) scalar_non_empty_array_pair_list -> scalar . DOUBLE_ARROW scalar

    COMMA           reduce using rule 110 (scalar_non_empty_array_pair_list -> scalar .)
    RPAREN          reduce using rule 110 (scalar_non_empty_array_pair_list -> scalar .)
    DOUBLE_ARROW    shift and go to state 329



state 305

    (106) scalar -> ARRAY LPAREN scalar_array_pair_list . RPAREN

    RPAREN          shift and go to state 330



state 306

    (107) scalar_array_pair_list -> empty .

    RPAREN          reduce using rule 107 (scalar_array_pair_list -> empty .)



state 307

    (18) param -> BIT_AND IDENTIFIER EQUAL . scalar
    (98) scalar -> . CONST_DECIMAL
    (99) scalar -> . CONST_DOUBLE
    (100) scalar -> . CONST_STRING
    (101) scalar -> . NULL
    (102) scalar -> . TRUE
    (103) scalar -> . FALSE
    (104) scalar -> . PLUS scalar
    (105) scalar -> . MINUS scalar
    (106) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 231
    CONST_DOUBLE    shift and go to state 232
    CONST_STRING    shift and go to state 230
    NULL            shift and go to state 228
    TRUE            shift and go to state 236
    FALSE           shift and go to state 229
    PLUS            shift and go to state 234
    MINUS           shift and go to state 237
    ARRAY           shift and go to state 235


    scalar                         shift and go to state 331

state 308

    (17) param -> IDENTIFIER EQUAL scalar .

    RPAREN          reduce using rule 17 (param -> IDENTIFIER EQUAL scalar .)
    COMMA           reduce using rule 17 (param -> IDENTIFIER EQUAL scalar .)



state 309

    (11) func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE . inner_stmts RBRACE
    (77) inner_stmts -> . inner_stmts inner_stmt
    (78) inner_stmts -> . empty
    (180) empty -> .

    RBRACE          reduce using rule 180 (empty -> .)
    WHILE           reduce using rule 180 (empty -> .)
    DO              reduce using rule 180 (empty -> .)
    FOR             reduce using rule 180 (empty -> .)
    FOREACH         reduce using rule 180 (empty -> .)
    SWITCH          reduce using rule 180 (empty -> .)
    BREAK           reduce using rule 180 (empty -> .)
    CONTINUE        reduce using rule 180 (empty -> .)
    RETURN          reduce using rule 180 (empty -> .)
    GLOBAL          reduce using rule 180 (empty -> .)
    STATIC          reduce using rule 180 (empty -> .)
    ECHO            reduce using rule 180 (empty -> .)
    LBRACE          reduce using rule 180 (empty -> .)
    SEMICOLON       reduce using rule 180 (empty -> .)
    FUNCTION        reduce using rule 180 (empty -> .)
    CLONE           reduce using rule 180 (empty -> .)
    ARRAY           reduce using rule 180 (empty -> .)
    PLUS            reduce using rule 180 (empty -> .)
    MINUS           reduce using rule 180 (empty -> .)
    BIT_NOT         reduce using rule 180 (empty -> .)
    NOT             reduce using rule 180 (empty -> .)
    CONST_DECIMAL   reduce using rule 180 (empty -> .)
    CONST_DOUBLE    reduce using rule 180 (empty -> .)
    CONST_STRING    reduce using rule 180 (empty -> .)
    NULL            reduce using rule 180 (empty -> .)
    TRUE            reduce using rule 180 (empty -> .)
    FALSE           reduce using rule 180 (empty -> .)
    INC             reduce using rule 180 (empty -> .)
    DEC             reduce using rule 180 (empty -> .)
    EMPTY           reduce using rule 180 (empty -> .)
    EVAL            reduce using rule 180 (empty -> .)
    LPAREN          reduce using rule 180 (empty -> .)
    INCLUDE         reduce using rule 180 (empty -> .)
    INCLUDE_ONCE    reduce using rule 180 (empty -> .)
    REQUIRE         reduce using rule 180 (empty -> .)
    REQUIRE_ONCE    reduce using rule 180 (empty -> .)
    EXIT            reduce using rule 180 (empty -> .)
    PRINT           reduce using rule 180 (empty -> .)
    IF              reduce using rule 180 (empty -> .)
    IDENTIFIER      reduce using rule 180 (empty -> .)
    STRING          reduce using rule 180 (empty -> .)


    inner_stmts                    shift and go to state 332
    empty                          shift and go to state 84

state 310

    (12) params -> params COMMA param .

    RPAREN          reduce using rule 12 (params -> params COMMA param .)
    COMMA           reduce using rule 12 (params -> params COMMA param .)



state 311

    (33) stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON . for_expr RPAREN for_stmt
    (34) for_expr -> . empty
    (35) for_expr -> . non_empty_for_expr
    (180) empty -> .
    (36) non_empty_for_expr -> . non_empty_for_expr COMMA expr
    (37) non_empty_for_expr -> . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    RPAREN          reduce using rule 180 (empty -> .)
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    non_empty_for_expr             shift and go to state 153
    base_var                       shift and go to state 43
    expr                           shift and go to state 155
    for_expr                       shift and go to state 333
    variable                       shift and go to state 53
    empty                          shift and go to state 154

state 312

    (31) while_stmt -> COLON inner_stmts . ENDWHILE SEMICOLON
    (77) inner_stmts -> inner_stmts . inner_stmt
    (79) inner_stmt -> . stmt
    (80) inner_stmt -> . func_decl
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (11) func_decl -> . FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    ENDWHILE        shift and go to state 334
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    FUNCTION        shift and go to state 24
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    inner_stmt                     shift and go to state 162
    func_decl                      shift and go to state 161
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 160
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 313

    (48) switch_stmt -> LBRACE case_stmt . RBRACE
    (53) case_stmt -> case_stmt . CASE expr case_separator inner_stmts
    (54) case_stmt -> case_stmt . DEFAULT case_separator inner_stmts

    RBRACE          shift and go to state 336
    CASE            shift and go to state 335
    DEFAULT         shift and go to state 337



state 314

    (49) switch_stmt -> LBRACE SEMICOLON . case_stmt RBRACE
    (52) case_stmt -> . empty
    (53) case_stmt -> . case_stmt CASE expr case_separator inner_stmts
    (54) case_stmt -> . case_stmt DEFAULT case_separator inner_stmts
    (180) empty -> .

    RBRACE          reduce using rule 180 (empty -> .)
    CASE            reduce using rule 180 (empty -> .)
    DEFAULT         reduce using rule 180 (empty -> .)


    case_stmt                      shift and go to state 338
    empty                          shift and go to state 315

state 315

    (52) case_stmt -> empty .

    RBRACE          reduce using rule 52 (case_stmt -> empty .)
    CASE            reduce using rule 52 (case_stmt -> empty .)
    DEFAULT         reduce using rule 52 (case_stmt -> empty .)
    ENDSWITCH       reduce using rule 52 (case_stmt -> empty .)



state 316

    (50) switch_stmt -> COLON case_stmt . ENDSWITCH SEMICOLON
    (53) case_stmt -> case_stmt . CASE expr case_separator inner_stmts
    (54) case_stmt -> case_stmt . DEFAULT case_separator inner_stmts

    ENDSWITCH       shift and go to state 339
    CASE            shift and go to state 335
    DEFAULT         shift and go to state 337



state 317

    (51) switch_stmt -> COLON SEMICOLON . case_stmt ENDSWITCH SEMICOLON
    (52) case_stmt -> . empty
    (53) case_stmt -> . case_stmt CASE expr case_separator inner_stmts
    (54) case_stmt -> . case_stmt DEFAULT case_separator inner_stmts
    (180) empty -> .

    ENDSWITCH       reduce using rule 180 (empty -> .)
    CASE            reduce using rule 180 (empty -> .)
    DEFAULT         reduce using rule 180 (empty -> .)


    case_stmt                      shift and go to state 340
    empty                          shift and go to state 315

state 318

    (118) non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND variable .

    COMMA           reduce using rule 118 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND variable .)
    RPAREN          reduce using rule 118 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND variable .)



state 319

    (122) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW . BIT_AND variable
    (123) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW . expr
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    BIT_AND         shift and go to state 341
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 342
    variable                       shift and go to state 53

state 320

    (124) non_empty_array_pair_list -> expr DOUBLE_ARROW BIT_AND variable .

    COMMA           reduce using rule 124 (non_empty_array_pair_list -> expr DOUBLE_ARROW BIT_AND variable .)
    RPAREN          reduce using rule 124 (non_empty_array_pair_list -> expr DOUBLE_ARROW BIT_AND variable .)



state 321

    (24) if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .

    VAR             reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    DO              reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    FOREACH         reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    SWITCH          reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    GLOBAL          reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    STATIC          reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    ECHO            reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    FUNCTION        reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    CLONE           reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    ARRAY           reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    PLUS            reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    MINUS           reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    BIT_NOT         reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    NOT             reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    CONST_DECIMAL   reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    CONST_DOUBLE    reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    CONST_STRING    reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    INC             reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    DEC             reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    EMPTY           reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    EVAL            reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    INCLUDE         reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    INCLUDE_ONCE    reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    REQUIRE         reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    REQUIRE_ONCE    reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    EXIT            reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    PRINT           reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    IF              reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    IDENTIFIER      reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    STRING          reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    $end            reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    ENDIF           reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    ELSEIF          reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    ENDWHILE        reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    ENDFOREACH      reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    CASE            reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    DEFAULT         reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    ENDSWITCH       reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)
    ENDFOR          reduce using rule 24 (if_stmt_without_else -> if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt .)



state 322

    (32) stmt -> DO stmt WHILE LPAREN expr RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 343



state 323

    (27) alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON inner_stmts .
    (77) inner_stmts -> inner_stmts . inner_stmt
    (79) inner_stmt -> . stmt
    (80) inner_stmt -> . func_decl
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (11) func_decl -> . FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    ENDIF           reduce using rule 27 (alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON inner_stmts .)
    ELSE            reduce using rule 27 (alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON inner_stmts .)
    ELSEIF          reduce using rule 27 (alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON inner_stmts .)
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    FUNCTION        shift and go to state 24
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    inner_stmt                     shift and go to state 162
    func_decl                      shift and go to state 161
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 160
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 324

    (28) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts .
    (77) inner_stmts -> inner_stmts . inner_stmt
    (79) inner_stmt -> . stmt
    (80) inner_stmt -> . func_decl
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (11) func_decl -> . FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    ENDIF           reduce using rule 28 (alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts .)
    ELSE            reduce using rule 28 (alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts .)
    ELSEIF          reduce using rule 28 (alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts .)
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    FUNCTION        shift and go to state 24
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    inner_stmt                     shift and go to state 162
    func_decl                      shift and go to state 161
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 160
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 325

    (44) foreach_arg -> DOUBLE_ARROW foreach_var .

    RPAREN          reduce using rule 44 (foreach_arg -> DOUBLE_ARROW foreach_var .)



state 326

    (40) stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN . foreach_stmt
    (45) foreach_stmt -> . stmt
    (46) foreach_stmt -> . COLON inner_stmts ENDFOREACH SEMICOLON
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    COLON           shift and go to state 345
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    foreach_stmt                   shift and go to state 344
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 346
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 327

    (108) scalar_array_pair_list -> scalar_non_empty_array_pair_list possible_comma .

    RPAREN          reduce using rule 108 (scalar_array_pair_list -> scalar_non_empty_array_pair_list possible_comma .)



state 328

    (109) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA . scalar
    (111) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA . scalar DOUBLE_ARROW scalar
    (117) possible_comma -> COMMA .
    (98) scalar -> . CONST_DECIMAL
    (99) scalar -> . CONST_DOUBLE
    (100) scalar -> . CONST_STRING
    (101) scalar -> . NULL
    (102) scalar -> . TRUE
    (103) scalar -> . FALSE
    (104) scalar -> . PLUS scalar
    (105) scalar -> . MINUS scalar
    (106) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    RPAREN          reduce using rule 117 (possible_comma -> COMMA .)
    CONST_DECIMAL   shift and go to state 231
    CONST_DOUBLE    shift and go to state 232
    CONST_STRING    shift and go to state 230
    NULL            shift and go to state 228
    TRUE            shift and go to state 236
    FALSE           shift and go to state 229
    PLUS            shift and go to state 234
    MINUS           shift and go to state 237
    ARRAY           shift and go to state 235


    scalar                         shift and go to state 347

state 329

    (112) scalar_non_empty_array_pair_list -> scalar DOUBLE_ARROW . scalar
    (98) scalar -> . CONST_DECIMAL
    (99) scalar -> . CONST_DOUBLE
    (100) scalar -> . CONST_STRING
    (101) scalar -> . NULL
    (102) scalar -> . TRUE
    (103) scalar -> . FALSE
    (104) scalar -> . PLUS scalar
    (105) scalar -> . MINUS scalar
    (106) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 231
    CONST_DOUBLE    shift and go to state 232
    CONST_STRING    shift and go to state 230
    NULL            shift and go to state 228
    TRUE            shift and go to state 236
    FALSE           shift and go to state 229
    PLUS            shift and go to state 234
    MINUS           shift and go to state 237
    ARRAY           shift and go to state 235


    scalar                         shift and go to state 348

state 330

    (106) scalar -> ARRAY LPAREN scalar_array_pair_list RPAREN .

    RPAREN          reduce using rule 106 (scalar -> ARRAY LPAREN scalar_array_pair_list RPAREN .)
    COMMA           reduce using rule 106 (scalar -> ARRAY LPAREN scalar_array_pair_list RPAREN .)
    DOUBLE_ARROW    reduce using rule 106 (scalar -> ARRAY LPAREN scalar_array_pair_list RPAREN .)
    SEMICOLON       reduce using rule 106 (scalar -> ARRAY LPAREN scalar_array_pair_list RPAREN .)



state 331

    (18) param -> BIT_AND IDENTIFIER EQUAL scalar .

    RPAREN          reduce using rule 18 (param -> BIT_AND IDENTIFIER EQUAL scalar .)
    COMMA           reduce using rule 18 (param -> BIT_AND IDENTIFIER EQUAL scalar .)



state 332

    (11) func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts . RBRACE
    (77) inner_stmts -> inner_stmts . inner_stmt
    (79) inner_stmt -> . stmt
    (80) inner_stmt -> . func_decl
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (11) func_decl -> . FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    RBRACE          shift and go to state 349
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    FUNCTION        shift and go to state 24
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    inner_stmt                     shift and go to state 162
    func_decl                      shift and go to state 161
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 160
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 333

    (33) stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr . RPAREN for_stmt

    RPAREN          shift and go to state 350



state 334

    (31) while_stmt -> COLON inner_stmts ENDWHILE . SEMICOLON

    SEMICOLON       shift and go to state 351



state 335

    (53) case_stmt -> case_stmt CASE . expr case_separator inner_stmts
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 352
    variable                       shift and go to state 53

state 336

    (48) switch_stmt -> LBRACE case_stmt RBRACE .

    VAR             reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    WHILE           reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    DO              reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    FOR             reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    FOREACH         reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    SWITCH          reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    BREAK           reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    CONTINUE        reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    RETURN          reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    GLOBAL          reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    STATIC          reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ECHO            reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    LBRACE          reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    SEMICOLON       reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    FUNCTION        reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    CLONE           reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ARRAY           reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    PLUS            reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    MINUS           reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    BIT_NOT         reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    NOT             reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    CONST_DECIMAL   reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    CONST_DOUBLE    reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    CONST_STRING    reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    NULL            reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    TRUE            reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    FALSE           reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    INC             reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    DEC             reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    EMPTY           reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    EVAL            reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    LPAREN          reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    INCLUDE         reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    INCLUDE_ONCE    reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    REQUIRE         reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    REQUIRE_ONCE    reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    EXIT            reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    PRINT           reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    IF              reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    IDENTIFIER      reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    STRING          reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    $end            reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    RBRACE          reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ENDIF           reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ELSE            reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ELSEIF          reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ENDWHILE        reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ENDFOREACH      reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    CASE            reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    DEFAULT         reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ENDSWITCH       reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ENDFOR          reduce using rule 48 (switch_stmt -> LBRACE case_stmt RBRACE .)



state 337

    (54) case_stmt -> case_stmt DEFAULT . case_separator inner_stmts
    (55) case_separator -> . COLON
    (56) case_separator -> . SEMICOLON

    COLON           shift and go to state 355
    SEMICOLON       shift and go to state 353


    case_separator                 shift and go to state 354

state 338

    (49) switch_stmt -> LBRACE SEMICOLON case_stmt . RBRACE
    (53) case_stmt -> case_stmt . CASE expr case_separator inner_stmts
    (54) case_stmt -> case_stmt . DEFAULT case_separator inner_stmts

    RBRACE          shift and go to state 356
    CASE            shift and go to state 335
    DEFAULT         shift and go to state 337



state 339

    (50) switch_stmt -> COLON case_stmt ENDSWITCH . SEMICOLON

    SEMICOLON       shift and go to state 357



state 340

    (51) switch_stmt -> COLON SEMICOLON case_stmt . ENDSWITCH SEMICOLON
    (53) case_stmt -> case_stmt . CASE expr case_separator inner_stmts
    (54) case_stmt -> case_stmt . DEFAULT case_separator inner_stmts

    ENDSWITCH       shift and go to state 358
    CASE            shift and go to state 335
    DEFAULT         shift and go to state 337



state 341

    (122) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW BIT_AND . variable
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    variable                       shift and go to state 359

state 342

    (123) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW expr .
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr

    COMMA           reduce using rule 123 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW expr .)
    RPAREN          reduce using rule 123 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW expr .)
    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116



state 343

    (32) stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .

    WHILE           reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    DO              reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    FOR             reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    FOREACH         reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    SWITCH          reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    BREAK           reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    RETURN          reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    GLOBAL          reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    STATIC          reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ECHO            reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    LBRACE          reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    CLONE           reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ARRAY           reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    PLUS            reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    MINUS           reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    BIT_NOT         reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    NOT             reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    CONST_DECIMAL   reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    CONST_DOUBLE    reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    CONST_STRING    reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    NULL            reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    TRUE            reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    FALSE           reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    INC             reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    DEC             reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    EMPTY           reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    EVAL            reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    LPAREN          reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    INCLUDE         reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    REQUIRE         reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    EXIT            reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    PRINT           reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    IF              reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    STRING          reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ENDIF           reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ELSE            reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ELSEIF          reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    RBRACE          reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    VAR             reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    $end            reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ENDWHILE        reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ENDFOREACH      reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    CASE            reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    DEFAULT         reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ENDSWITCH       reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ENDFOR          reduce using rule 32 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)



state 344

    (40) stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .

    WHILE           reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    DO              reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    FOR             reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    FOREACH         reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    SWITCH          reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    BREAK           reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    CONTINUE        reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    RETURN          reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    GLOBAL          reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    STATIC          reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ECHO            reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    LBRACE          reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    SEMICOLON       reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    FUNCTION        reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    CLONE           reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ARRAY           reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    PLUS            reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    MINUS           reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    BIT_NOT         reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    NOT             reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    CONST_DECIMAL   reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    CONST_DOUBLE    reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    CONST_STRING    reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    NULL            reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    TRUE            reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    FALSE           reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    INC             reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    DEC             reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    EMPTY           reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    EVAL            reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    LPAREN          reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    INCLUDE         reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    INCLUDE_ONCE    reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    REQUIRE         reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    REQUIRE_ONCE    reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    EXIT            reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    PRINT           reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    IF              reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    IDENTIFIER      reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    STRING          reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ENDIF           reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ELSE            reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ELSEIF          reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    RBRACE          reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    VAR             reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    $end            reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ENDWHILE        reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ENDFOREACH      reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    CASE            reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    DEFAULT         reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ENDSWITCH       reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ENDFOR          reduce using rule 40 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)



state 345

    (46) foreach_stmt -> COLON . inner_stmts ENDFOREACH SEMICOLON
    (77) inner_stmts -> . inner_stmts inner_stmt
    (78) inner_stmts -> . empty
    (180) empty -> .

    ENDFOREACH      reduce using rule 180 (empty -> .)
    WHILE           reduce using rule 180 (empty -> .)
    DO              reduce using rule 180 (empty -> .)
    FOR             reduce using rule 180 (empty -> .)
    FOREACH         reduce using rule 180 (empty -> .)
    SWITCH          reduce using rule 180 (empty -> .)
    BREAK           reduce using rule 180 (empty -> .)
    CONTINUE        reduce using rule 180 (empty -> .)
    RETURN          reduce using rule 180 (empty -> .)
    GLOBAL          reduce using rule 180 (empty -> .)
    STATIC          reduce using rule 180 (empty -> .)
    ECHO            reduce using rule 180 (empty -> .)
    LBRACE          reduce using rule 180 (empty -> .)
    SEMICOLON       reduce using rule 180 (empty -> .)
    FUNCTION        reduce using rule 180 (empty -> .)
    CLONE           reduce using rule 180 (empty -> .)
    ARRAY           reduce using rule 180 (empty -> .)
    PLUS            reduce using rule 180 (empty -> .)
    MINUS           reduce using rule 180 (empty -> .)
    BIT_NOT         reduce using rule 180 (empty -> .)
    NOT             reduce using rule 180 (empty -> .)
    CONST_DECIMAL   reduce using rule 180 (empty -> .)
    CONST_DOUBLE    reduce using rule 180 (empty -> .)
    CONST_STRING    reduce using rule 180 (empty -> .)
    NULL            reduce using rule 180 (empty -> .)
    TRUE            reduce using rule 180 (empty -> .)
    FALSE           reduce using rule 180 (empty -> .)
    INC             reduce using rule 180 (empty -> .)
    DEC             reduce using rule 180 (empty -> .)
    EMPTY           reduce using rule 180 (empty -> .)
    EVAL            reduce using rule 180 (empty -> .)
    LPAREN          reduce using rule 180 (empty -> .)
    INCLUDE         reduce using rule 180 (empty -> .)
    INCLUDE_ONCE    reduce using rule 180 (empty -> .)
    REQUIRE         reduce using rule 180 (empty -> .)
    REQUIRE_ONCE    reduce using rule 180 (empty -> .)
    EXIT            reduce using rule 180 (empty -> .)
    PRINT           reduce using rule 180 (empty -> .)
    IF              reduce using rule 180 (empty -> .)
    IDENTIFIER      reduce using rule 180 (empty -> .)
    STRING          reduce using rule 180 (empty -> .)


    inner_stmts                    shift and go to state 360
    empty                          shift and go to state 84

state 346

    (45) foreach_stmt -> stmt .

    VAR             reduce using rule 45 (foreach_stmt -> stmt .)
    WHILE           reduce using rule 45 (foreach_stmt -> stmt .)
    DO              reduce using rule 45 (foreach_stmt -> stmt .)
    FOR             reduce using rule 45 (foreach_stmt -> stmt .)
    FOREACH         reduce using rule 45 (foreach_stmt -> stmt .)
    SWITCH          reduce using rule 45 (foreach_stmt -> stmt .)
    BREAK           reduce using rule 45 (foreach_stmt -> stmt .)
    CONTINUE        reduce using rule 45 (foreach_stmt -> stmt .)
    RETURN          reduce using rule 45 (foreach_stmt -> stmt .)
    GLOBAL          reduce using rule 45 (foreach_stmt -> stmt .)
    STATIC          reduce using rule 45 (foreach_stmt -> stmt .)
    ECHO            reduce using rule 45 (foreach_stmt -> stmt .)
    LBRACE          reduce using rule 45 (foreach_stmt -> stmt .)
    SEMICOLON       reduce using rule 45 (foreach_stmt -> stmt .)
    FUNCTION        reduce using rule 45 (foreach_stmt -> stmt .)
    CLONE           reduce using rule 45 (foreach_stmt -> stmt .)
    ARRAY           reduce using rule 45 (foreach_stmt -> stmt .)
    PLUS            reduce using rule 45 (foreach_stmt -> stmt .)
    MINUS           reduce using rule 45 (foreach_stmt -> stmt .)
    BIT_NOT         reduce using rule 45 (foreach_stmt -> stmt .)
    NOT             reduce using rule 45 (foreach_stmt -> stmt .)
    CONST_DECIMAL   reduce using rule 45 (foreach_stmt -> stmt .)
    CONST_DOUBLE    reduce using rule 45 (foreach_stmt -> stmt .)
    CONST_STRING    reduce using rule 45 (foreach_stmt -> stmt .)
    NULL            reduce using rule 45 (foreach_stmt -> stmt .)
    TRUE            reduce using rule 45 (foreach_stmt -> stmt .)
    FALSE           reduce using rule 45 (foreach_stmt -> stmt .)
    INC             reduce using rule 45 (foreach_stmt -> stmt .)
    DEC             reduce using rule 45 (foreach_stmt -> stmt .)
    EMPTY           reduce using rule 45 (foreach_stmt -> stmt .)
    EVAL            reduce using rule 45 (foreach_stmt -> stmt .)
    LPAREN          reduce using rule 45 (foreach_stmt -> stmt .)
    INCLUDE         reduce using rule 45 (foreach_stmt -> stmt .)
    INCLUDE_ONCE    reduce using rule 45 (foreach_stmt -> stmt .)
    REQUIRE         reduce using rule 45 (foreach_stmt -> stmt .)
    REQUIRE_ONCE    reduce using rule 45 (foreach_stmt -> stmt .)
    EXIT            reduce using rule 45 (foreach_stmt -> stmt .)
    PRINT           reduce using rule 45 (foreach_stmt -> stmt .)
    IF              reduce using rule 45 (foreach_stmt -> stmt .)
    IDENTIFIER      reduce using rule 45 (foreach_stmt -> stmt .)
    STRING          reduce using rule 45 (foreach_stmt -> stmt .)
    $end            reduce using rule 45 (foreach_stmt -> stmt .)
    RBRACE          reduce using rule 45 (foreach_stmt -> stmt .)
    ENDIF           reduce using rule 45 (foreach_stmt -> stmt .)
    ELSE            reduce using rule 45 (foreach_stmt -> stmt .)
    ELSEIF          reduce using rule 45 (foreach_stmt -> stmt .)
    ENDWHILE        reduce using rule 45 (foreach_stmt -> stmt .)
    ENDFOREACH      reduce using rule 45 (foreach_stmt -> stmt .)
    CASE            reduce using rule 45 (foreach_stmt -> stmt .)
    DEFAULT         reduce using rule 45 (foreach_stmt -> stmt .)
    ENDSWITCH       reduce using rule 45 (foreach_stmt -> stmt .)
    ENDFOR          reduce using rule 45 (foreach_stmt -> stmt .)



state 347

    (109) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar .
    (111) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar . DOUBLE_ARROW scalar

    COMMA           reduce using rule 109 (scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar .)
    RPAREN          reduce using rule 109 (scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar .)
    DOUBLE_ARROW    shift and go to state 361



state 348

    (112) scalar_non_empty_array_pair_list -> scalar DOUBLE_ARROW scalar .

    COMMA           reduce using rule 112 (scalar_non_empty_array_pair_list -> scalar DOUBLE_ARROW scalar .)
    RPAREN          reduce using rule 112 (scalar_non_empty_array_pair_list -> scalar DOUBLE_ARROW scalar .)



state 349

    (11) func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .

    RBRACE          reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    WHILE           reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    DO              reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    FOR             reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    FOREACH         reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    SWITCH          reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    BREAK           reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    CONTINUE        reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    RETURN          reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    GLOBAL          reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    STATIC          reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    ECHO            reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    LBRACE          reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    SEMICOLON       reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    FUNCTION        reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    CLONE           reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    ARRAY           reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    PLUS            reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    MINUS           reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    BIT_NOT         reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    NOT             reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    CONST_DECIMAL   reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    CONST_DOUBLE    reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    CONST_STRING    reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    NULL            reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    TRUE            reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    FALSE           reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    INC             reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    DEC             reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    EMPTY           reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    EVAL            reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    LPAREN          reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    INCLUDE         reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    INCLUDE_ONCE    reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    REQUIRE         reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    REQUIRE_ONCE    reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    EXIT            reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    PRINT           reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    IF              reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    IDENTIFIER      reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    STRING          reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    ENDIF           reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    ELSE            reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    ELSEIF          reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    ENDWHILE        reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    CASE            reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    DEFAULT         reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    ENDSWITCH       reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    ENDFOREACH      reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    VAR             reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    $end            reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)
    ENDFOR          reduce using rule 11 (func_decl -> FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE .)



state 350

    (33) stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN . for_stmt
    (38) for_stmt -> . stmt
    (39) for_stmt -> . COLON inner_stmts ENDFOR SEMICOLON
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    COLON           shift and go to state 363
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 364
    for_stmt                       shift and go to state 362
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 351

    (31) while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .

    VAR             reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    WHILE           reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    DO              reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    FOR             reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    FOREACH         reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    SWITCH          reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    BREAK           reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    CONTINUE        reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    RETURN          reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    GLOBAL          reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    STATIC          reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ECHO            reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    LBRACE          reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    SEMICOLON       reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    FUNCTION        reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    CLONE           reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ARRAY           reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    PLUS            reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    MINUS           reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    BIT_NOT         reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    NOT             reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    CONST_DECIMAL   reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    CONST_DOUBLE    reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    CONST_STRING    reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    NULL            reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    TRUE            reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    FALSE           reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    INC             reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    DEC             reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    EMPTY           reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    EVAL            reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    LPAREN          reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    INCLUDE         reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    REQUIRE         reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    EXIT            reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    PRINT           reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    IF              reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    IDENTIFIER      reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    STRING          reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    $end            reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    RBRACE          reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ENDIF           reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ELSE            reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ELSEIF          reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ENDWHILE        reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ENDFOREACH      reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    CASE            reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    DEFAULT         reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ENDSWITCH       reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ENDFOR          reduce using rule 31 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)



state 352

    (53) case_stmt -> case_stmt CASE expr . case_separator inner_stmts
    (132) expr -> expr . AND_OP expr
    (133) expr -> expr . OR_OP expr
    (134) expr -> expr . BIT_OR expr
    (135) expr -> expr . BIT_XOR expr
    (136) expr -> expr . BIT_AND expr
    (137) expr -> expr . DOT expr
    (138) expr -> expr . PLUS expr
    (139) expr -> expr . MINUS expr
    (140) expr -> expr . MULT expr
    (141) expr -> expr . DIV expr
    (142) expr -> expr . BIT_LSHIFT expr
    (143) expr -> expr . BIT_RSHIFT expr
    (144) expr -> expr . MOD expr
    (145) expr -> expr . IDENTICAL expr
    (146) expr -> expr . NOT_IDENTICAL expr
    (147) expr -> expr . EQ_EQ expr
    (148) expr -> expr . NOT_EQ expr
    (149) expr -> expr . LESSER expr
    (150) expr -> expr . LESSER_EQ expr
    (151) expr -> expr . GREATER expr
    (152) expr -> expr . GREATER_EQ expr
    (153) expr -> expr . INSTANCEOF expr
    (164) expr -> expr . COND_OP expr COLON expr
    (55) case_separator -> . COLON
    (56) case_separator -> . SEMICOLON

    AND_OP          shift and go to state 113
    OR_OP           shift and go to state 106
    BIT_OR          shift and go to state 118
    BIT_XOR         shift and go to state 101
    BIT_AND         shift and go to state 111
    DOT             shift and go to state 108
    PLUS            shift and go to state 107
    MINUS           shift and go to state 102
    MULT            shift and go to state 103
    DIV             shift and go to state 100
    BIT_LSHIFT      shift and go to state 120
    BIT_RSHIFT      shift and go to state 117
    MOD             shift and go to state 121
    IDENTICAL       shift and go to state 104
    NOT_IDENTICAL   shift and go to state 110
    EQ_EQ           shift and go to state 98
    NOT_EQ          shift and go to state 109
    LESSER          shift and go to state 119
    LESSER_EQ       shift and go to state 112
    GREATER         shift and go to state 115
    GREATER_EQ      shift and go to state 99
    INSTANCEOF      shift and go to state 114
    COND_OP         shift and go to state 116
    COLON           shift and go to state 355
    SEMICOLON       shift and go to state 353


    case_separator                 shift and go to state 365

state 353

    (56) case_separator -> SEMICOLON .

    WHILE           reduce using rule 56 (case_separator -> SEMICOLON .)
    DO              reduce using rule 56 (case_separator -> SEMICOLON .)
    FOR             reduce using rule 56 (case_separator -> SEMICOLON .)
    FOREACH         reduce using rule 56 (case_separator -> SEMICOLON .)
    SWITCH          reduce using rule 56 (case_separator -> SEMICOLON .)
    BREAK           reduce using rule 56 (case_separator -> SEMICOLON .)
    CONTINUE        reduce using rule 56 (case_separator -> SEMICOLON .)
    RETURN          reduce using rule 56 (case_separator -> SEMICOLON .)
    GLOBAL          reduce using rule 56 (case_separator -> SEMICOLON .)
    STATIC          reduce using rule 56 (case_separator -> SEMICOLON .)
    ECHO            reduce using rule 56 (case_separator -> SEMICOLON .)
    LBRACE          reduce using rule 56 (case_separator -> SEMICOLON .)
    SEMICOLON       reduce using rule 56 (case_separator -> SEMICOLON .)
    FUNCTION        reduce using rule 56 (case_separator -> SEMICOLON .)
    CLONE           reduce using rule 56 (case_separator -> SEMICOLON .)
    ARRAY           reduce using rule 56 (case_separator -> SEMICOLON .)
    PLUS            reduce using rule 56 (case_separator -> SEMICOLON .)
    MINUS           reduce using rule 56 (case_separator -> SEMICOLON .)
    BIT_NOT         reduce using rule 56 (case_separator -> SEMICOLON .)
    NOT             reduce using rule 56 (case_separator -> SEMICOLON .)
    CONST_DECIMAL   reduce using rule 56 (case_separator -> SEMICOLON .)
    CONST_DOUBLE    reduce using rule 56 (case_separator -> SEMICOLON .)
    CONST_STRING    reduce using rule 56 (case_separator -> SEMICOLON .)
    NULL            reduce using rule 56 (case_separator -> SEMICOLON .)
    TRUE            reduce using rule 56 (case_separator -> SEMICOLON .)
    FALSE           reduce using rule 56 (case_separator -> SEMICOLON .)
    INC             reduce using rule 56 (case_separator -> SEMICOLON .)
    DEC             reduce using rule 56 (case_separator -> SEMICOLON .)
    EMPTY           reduce using rule 56 (case_separator -> SEMICOLON .)
    EVAL            reduce using rule 56 (case_separator -> SEMICOLON .)
    LPAREN          reduce using rule 56 (case_separator -> SEMICOLON .)
    INCLUDE         reduce using rule 56 (case_separator -> SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 56 (case_separator -> SEMICOLON .)
    REQUIRE         reduce using rule 56 (case_separator -> SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 56 (case_separator -> SEMICOLON .)
    EXIT            reduce using rule 56 (case_separator -> SEMICOLON .)
    PRINT           reduce using rule 56 (case_separator -> SEMICOLON .)
    IF              reduce using rule 56 (case_separator -> SEMICOLON .)
    IDENTIFIER      reduce using rule 56 (case_separator -> SEMICOLON .)
    STRING          reduce using rule 56 (case_separator -> SEMICOLON .)
    RBRACE          reduce using rule 56 (case_separator -> SEMICOLON .)
    CASE            reduce using rule 56 (case_separator -> SEMICOLON .)
    DEFAULT         reduce using rule 56 (case_separator -> SEMICOLON .)
    ENDSWITCH       reduce using rule 56 (case_separator -> SEMICOLON .)



state 354

    (54) case_stmt -> case_stmt DEFAULT case_separator . inner_stmts
    (77) inner_stmts -> . inner_stmts inner_stmt
    (78) inner_stmts -> . empty
    (180) empty -> .

    WHILE           reduce using rule 180 (empty -> .)
    DO              reduce using rule 180 (empty -> .)
    FOR             reduce using rule 180 (empty -> .)
    FOREACH         reduce using rule 180 (empty -> .)
    SWITCH          reduce using rule 180 (empty -> .)
    BREAK           reduce using rule 180 (empty -> .)
    CONTINUE        reduce using rule 180 (empty -> .)
    RETURN          reduce using rule 180 (empty -> .)
    GLOBAL          reduce using rule 180 (empty -> .)
    STATIC          reduce using rule 180 (empty -> .)
    ECHO            reduce using rule 180 (empty -> .)
    LBRACE          reduce using rule 180 (empty -> .)
    SEMICOLON       reduce using rule 180 (empty -> .)
    FUNCTION        reduce using rule 180 (empty -> .)
    CLONE           reduce using rule 180 (empty -> .)
    ARRAY           reduce using rule 180 (empty -> .)
    PLUS            reduce using rule 180 (empty -> .)
    MINUS           reduce using rule 180 (empty -> .)
    BIT_NOT         reduce using rule 180 (empty -> .)
    NOT             reduce using rule 180 (empty -> .)
    CONST_DECIMAL   reduce using rule 180 (empty -> .)
    CONST_DOUBLE    reduce using rule 180 (empty -> .)
    CONST_STRING    reduce using rule 180 (empty -> .)
    NULL            reduce using rule 180 (empty -> .)
    TRUE            reduce using rule 180 (empty -> .)
    FALSE           reduce using rule 180 (empty -> .)
    INC             reduce using rule 180 (empty -> .)
    DEC             reduce using rule 180 (empty -> .)
    EMPTY           reduce using rule 180 (empty -> .)
    EVAL            reduce using rule 180 (empty -> .)
    LPAREN          reduce using rule 180 (empty -> .)
    INCLUDE         reduce using rule 180 (empty -> .)
    INCLUDE_ONCE    reduce using rule 180 (empty -> .)
    REQUIRE         reduce using rule 180 (empty -> .)
    REQUIRE_ONCE    reduce using rule 180 (empty -> .)
    EXIT            reduce using rule 180 (empty -> .)
    PRINT           reduce using rule 180 (empty -> .)
    IF              reduce using rule 180 (empty -> .)
    IDENTIFIER      reduce using rule 180 (empty -> .)
    STRING          reduce using rule 180 (empty -> .)
    RBRACE          reduce using rule 180 (empty -> .)
    CASE            reduce using rule 180 (empty -> .)
    DEFAULT         reduce using rule 180 (empty -> .)
    ENDSWITCH       reduce using rule 180 (empty -> .)


    inner_stmts                    shift and go to state 366
    empty                          shift and go to state 84

state 355

    (55) case_separator -> COLON .

    WHILE           reduce using rule 55 (case_separator -> COLON .)
    DO              reduce using rule 55 (case_separator -> COLON .)
    FOR             reduce using rule 55 (case_separator -> COLON .)
    FOREACH         reduce using rule 55 (case_separator -> COLON .)
    SWITCH          reduce using rule 55 (case_separator -> COLON .)
    BREAK           reduce using rule 55 (case_separator -> COLON .)
    CONTINUE        reduce using rule 55 (case_separator -> COLON .)
    RETURN          reduce using rule 55 (case_separator -> COLON .)
    GLOBAL          reduce using rule 55 (case_separator -> COLON .)
    STATIC          reduce using rule 55 (case_separator -> COLON .)
    ECHO            reduce using rule 55 (case_separator -> COLON .)
    LBRACE          reduce using rule 55 (case_separator -> COLON .)
    SEMICOLON       reduce using rule 55 (case_separator -> COLON .)
    FUNCTION        reduce using rule 55 (case_separator -> COLON .)
    CLONE           reduce using rule 55 (case_separator -> COLON .)
    ARRAY           reduce using rule 55 (case_separator -> COLON .)
    PLUS            reduce using rule 55 (case_separator -> COLON .)
    MINUS           reduce using rule 55 (case_separator -> COLON .)
    BIT_NOT         reduce using rule 55 (case_separator -> COLON .)
    NOT             reduce using rule 55 (case_separator -> COLON .)
    CONST_DECIMAL   reduce using rule 55 (case_separator -> COLON .)
    CONST_DOUBLE    reduce using rule 55 (case_separator -> COLON .)
    CONST_STRING    reduce using rule 55 (case_separator -> COLON .)
    NULL            reduce using rule 55 (case_separator -> COLON .)
    TRUE            reduce using rule 55 (case_separator -> COLON .)
    FALSE           reduce using rule 55 (case_separator -> COLON .)
    INC             reduce using rule 55 (case_separator -> COLON .)
    DEC             reduce using rule 55 (case_separator -> COLON .)
    EMPTY           reduce using rule 55 (case_separator -> COLON .)
    EVAL            reduce using rule 55 (case_separator -> COLON .)
    LPAREN          reduce using rule 55 (case_separator -> COLON .)
    INCLUDE         reduce using rule 55 (case_separator -> COLON .)
    INCLUDE_ONCE    reduce using rule 55 (case_separator -> COLON .)
    REQUIRE         reduce using rule 55 (case_separator -> COLON .)
    REQUIRE_ONCE    reduce using rule 55 (case_separator -> COLON .)
    EXIT            reduce using rule 55 (case_separator -> COLON .)
    PRINT           reduce using rule 55 (case_separator -> COLON .)
    IF              reduce using rule 55 (case_separator -> COLON .)
    IDENTIFIER      reduce using rule 55 (case_separator -> COLON .)
    STRING          reduce using rule 55 (case_separator -> COLON .)
    RBRACE          reduce using rule 55 (case_separator -> COLON .)
    CASE            reduce using rule 55 (case_separator -> COLON .)
    DEFAULT         reduce using rule 55 (case_separator -> COLON .)
    ENDSWITCH       reduce using rule 55 (case_separator -> COLON .)



state 356

    (49) switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .

    VAR             reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    WHILE           reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    DO              reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    FOR             reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    FOREACH         reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    SWITCH          reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    BREAK           reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    CONTINUE        reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    RETURN          reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    GLOBAL          reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    STATIC          reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ECHO            reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    LBRACE          reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    SEMICOLON       reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    FUNCTION        reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    CLONE           reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ARRAY           reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    PLUS            reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    MINUS           reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    BIT_NOT         reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    NOT             reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    CONST_DECIMAL   reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    CONST_DOUBLE    reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    CONST_STRING    reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    NULL            reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    TRUE            reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    FALSE           reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    INC             reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    DEC             reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    EMPTY           reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    EVAL            reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    LPAREN          reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    INCLUDE         reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    INCLUDE_ONCE    reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    REQUIRE         reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    REQUIRE_ONCE    reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    EXIT            reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    PRINT           reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    IF              reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    IDENTIFIER      reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    STRING          reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    $end            reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    RBRACE          reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ENDIF           reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ELSE            reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ELSEIF          reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ENDWHILE        reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ENDFOREACH      reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    CASE            reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    DEFAULT         reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ENDSWITCH       reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ENDFOR          reduce using rule 49 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)



state 357

    (50) switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .

    VAR             reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    WHILE           reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    DO              reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    FOR             reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    FOREACH         reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    SWITCH          reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    BREAK           reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    CONTINUE        reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    RETURN          reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    GLOBAL          reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    STATIC          reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ECHO            reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    LBRACE          reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    SEMICOLON       reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    FUNCTION        reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    CLONE           reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ARRAY           reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    PLUS            reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    MINUS           reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    BIT_NOT         reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    NOT             reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    CONST_DECIMAL   reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    CONST_DOUBLE    reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    CONST_STRING    reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    NULL            reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    TRUE            reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    FALSE           reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    INC             reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    DEC             reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    EMPTY           reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    EVAL            reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    LPAREN          reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    INCLUDE         reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    REQUIRE         reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    EXIT            reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    PRINT           reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    IF              reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    IDENTIFIER      reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    STRING          reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    $end            reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    RBRACE          reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ENDIF           reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ELSE            reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ELSEIF          reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ENDWHILE        reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ENDFOREACH      reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    CASE            reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    DEFAULT         reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ENDSWITCH       reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ENDFOR          reduce using rule 50 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)



state 358

    (51) switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH . SEMICOLON

    SEMICOLON       shift and go to state 367



state 359

    (122) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW BIT_AND variable .

    COMMA           reduce using rule 122 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW BIT_AND variable .)
    RPAREN          reduce using rule 122 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW BIT_AND variable .)



state 360

    (46) foreach_stmt -> COLON inner_stmts . ENDFOREACH SEMICOLON
    (77) inner_stmts -> inner_stmts . inner_stmt
    (79) inner_stmt -> . stmt
    (80) inner_stmt -> . func_decl
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (11) func_decl -> . FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    ENDFOREACH      shift and go to state 368
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    FUNCTION        shift and go to state 24
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    inner_stmt                     shift and go to state 162
    func_decl                      shift and go to state 161
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 160
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 361

    (111) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar DOUBLE_ARROW . scalar
    (98) scalar -> . CONST_DECIMAL
    (99) scalar -> . CONST_DOUBLE
    (100) scalar -> . CONST_STRING
    (101) scalar -> . NULL
    (102) scalar -> . TRUE
    (103) scalar -> . FALSE
    (104) scalar -> . PLUS scalar
    (105) scalar -> . MINUS scalar
    (106) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 231
    CONST_DOUBLE    shift and go to state 232
    CONST_STRING    shift and go to state 230
    NULL            shift and go to state 228
    TRUE            shift and go to state 236
    FALSE           shift and go to state 229
    PLUS            shift and go to state 234
    MINUS           shift and go to state 237
    ARRAY           shift and go to state 235


    scalar                         shift and go to state 369

state 362

    (33) stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .

    WHILE           reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    DO              reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    FOR             reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    FOREACH         reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    SWITCH          reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    BREAK           reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    CONTINUE        reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    RETURN          reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    GLOBAL          reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    STATIC          reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    ECHO            reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    LBRACE          reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    SEMICOLON       reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    FUNCTION        reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    CLONE           reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    ARRAY           reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    PLUS            reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    MINUS           reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    BIT_NOT         reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    NOT             reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    CONST_DECIMAL   reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    CONST_DOUBLE    reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    CONST_STRING    reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    NULL            reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    TRUE            reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    FALSE           reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    INC             reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    DEC             reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    EMPTY           reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    EVAL            reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    LPAREN          reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    INCLUDE         reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    INCLUDE_ONCE    reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    REQUIRE         reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    REQUIRE_ONCE    reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    EXIT            reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    PRINT           reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    IF              reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    IDENTIFIER      reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    STRING          reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    ENDIF           reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    ELSE            reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    ELSEIF          reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    RBRACE          reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    VAR             reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    $end            reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    ENDWHILE        reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    ENDFOREACH      reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    CASE            reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    DEFAULT         reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    ENDSWITCH       reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)
    ENDFOR          reduce using rule 33 (stmt -> FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt .)



state 363

    (39) for_stmt -> COLON . inner_stmts ENDFOR SEMICOLON
    (77) inner_stmts -> . inner_stmts inner_stmt
    (78) inner_stmts -> . empty
    (180) empty -> .

    ENDFOR          reduce using rule 180 (empty -> .)
    WHILE           reduce using rule 180 (empty -> .)
    DO              reduce using rule 180 (empty -> .)
    FOR             reduce using rule 180 (empty -> .)
    FOREACH         reduce using rule 180 (empty -> .)
    SWITCH          reduce using rule 180 (empty -> .)
    BREAK           reduce using rule 180 (empty -> .)
    CONTINUE        reduce using rule 180 (empty -> .)
    RETURN          reduce using rule 180 (empty -> .)
    GLOBAL          reduce using rule 180 (empty -> .)
    STATIC          reduce using rule 180 (empty -> .)
    ECHO            reduce using rule 180 (empty -> .)
    LBRACE          reduce using rule 180 (empty -> .)
    SEMICOLON       reduce using rule 180 (empty -> .)
    FUNCTION        reduce using rule 180 (empty -> .)
    CLONE           reduce using rule 180 (empty -> .)
    ARRAY           reduce using rule 180 (empty -> .)
    PLUS            reduce using rule 180 (empty -> .)
    MINUS           reduce using rule 180 (empty -> .)
    BIT_NOT         reduce using rule 180 (empty -> .)
    NOT             reduce using rule 180 (empty -> .)
    CONST_DECIMAL   reduce using rule 180 (empty -> .)
    CONST_DOUBLE    reduce using rule 180 (empty -> .)
    CONST_STRING    reduce using rule 180 (empty -> .)
    NULL            reduce using rule 180 (empty -> .)
    TRUE            reduce using rule 180 (empty -> .)
    FALSE           reduce using rule 180 (empty -> .)
    INC             reduce using rule 180 (empty -> .)
    DEC             reduce using rule 180 (empty -> .)
    EMPTY           reduce using rule 180 (empty -> .)
    EVAL            reduce using rule 180 (empty -> .)
    LPAREN          reduce using rule 180 (empty -> .)
    INCLUDE         reduce using rule 180 (empty -> .)
    INCLUDE_ONCE    reduce using rule 180 (empty -> .)
    REQUIRE         reduce using rule 180 (empty -> .)
    REQUIRE_ONCE    reduce using rule 180 (empty -> .)
    EXIT            reduce using rule 180 (empty -> .)
    PRINT           reduce using rule 180 (empty -> .)
    IF              reduce using rule 180 (empty -> .)
    IDENTIFIER      reduce using rule 180 (empty -> .)
    STRING          reduce using rule 180 (empty -> .)


    inner_stmts                    shift and go to state 370
    empty                          shift and go to state 84

state 364

    (38) for_stmt -> stmt .

    VAR             reduce using rule 38 (for_stmt -> stmt .)
    WHILE           reduce using rule 38 (for_stmt -> stmt .)
    DO              reduce using rule 38 (for_stmt -> stmt .)
    FOR             reduce using rule 38 (for_stmt -> stmt .)
    FOREACH         reduce using rule 38 (for_stmt -> stmt .)
    SWITCH          reduce using rule 38 (for_stmt -> stmt .)
    BREAK           reduce using rule 38 (for_stmt -> stmt .)
    CONTINUE        reduce using rule 38 (for_stmt -> stmt .)
    RETURN          reduce using rule 38 (for_stmt -> stmt .)
    GLOBAL          reduce using rule 38 (for_stmt -> stmt .)
    STATIC          reduce using rule 38 (for_stmt -> stmt .)
    ECHO            reduce using rule 38 (for_stmt -> stmt .)
    LBRACE          reduce using rule 38 (for_stmt -> stmt .)
    SEMICOLON       reduce using rule 38 (for_stmt -> stmt .)
    FUNCTION        reduce using rule 38 (for_stmt -> stmt .)
    CLONE           reduce using rule 38 (for_stmt -> stmt .)
    ARRAY           reduce using rule 38 (for_stmt -> stmt .)
    PLUS            reduce using rule 38 (for_stmt -> stmt .)
    MINUS           reduce using rule 38 (for_stmt -> stmt .)
    BIT_NOT         reduce using rule 38 (for_stmt -> stmt .)
    NOT             reduce using rule 38 (for_stmt -> stmt .)
    CONST_DECIMAL   reduce using rule 38 (for_stmt -> stmt .)
    CONST_DOUBLE    reduce using rule 38 (for_stmt -> stmt .)
    CONST_STRING    reduce using rule 38 (for_stmt -> stmt .)
    NULL            reduce using rule 38 (for_stmt -> stmt .)
    TRUE            reduce using rule 38 (for_stmt -> stmt .)
    FALSE           reduce using rule 38 (for_stmt -> stmt .)
    INC             reduce using rule 38 (for_stmt -> stmt .)
    DEC             reduce using rule 38 (for_stmt -> stmt .)
    EMPTY           reduce using rule 38 (for_stmt -> stmt .)
    EVAL            reduce using rule 38 (for_stmt -> stmt .)
    LPAREN          reduce using rule 38 (for_stmt -> stmt .)
    INCLUDE         reduce using rule 38 (for_stmt -> stmt .)
    INCLUDE_ONCE    reduce using rule 38 (for_stmt -> stmt .)
    REQUIRE         reduce using rule 38 (for_stmt -> stmt .)
    REQUIRE_ONCE    reduce using rule 38 (for_stmt -> stmt .)
    EXIT            reduce using rule 38 (for_stmt -> stmt .)
    PRINT           reduce using rule 38 (for_stmt -> stmt .)
    IF              reduce using rule 38 (for_stmt -> stmt .)
    IDENTIFIER      reduce using rule 38 (for_stmt -> stmt .)
    STRING          reduce using rule 38 (for_stmt -> stmt .)
    $end            reduce using rule 38 (for_stmt -> stmt .)
    RBRACE          reduce using rule 38 (for_stmt -> stmt .)
    ENDIF           reduce using rule 38 (for_stmt -> stmt .)
    ELSE            reduce using rule 38 (for_stmt -> stmt .)
    ELSEIF          reduce using rule 38 (for_stmt -> stmt .)
    ENDWHILE        reduce using rule 38 (for_stmt -> stmt .)
    ENDFOREACH      reduce using rule 38 (for_stmt -> stmt .)
    CASE            reduce using rule 38 (for_stmt -> stmt .)
    DEFAULT         reduce using rule 38 (for_stmt -> stmt .)
    ENDSWITCH       reduce using rule 38 (for_stmt -> stmt .)
    ENDFOR          reduce using rule 38 (for_stmt -> stmt .)



state 365

    (53) case_stmt -> case_stmt CASE expr case_separator . inner_stmts
    (77) inner_stmts -> . inner_stmts inner_stmt
    (78) inner_stmts -> . empty
    (180) empty -> .

    WHILE           reduce using rule 180 (empty -> .)
    DO              reduce using rule 180 (empty -> .)
    FOR             reduce using rule 180 (empty -> .)
    FOREACH         reduce using rule 180 (empty -> .)
    SWITCH          reduce using rule 180 (empty -> .)
    BREAK           reduce using rule 180 (empty -> .)
    CONTINUE        reduce using rule 180 (empty -> .)
    RETURN          reduce using rule 180 (empty -> .)
    GLOBAL          reduce using rule 180 (empty -> .)
    STATIC          reduce using rule 180 (empty -> .)
    ECHO            reduce using rule 180 (empty -> .)
    LBRACE          reduce using rule 180 (empty -> .)
    SEMICOLON       reduce using rule 180 (empty -> .)
    FUNCTION        reduce using rule 180 (empty -> .)
    CLONE           reduce using rule 180 (empty -> .)
    ARRAY           reduce using rule 180 (empty -> .)
    PLUS            reduce using rule 180 (empty -> .)
    MINUS           reduce using rule 180 (empty -> .)
    BIT_NOT         reduce using rule 180 (empty -> .)
    NOT             reduce using rule 180 (empty -> .)
    CONST_DECIMAL   reduce using rule 180 (empty -> .)
    CONST_DOUBLE    reduce using rule 180 (empty -> .)
    CONST_STRING    reduce using rule 180 (empty -> .)
    NULL            reduce using rule 180 (empty -> .)
    TRUE            reduce using rule 180 (empty -> .)
    FALSE           reduce using rule 180 (empty -> .)
    INC             reduce using rule 180 (empty -> .)
    DEC             reduce using rule 180 (empty -> .)
    EMPTY           reduce using rule 180 (empty -> .)
    EVAL            reduce using rule 180 (empty -> .)
    LPAREN          reduce using rule 180 (empty -> .)
    INCLUDE         reduce using rule 180 (empty -> .)
    INCLUDE_ONCE    reduce using rule 180 (empty -> .)
    REQUIRE         reduce using rule 180 (empty -> .)
    REQUIRE_ONCE    reduce using rule 180 (empty -> .)
    EXIT            reduce using rule 180 (empty -> .)
    PRINT           reduce using rule 180 (empty -> .)
    IF              reduce using rule 180 (empty -> .)
    IDENTIFIER      reduce using rule 180 (empty -> .)
    STRING          reduce using rule 180 (empty -> .)
    RBRACE          reduce using rule 180 (empty -> .)
    CASE            reduce using rule 180 (empty -> .)
    DEFAULT         reduce using rule 180 (empty -> .)
    ENDSWITCH       reduce using rule 180 (empty -> .)


    inner_stmts                    shift and go to state 371
    empty                          shift and go to state 84

state 366

    (54) case_stmt -> case_stmt DEFAULT case_separator inner_stmts .
    (77) inner_stmts -> inner_stmts . inner_stmt
    (79) inner_stmt -> . stmt
    (80) inner_stmt -> . func_decl
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (11) func_decl -> . FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    RBRACE          reduce using rule 54 (case_stmt -> case_stmt DEFAULT case_separator inner_stmts .)
    CASE            reduce using rule 54 (case_stmt -> case_stmt DEFAULT case_separator inner_stmts .)
    DEFAULT         reduce using rule 54 (case_stmt -> case_stmt DEFAULT case_separator inner_stmts .)
    ENDSWITCH       reduce using rule 54 (case_stmt -> case_stmt DEFAULT case_separator inner_stmts .)
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    FUNCTION        shift and go to state 24
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    inner_stmt                     shift and go to state 162
    func_decl                      shift and go to state 161
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 160
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 367

    (51) switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .

    VAR             reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    WHILE           reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    DO              reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    FOR             reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    FOREACH         reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    SWITCH          reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    BREAK           reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    CONTINUE        reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    RETURN          reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    GLOBAL          reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    STATIC          reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ECHO            reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    LBRACE          reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    SEMICOLON       reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    FUNCTION        reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    CLONE           reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ARRAY           reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    PLUS            reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    MINUS           reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    BIT_NOT         reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    NOT             reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    CONST_DECIMAL   reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    CONST_DOUBLE    reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    CONST_STRING    reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    NULL            reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    TRUE            reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    FALSE           reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    INC             reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    DEC             reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    EMPTY           reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    EVAL            reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    LPAREN          reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    INCLUDE         reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    REQUIRE         reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    EXIT            reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    PRINT           reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    IF              reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    STRING          reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    $end            reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    RBRACE          reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ENDIF           reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ELSE            reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ELSEIF          reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ENDWHILE        reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ENDFOREACH      reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    CASE            reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    DEFAULT         reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ENDSWITCH       reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ENDFOR          reduce using rule 51 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)



state 368

    (46) foreach_stmt -> COLON inner_stmts ENDFOREACH . SEMICOLON

    SEMICOLON       shift and go to state 372



state 369

    (111) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar DOUBLE_ARROW scalar .

    COMMA           reduce using rule 111 (scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar DOUBLE_ARROW scalar .)
    RPAREN          reduce using rule 111 (scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar DOUBLE_ARROW scalar .)



state 370

    (39) for_stmt -> COLON inner_stmts . ENDFOR SEMICOLON
    (77) inner_stmts -> inner_stmts . inner_stmt
    (79) inner_stmt -> . stmt
    (80) inner_stmt -> . func_decl
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (11) func_decl -> . FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    ENDFOR          shift and go to state 373
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    FUNCTION        shift and go to state 24
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    inner_stmt                     shift and go to state 162
    func_decl                      shift and go to state 161
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 160
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 371

    (53) case_stmt -> case_stmt CASE expr case_separator inner_stmts .
    (77) inner_stmts -> inner_stmts . inner_stmt
    (79) inner_stmt -> . stmt
    (80) inner_stmt -> . func_decl
    (19) stmt -> . if_stmt
    (20) stmt -> . alt_if_stmt
    (29) stmt -> . WHILE LPAREN expr RPAREN while_stmt
    (32) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt -> . FOR LPAREN for_expr SEMICOLON for_expr SEMICOLON for_expr RPAREN for_stmt
    (40) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (47) stmt -> . SWITCH LPAREN expr RPAREN switch_stmt
    (57) stmt -> . BREAK SEMICOLON
    (58) stmt -> . BREAK expr SEMICOLON
    (59) stmt -> . CONTINUE SEMICOLON
    (60) stmt -> . CONTINUE expr SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . RETURN expr SEMICOLON
    (63) stmt -> . GLOBAL global_var_list SEMICOLON
    (66) stmt -> . STATIC static_var_list SEMICOLON
    (71) stmt -> . ECHO echo_expr_list SEMICOLON
    (74) stmt -> . LBRACE inner_stmts RBRACE
    (75) stmt -> . SEMICOLON
    (76) stmt -> . expr SEMICOLON
    (11) func_decl -> . FUNCTION STRING LPAREN params RPAREN LBRACE inner_stmts RBRACE
    (21) if_stmt -> . if_stmt_without_else
    (22) if_stmt -> . if_stmt_without_else ELSE stmt
    (25) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (26) alt_if_stmt -> . alt_if_stmt_without_else ELSE COLON inner_stmts ENDIF SEMICOLON
    (81) expr -> . variable
    (95) expr -> . variable EQUAL expr
    (96) expr -> . variable EQUAL BIT_AND expr
    (97) expr -> . CLONE expr
    (113) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (126) expr -> . variable PLUS_EQ expr
    (127) expr -> . variable MINUS_EQ expr
    (128) expr -> . variable MULTIPLY_EQ expr
    (129) expr -> . variable DIVIDE_EQ expr
    (130) expr -> . variable DOT_EQ expr
    (131) expr -> . variable MOD_EQ expr
    (132) expr -> . expr AND_OP expr
    (133) expr -> . expr OR_OP expr
    (134) expr -> . expr BIT_OR expr
    (135) expr -> . expr BIT_XOR expr
    (136) expr -> . expr BIT_AND expr
    (137) expr -> . expr DOT expr
    (138) expr -> . expr PLUS expr
    (139) expr -> . expr MINUS expr
    (140) expr -> . expr MULT expr
    (141) expr -> . expr DIV expr
    (142) expr -> . expr BIT_LSHIFT expr
    (143) expr -> . expr BIT_RSHIFT expr
    (144) expr -> . expr MOD expr
    (145) expr -> . expr IDENTICAL expr
    (146) expr -> . expr NOT_IDENTICAL expr
    (147) expr -> . expr EQ_EQ expr
    (148) expr -> . expr NOT_EQ expr
    (149) expr -> . expr LESSER expr
    (150) expr -> . expr LESSER_EQ expr
    (151) expr -> . expr GREATER expr
    (152) expr -> . expr GREATER_EQ expr
    (153) expr -> . expr INSTANCEOF expr
    (154) expr -> . PLUS expr
    (155) expr -> . MINUS expr
    (156) expr -> . BIT_NOT expr
    (157) expr -> . NOT expr
    (158) expr -> . CONST_DECIMAL
    (159) expr -> . CONST_DOUBLE
    (160) expr -> . CONST_STRING
    (161) expr -> . NULL
    (162) expr -> . TRUE
    (163) expr -> . FALSE
    (164) expr -> . expr COND_OP expr COLON expr
    (165) expr -> . INC variable
    (166) expr -> . DEC variable
    (167) expr -> . variable INC
    (168) expr -> . variable DEC
    (169) expr -> . EMPTY LPAREN expr RPAREN
    (170) expr -> . EVAL LPAREN expr RPAREN
    (171) expr -> . LPAREN expr RPAREN
    (172) expr -> . INCLUDE expr
    (173) expr -> . INCLUDE_ONCE expr
    (174) expr -> . REQUIRE expr
    (175) expr -> . REQUIRE_ONCE expr
    (176) expr -> . EXIT
    (177) expr -> . EXIT LPAREN RPAREN
    (178) expr -> . EXIT LPAREN expr RPAREN
    (179) expr -> . PRINT expr
    (23) if_stmt_without_else -> . IF LPAREN expr RPAREN stmt
    (24) if_stmt_without_else -> . if_stmt_without_else ELSEIF LPAREN expr RPAREN stmt
    (27) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON inner_stmts
    (28) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF LPAREN expr RPAREN COLON inner_stmts
    (82) variable -> . base_var
    (83) variable -> . func_call
    (90) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (91) base_var -> . base_var LBRACE expr RBRACE
    (92) base_var -> . IDENTIFIER
    (84) func_call -> . STRING LPAREN func_params RPAREN

    RBRACE          reduce using rule 53 (case_stmt -> case_stmt CASE expr case_separator inner_stmts .)
    CASE            reduce using rule 53 (case_stmt -> case_stmt CASE expr case_separator inner_stmts .)
    DEFAULT         reduce using rule 53 (case_stmt -> case_stmt CASE expr case_separator inner_stmts .)
    ENDSWITCH       reduce using rule 53 (case_stmt -> case_stmt CASE expr case_separator inner_stmts .)
    WHILE           shift and go to state 34
    DO              shift and go to state 49
    FOR             shift and go to state 25
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 37
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 31
    RETURN          shift and go to state 17
    GLOBAL          shift and go to state 33
    STATIC          shift and go to state 19
    ECHO            shift and go to state 28
    LBRACE          shift and go to state 30
    SEMICOLON       shift and go to state 36
    FUNCTION        shift and go to state 24
    CLONE           shift and go to state 15
    ARRAY           shift and go to state 38
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 32
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 23
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 55
    DEC             shift and go to state 21
    EMPTY           shift and go to state 22
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 35
    INCLUDE_ONCE    shift and go to state 13
    REQUIRE         shift and go to state 18
    REQUIRE_ONCE    shift and go to state 29
    EXIT            shift and go to state 48
    PRINT           shift and go to state 20
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    inner_stmt                     shift and go to state 162
    func_decl                      shift and go to state 161
    alt_if_stmt                    shift and go to state 26
    stmt                           shift and go to state 160
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 14
    expr                           shift and go to state 45

state 372

    (46) foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .

    VAR             reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    WHILE           reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    DO              reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    FOR             reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    FOREACH         reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    SWITCH          reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    BREAK           reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    CONTINUE        reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    RETURN          reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    GLOBAL          reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    STATIC          reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ECHO            reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    LBRACE          reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    SEMICOLON       reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    FUNCTION        reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    CLONE           reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ARRAY           reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    PLUS            reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    MINUS           reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    BIT_NOT         reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    NOT             reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    CONST_DECIMAL   reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    CONST_DOUBLE    reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    CONST_STRING    reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    NULL            reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    TRUE            reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    FALSE           reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    INC             reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    DEC             reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    EMPTY           reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    EVAL            reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    LPAREN          reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    INCLUDE         reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    REQUIRE         reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    EXIT            reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    PRINT           reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    IF              reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    IDENTIFIER      reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    STRING          reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    $end            reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    RBRACE          reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ENDIF           reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ELSE            reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ELSEIF          reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ENDWHILE        reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ENDFOREACH      reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    CASE            reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    DEFAULT         reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ENDSWITCH       reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ENDFOR          reduce using rule 46 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)



state 373

    (39) for_stmt -> COLON inner_stmts ENDFOR . SEMICOLON

    SEMICOLON       shift and go to state 374



state 374

    (39) for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .

    VAR             reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    WHILE           reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    DO              reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    FOR             reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    FOREACH         reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    SWITCH          reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    BREAK           reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    CONTINUE        reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    RETURN          reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    GLOBAL          reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    STATIC          reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ECHO            reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    LBRACE          reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    SEMICOLON       reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    FUNCTION        reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    CLONE           reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ARRAY           reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    PLUS            reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    MINUS           reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    BIT_NOT         reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    NOT             reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    CONST_DECIMAL   reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    CONST_DOUBLE    reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    CONST_STRING    reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    NULL            reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    TRUE            reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    FALSE           reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    INC             reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    DEC             reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    EMPTY           reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    EVAL            reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    LPAREN          reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    INCLUDE         reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    REQUIRE         reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    EXIT            reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    PRINT           reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    IF              reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    IDENTIFIER      reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    STRING          reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    $end            reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    RBRACE          reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ENDIF           reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ELSE            reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ELSEIF          reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ENDWHILE        reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ENDFOREACH      reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    CASE            reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    DEFAULT         reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ENDSWITCH       reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ENDFOR          reduce using rule 39 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)


