shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 114 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 119 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.
shift/reduce conflict in state 154 resolved as shift.


Unused terminals:

   COND_OP
   PROTECTED
   TRUE
   __HALT_COMPILER
   CONST_DECIMAL
   CONST_BINARY
   GOTO
   NAMESPACE
   __CLASS__
   __LINE__
   CALLABLE
   EXTENDS
   FOREACH
   ENDIF
   VAR
   DECLARE
   TRAIT
   ISSET
   INSTEADOF
   ACCESS_OP
   CONST_OCTAL
   INTERFACE
   OR
   RETURN
   STATIC
   FINAL
   ENDFOREACH
   CONST_DOUBLE
   ENDSWITCH
   COND_COLON
   FUNCTION
   FOR
   ECHO
   TRY
   ELSEIF
   ENDWHILE
   ENDDECLARE
   CONTINUE
   DEFAULT
   GLOBAL
   ELSE
   WHILE
   NEW
   END_TAG
   CASE
   EXPONENT
   START_TAG
   SWITCH
   ENDFOR
   CATCH
   __METHOD__
   IMPLEMENTS
   FALSE
   CONST_STRING
   BREAK
   PUBLIC
   DO
   USE
   CONST
   DIE
   ABSTRACT
   NULL
   UNSET
   CONST_HEX
   PRIVATE
   CLASS
   __DIR__
   XOR
   __FILE__
   AS
   IF
   __FUNCTION__
   __TRAIT__
   __NAMESPACE__
   THROW

Grammar

Rule 1     start -> top_statement_list
Rule 2     top_statement_list -> top_statement_list top_statement
Rule 3     top_statement_list -> empty
Rule 4     top_statement -> statement
Rule 5     statement -> expr SEMICOLON
Rule 6     expr -> variable
Rule 7     variable -> base_variable_with_function_calls
Rule 8     base_variable_with_function_calls -> base_variable
Rule 9     base_variable -> simple_indirect_reference
Rule 10    simple_indirect_reference -> reference_variable
Rule 11    reference_variable -> reference_variable LBRACKET dim_offset RBRACKET
Rule 12    reference_variable -> reference_variable LBRACE expr RBRACE
Rule 13    reference_variable -> compound_variable
Rule 14    compound_variable -> IDENTIFIER
Rule 15    dim_offset -> expr
Rule 16    dim_offset -> empty
Rule 17    expr -> variable EQUAL expr
Rule 18    expr -> variable EQUAL BIT_AND expr
Rule 19    expr -> CLONE expr
Rule 20    expr -> LIST LPAREN assignment_list RPAREN EQUAL expr
Rule 21    assignment_list -> assignment_list COMMA assignment_list_element
Rule 22    assignment_list -> assignment_list_element
Rule 23    assignment_list_element -> variable
Rule 24    assignment_list_element -> empty
Rule 25    assignment_list_element -> LIST LPAREN assignment_list RPAREN
Rule 26    expr -> ARRAY LPAREN array_pair_list RPAREN
Rule 27    array_pair_list -> empty
Rule 28    array_pair_list -> non_empty_array_pair_list possible_comma
Rule 29    non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND variable
Rule 30    non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr
Rule 31    non_empty_array_pair_list -> BIT_AND variable
Rule 32    non_empty_array_pair_list -> expr
Rule 33    possible_comma -> empty
Rule 34    possible_comma -> COMMA
Rule 35    expr -> variable PLUS_EQ expr
Rule 36    expr -> variable MINUS_EQ expr
Rule 37    expr -> variable MULTIPLY_EQ expr
Rule 38    expr -> variable DIVIDE_EQ expr
Rule 39    expr -> variable DOT_EQ expr
Rule 40    expr -> variable MOD_EQ expr
Rule 41    expr -> expr AND_OP expr
Rule 42    expr -> expr OR_OP expr
Rule 43    expr -> expr AND expr
Rule 44    expr -> expr BIT_OR expr
Rule 45    expr -> expr BIT_XOR expr
Rule 46    expr -> expr DOT expr
Rule 47    expr -> expr PLUS expr
Rule 48    expr -> expr MINUS expr
Rule 49    expr -> expr MULT expr
Rule 50    expr -> expr DIV expr
Rule 51    expr -> expr BIT_LSHIFT expr
Rule 52    expr -> expr BIT_RSHIFT expr
Rule 53    expr -> expr MOD expr
Rule 54    expr -> expr IDENTICAL expr
Rule 55    expr -> expr NOT_IDENTICAL expr
Rule 56    expr -> expr EQ_EQ expr
Rule 57    expr -> expr NOT_EQ expr
Rule 58    expr -> expr LESSER expr
Rule 59    expr -> expr LESSER_EQ expr
Rule 60    expr -> expr GREATER expr
Rule 61    expr -> expr GREATER_EQ expr
Rule 62    expr -> expr INSTANCEOF expr
Rule 63    expr -> PLUS expr
Rule 64    expr -> MINUS expr
Rule 65    expr -> BIT_NOT expr
Rule 66    expr -> NOT expr
Rule 67    expr -> INC variable
Rule 68    expr -> DEC variable
Rule 69    expr -> variable INC
Rule 70    expr -> variable DEC
Rule 71    expr -> EMPTY LPAREN expr RPAREN
Rule 72    expr -> EVAL LPAREN expr RPAREN
Rule 73    expr -> LPAREN expr RPAREN
Rule 74    expr -> INCLUDE expr
Rule 75    expr -> INCLUDE_ONCE expr
Rule 76    expr -> REQUIRE expr
Rule 77    expr -> REQUIRE_ONCE expr
Rule 78    expr -> EXIT
Rule 79    expr -> EXIT LPAREN RPAREN
Rule 80    expr -> EXIT LPAREN expr RPAREN
Rule 81    expr -> PRINT expr
Rule 82    empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
ACCESS_OP            : 
AND                  : 43
AND_OP               : 41
ARRAY                : 26
AS                   : 
BIT_AND              : 18 29 31
BIT_LSHIFT           : 51
BIT_NOT              : 65
BIT_OR               : 44
BIT_RSHIFT           : 52
BIT_XOR              : 45
BREAK                : 
CALLABLE             : 
CASE                 : 
CATCH                : 
CLASS                : 
CLONE                : 19
COMMA                : 21 29 30 34
COND_COLON           : 
COND_OP              : 
CONST                : 
CONST_BINARY         : 
CONST_DECIMAL        : 
CONST_DOUBLE         : 
CONST_HEX            : 
CONST_OCTAL          : 
CONST_STRING         : 
CONTINUE             : 
DEC                  : 68 70
DECLARE              : 
DEFAULT              : 
DIE                  : 
DIV                  : 50
DIVIDE_EQ            : 38
DO                   : 
DOT                  : 46
DOT_EQ               : 39
ECHO                 : 
ELSE                 : 
ELSEIF               : 
EMPTY                : 71
ENDDECLARE           : 
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
ENDSWITCH            : 
ENDWHILE             : 
END_TAG              : 
EQUAL                : 17 18 20
EQ_EQ                : 56
EVAL                 : 72
EXIT                 : 78 79 80
EXPONENT             : 
EXTENDS              : 
FALSE                : 
FINAL                : 
FOR                  : 
FOREACH              : 
FUNCTION             : 
GLOBAL               : 
GOTO                 : 
GREATER              : 60
GREATER_EQ           : 61
IDENTICAL            : 54
IDENTIFIER           : 14
IF                   : 
IMPLEMENTS           : 
INC                  : 67 69
INCLUDE              : 74
INCLUDE_ONCE         : 75
INSTANCEOF           : 62
INSTEADOF            : 
INTERFACE            : 
ISSET                : 
LBRACE               : 12
LBRACKET             : 11
LESSER               : 58
LESSER_EQ            : 59
LIST                 : 20 25
LPAREN               : 20 25 26 71 72 73 79 80
MINUS                : 48 64
MINUS_EQ             : 36
MOD                  : 53
MOD_EQ               : 40
MULT                 : 49
MULTIPLY_EQ          : 37
NAMESPACE            : 
NEW                  : 
NOT                  : 66
NOT_EQ               : 57
NOT_IDENTICAL        : 55
NULL                 : 
OR                   : 
OR_OP                : 42
PLUS                 : 47 63
PLUS_EQ              : 35
PRINT                : 81
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
RBRACE               : 12
RBRACKET             : 11
REQUIRE              : 76
REQUIRE_ONCE         : 77
RETURN               : 
RPAREN               : 20 25 26 71 72 73 79 80
SEMICOLON            : 5
START_TAG            : 
STATIC               : 
SWITCH               : 
THROW                : 
TRAIT                : 
TRUE                 : 
TRY                  : 
UNSET                : 
USE                  : 
VAR                  : 
WHILE                : 
XOR                  : 
__CLASS__            : 
__DIR__              : 
__FILE__             : 
__FUNCTION__         : 
__HALT_COMPILER      : 
__LINE__             : 
__METHOD__           : 
__NAMESPACE__        : 
__TRAIT__            : 
error                : 

Nonterminals, with rules where they appear

array_pair_list      : 26
assignment_list      : 20 21 25
assignment_list_element : 21 22
base_variable        : 8
base_variable_with_function_calls : 7
compound_variable    : 13
dim_offset           : 11
empty                : 3 16 24 27 33
expr                 : 5 12 15 17 18 19 20 30 32 35 36 37 38 39 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 64 65 66 71 72 73 74 75 76 77 80 81
non_empty_array_pair_list : 28 29 30
possible_comma       : 28
reference_variable   : 10 11 12
simple_indirect_reference : 9
start                : 0
statement            : 4
top_statement        : 2
top_statement_list   : 1 2
variable             : 6 17 18 23 29 31 35 36 37 38 39 40 67 68 69 70


Parsing method: LALR


state 0

    (0) S' -> . start
    (1) start -> . top_statement_list
    (2) top_statement_list -> . top_statement_list top_statement
    (3) top_statement_list -> . empty
    (82) empty -> .

    CLONE           reduce using rule 82 (empty -> .)
    LIST            reduce using rule 82 (empty -> .)
    ARRAY           reduce using rule 82 (empty -> .)
    PLUS            reduce using rule 82 (empty -> .)
    MINUS           reduce using rule 82 (empty -> .)
    BIT_NOT         reduce using rule 82 (empty -> .)
    NOT             reduce using rule 82 (empty -> .)
    INC             reduce using rule 82 (empty -> .)
    DEC             reduce using rule 82 (empty -> .)
    EMPTY           reduce using rule 82 (empty -> .)
    EVAL            reduce using rule 82 (empty -> .)
    LPAREN          reduce using rule 82 (empty -> .)
    INCLUDE         reduce using rule 82 (empty -> .)
    INCLUDE_ONCE    reduce using rule 82 (empty -> .)
    REQUIRE         reduce using rule 82 (empty -> .)
    REQUIRE_ONCE    reduce using rule 82 (empty -> .)
    EXIT            reduce using rule 82 (empty -> .)
    PRINT           reduce using rule 82 (empty -> .)
    IDENTIFIER      reduce using rule 82 (empty -> .)
    $end            reduce using rule 82 (empty -> .)


    top_statement_list             shift and go to state 1
    start                          shift and go to state 2
    empty                          shift and go to state 3

state 1

    (1) start -> top_statement_list .
    (2) top_statement_list -> top_statement_list . top_statement
    (4) top_statement -> . statement
    (5) statement -> . expr SEMICOLON
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    $end            reduce using rule 1 (start -> top_statement_list .)
    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    simple_indirect_reference      shift and go to state 14
    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 25
    variable                       shift and go to state 21
    base_variable_with_function_calls shift and go to state 11
    statement                      shift and go to state 13
    reference_variable             shift and go to state 6
    top_statement                  shift and go to state 31

state 2

    (0) S' -> start .




state 3

    (3) top_statement_list -> empty .

    CLONE           reduce using rule 3 (top_statement_list -> empty .)
    LIST            reduce using rule 3 (top_statement_list -> empty .)
    ARRAY           reduce using rule 3 (top_statement_list -> empty .)
    PLUS            reduce using rule 3 (top_statement_list -> empty .)
    MINUS           reduce using rule 3 (top_statement_list -> empty .)
    BIT_NOT         reduce using rule 3 (top_statement_list -> empty .)
    NOT             reduce using rule 3 (top_statement_list -> empty .)
    INC             reduce using rule 3 (top_statement_list -> empty .)
    DEC             reduce using rule 3 (top_statement_list -> empty .)
    EMPTY           reduce using rule 3 (top_statement_list -> empty .)
    EVAL            reduce using rule 3 (top_statement_list -> empty .)
    LPAREN          reduce using rule 3 (top_statement_list -> empty .)
    INCLUDE         reduce using rule 3 (top_statement_list -> empty .)
    INCLUDE_ONCE    reduce using rule 3 (top_statement_list -> empty .)
    REQUIRE         reduce using rule 3 (top_statement_list -> empty .)
    REQUIRE_ONCE    reduce using rule 3 (top_statement_list -> empty .)
    EXIT            reduce using rule 3 (top_statement_list -> empty .)
    PRINT           reduce using rule 3 (top_statement_list -> empty .)
    IDENTIFIER      reduce using rule 3 (top_statement_list -> empty .)
    $end            reduce using rule 3 (top_statement_list -> empty .)



state 4

    (72) expr -> EVAL . LPAREN expr RPAREN

    LPAREN          shift and go to state 32



state 5

    (65) expr -> BIT_NOT . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 33
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 6

    (10) simple_indirect_reference -> reference_variable .
    (11) reference_variable -> reference_variable . LBRACKET dim_offset RBRACKET
    (12) reference_variable -> reference_variable . LBRACE expr RBRACE

    EQUAL           reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    PLUS_EQ         reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    MINUS_EQ        reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    MULTIPLY_EQ     reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    DIVIDE_EQ       reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    DOT_EQ          reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    MOD_EQ          reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    INC             reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    DEC             reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    SEMICOLON       reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    AND_OP          reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    OR_OP           reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    AND             reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    BIT_OR          reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    BIT_XOR         reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    DOT             reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    PLUS            reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    MINUS           reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    MULT            reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    DIV             reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    BIT_LSHIFT      reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    BIT_RSHIFT      reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    MOD             reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    IDENTICAL       reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    NOT_IDENTICAL   reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    EQ_EQ           reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    NOT_EQ          reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    LESSER          reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    LESSER_EQ       reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    GREATER         reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    GREATER_EQ      reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    INSTANCEOF      reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    RPAREN          reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    RBRACE          reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    RBRACKET        reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    COMMA           reduce using rule 10 (simple_indirect_reference -> reference_variable .)
    LBRACKET        shift and go to state 35
    LBRACE          shift and go to state 34



state 7

    (81) expr -> PRINT . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 36
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 8

    (68) expr -> DEC . variable
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 37

state 9

    (64) expr -> MINUS . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 38
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 10

    (74) expr -> INCLUDE . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 39
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 11

    (7) variable -> base_variable_with_function_calls .

    COMMA           reduce using rule 7 (variable -> base_variable_with_function_calls .)
    RPAREN          reduce using rule 7 (variable -> base_variable_with_function_calls .)
    SEMICOLON       reduce using rule 7 (variable -> base_variable_with_function_calls .)
    AND_OP          reduce using rule 7 (variable -> base_variable_with_function_calls .)
    OR_OP           reduce using rule 7 (variable -> base_variable_with_function_calls .)
    AND             reduce using rule 7 (variable -> base_variable_with_function_calls .)
    BIT_OR          reduce using rule 7 (variable -> base_variable_with_function_calls .)
    BIT_XOR         reduce using rule 7 (variable -> base_variable_with_function_calls .)
    DOT             reduce using rule 7 (variable -> base_variable_with_function_calls .)
    PLUS            reduce using rule 7 (variable -> base_variable_with_function_calls .)
    MINUS           reduce using rule 7 (variable -> base_variable_with_function_calls .)
    MULT            reduce using rule 7 (variable -> base_variable_with_function_calls .)
    DIV             reduce using rule 7 (variable -> base_variable_with_function_calls .)
    BIT_LSHIFT      reduce using rule 7 (variable -> base_variable_with_function_calls .)
    BIT_RSHIFT      reduce using rule 7 (variable -> base_variable_with_function_calls .)
    MOD             reduce using rule 7 (variable -> base_variable_with_function_calls .)
    IDENTICAL       reduce using rule 7 (variable -> base_variable_with_function_calls .)
    NOT_IDENTICAL   reduce using rule 7 (variable -> base_variable_with_function_calls .)
    EQ_EQ           reduce using rule 7 (variable -> base_variable_with_function_calls .)
    NOT_EQ          reduce using rule 7 (variable -> base_variable_with_function_calls .)
    LESSER          reduce using rule 7 (variable -> base_variable_with_function_calls .)
    LESSER_EQ       reduce using rule 7 (variable -> base_variable_with_function_calls .)
    GREATER         reduce using rule 7 (variable -> base_variable_with_function_calls .)
    GREATER_EQ      reduce using rule 7 (variable -> base_variable_with_function_calls .)
    INSTANCEOF      reduce using rule 7 (variable -> base_variable_with_function_calls .)
    RBRACE          reduce using rule 7 (variable -> base_variable_with_function_calls .)
    RBRACKET        reduce using rule 7 (variable -> base_variable_with_function_calls .)
    EQUAL           reduce using rule 7 (variable -> base_variable_with_function_calls .)
    PLUS_EQ         reduce using rule 7 (variable -> base_variable_with_function_calls .)
    MINUS_EQ        reduce using rule 7 (variable -> base_variable_with_function_calls .)
    MULTIPLY_EQ     reduce using rule 7 (variable -> base_variable_with_function_calls .)
    DIVIDE_EQ       reduce using rule 7 (variable -> base_variable_with_function_calls .)
    DOT_EQ          reduce using rule 7 (variable -> base_variable_with_function_calls .)
    MOD_EQ          reduce using rule 7 (variable -> base_variable_with_function_calls .)
    INC             reduce using rule 7 (variable -> base_variable_with_function_calls .)
    DEC             reduce using rule 7 (variable -> base_variable_with_function_calls .)



state 12

    (63) expr -> PLUS . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 40
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 13

    (4) top_statement -> statement .

    CLONE           reduce using rule 4 (top_statement -> statement .)
    LIST            reduce using rule 4 (top_statement -> statement .)
    ARRAY           reduce using rule 4 (top_statement -> statement .)
    PLUS            reduce using rule 4 (top_statement -> statement .)
    MINUS           reduce using rule 4 (top_statement -> statement .)
    BIT_NOT         reduce using rule 4 (top_statement -> statement .)
    NOT             reduce using rule 4 (top_statement -> statement .)
    INC             reduce using rule 4 (top_statement -> statement .)
    DEC             reduce using rule 4 (top_statement -> statement .)
    EMPTY           reduce using rule 4 (top_statement -> statement .)
    EVAL            reduce using rule 4 (top_statement -> statement .)
    LPAREN          reduce using rule 4 (top_statement -> statement .)
    INCLUDE         reduce using rule 4 (top_statement -> statement .)
    INCLUDE_ONCE    reduce using rule 4 (top_statement -> statement .)
    REQUIRE         reduce using rule 4 (top_statement -> statement .)
    REQUIRE_ONCE    reduce using rule 4 (top_statement -> statement .)
    EXIT            reduce using rule 4 (top_statement -> statement .)
    PRINT           reduce using rule 4 (top_statement -> statement .)
    IDENTIFIER      reduce using rule 4 (top_statement -> statement .)
    $end            reduce using rule 4 (top_statement -> statement .)



state 14

    (9) base_variable -> simple_indirect_reference .

    EQUAL           reduce using rule 9 (base_variable -> simple_indirect_reference .)
    PLUS_EQ         reduce using rule 9 (base_variable -> simple_indirect_reference .)
    MINUS_EQ        reduce using rule 9 (base_variable -> simple_indirect_reference .)
    MULTIPLY_EQ     reduce using rule 9 (base_variable -> simple_indirect_reference .)
    DIVIDE_EQ       reduce using rule 9 (base_variable -> simple_indirect_reference .)
    DOT_EQ          reduce using rule 9 (base_variable -> simple_indirect_reference .)
    MOD_EQ          reduce using rule 9 (base_variable -> simple_indirect_reference .)
    INC             reduce using rule 9 (base_variable -> simple_indirect_reference .)
    DEC             reduce using rule 9 (base_variable -> simple_indirect_reference .)
    AND_OP          reduce using rule 9 (base_variable -> simple_indirect_reference .)
    OR_OP           reduce using rule 9 (base_variable -> simple_indirect_reference .)
    AND             reduce using rule 9 (base_variable -> simple_indirect_reference .)
    BIT_OR          reduce using rule 9 (base_variable -> simple_indirect_reference .)
    BIT_XOR         reduce using rule 9 (base_variable -> simple_indirect_reference .)
    DOT             reduce using rule 9 (base_variable -> simple_indirect_reference .)
    PLUS            reduce using rule 9 (base_variable -> simple_indirect_reference .)
    MINUS           reduce using rule 9 (base_variable -> simple_indirect_reference .)
    MULT            reduce using rule 9 (base_variable -> simple_indirect_reference .)
    DIV             reduce using rule 9 (base_variable -> simple_indirect_reference .)
    BIT_LSHIFT      reduce using rule 9 (base_variable -> simple_indirect_reference .)
    BIT_RSHIFT      reduce using rule 9 (base_variable -> simple_indirect_reference .)
    MOD             reduce using rule 9 (base_variable -> simple_indirect_reference .)
    IDENTICAL       reduce using rule 9 (base_variable -> simple_indirect_reference .)
    NOT_IDENTICAL   reduce using rule 9 (base_variable -> simple_indirect_reference .)
    EQ_EQ           reduce using rule 9 (base_variable -> simple_indirect_reference .)
    NOT_EQ          reduce using rule 9 (base_variable -> simple_indirect_reference .)
    LESSER          reduce using rule 9 (base_variable -> simple_indirect_reference .)
    LESSER_EQ       reduce using rule 9 (base_variable -> simple_indirect_reference .)
    GREATER         reduce using rule 9 (base_variable -> simple_indirect_reference .)
    GREATER_EQ      reduce using rule 9 (base_variable -> simple_indirect_reference .)
    INSTANCEOF      reduce using rule 9 (base_variable -> simple_indirect_reference .)
    SEMICOLON       reduce using rule 9 (base_variable -> simple_indirect_reference .)
    RPAREN          reduce using rule 9 (base_variable -> simple_indirect_reference .)
    RBRACE          reduce using rule 9 (base_variable -> simple_indirect_reference .)
    RBRACKET        reduce using rule 9 (base_variable -> simple_indirect_reference .)
    COMMA           reduce using rule 9 (base_variable -> simple_indirect_reference .)



state 15

    (26) expr -> ARRAY . LPAREN array_pair_list RPAREN

    LPAREN          shift and go to state 41



state 16

    (14) compound_variable -> IDENTIFIER .

    LBRACKET        reduce using rule 14 (compound_variable -> IDENTIFIER .)
    LBRACE          reduce using rule 14 (compound_variable -> IDENTIFIER .)
    EQUAL           reduce using rule 14 (compound_variable -> IDENTIFIER .)
    PLUS_EQ         reduce using rule 14 (compound_variable -> IDENTIFIER .)
    MINUS_EQ        reduce using rule 14 (compound_variable -> IDENTIFIER .)
    MULTIPLY_EQ     reduce using rule 14 (compound_variable -> IDENTIFIER .)
    DIVIDE_EQ       reduce using rule 14 (compound_variable -> IDENTIFIER .)
    DOT_EQ          reduce using rule 14 (compound_variable -> IDENTIFIER .)
    MOD_EQ          reduce using rule 14 (compound_variable -> IDENTIFIER .)
    INC             reduce using rule 14 (compound_variable -> IDENTIFIER .)
    DEC             reduce using rule 14 (compound_variable -> IDENTIFIER .)
    AND_OP          reduce using rule 14 (compound_variable -> IDENTIFIER .)
    OR_OP           reduce using rule 14 (compound_variable -> IDENTIFIER .)
    AND             reduce using rule 14 (compound_variable -> IDENTIFIER .)
    BIT_OR          reduce using rule 14 (compound_variable -> IDENTIFIER .)
    BIT_XOR         reduce using rule 14 (compound_variable -> IDENTIFIER .)
    DOT             reduce using rule 14 (compound_variable -> IDENTIFIER .)
    PLUS            reduce using rule 14 (compound_variable -> IDENTIFIER .)
    MINUS           reduce using rule 14 (compound_variable -> IDENTIFIER .)
    MULT            reduce using rule 14 (compound_variable -> IDENTIFIER .)
    DIV             reduce using rule 14 (compound_variable -> IDENTIFIER .)
    BIT_LSHIFT      reduce using rule 14 (compound_variable -> IDENTIFIER .)
    BIT_RSHIFT      reduce using rule 14 (compound_variable -> IDENTIFIER .)
    MOD             reduce using rule 14 (compound_variable -> IDENTIFIER .)
    IDENTICAL       reduce using rule 14 (compound_variable -> IDENTIFIER .)
    NOT_IDENTICAL   reduce using rule 14 (compound_variable -> IDENTIFIER .)
    EQ_EQ           reduce using rule 14 (compound_variable -> IDENTIFIER .)
    NOT_EQ          reduce using rule 14 (compound_variable -> IDENTIFIER .)
    LESSER          reduce using rule 14 (compound_variable -> IDENTIFIER .)
    LESSER_EQ       reduce using rule 14 (compound_variable -> IDENTIFIER .)
    GREATER         reduce using rule 14 (compound_variable -> IDENTIFIER .)
    GREATER_EQ      reduce using rule 14 (compound_variable -> IDENTIFIER .)
    INSTANCEOF      reduce using rule 14 (compound_variable -> IDENTIFIER .)
    SEMICOLON       reduce using rule 14 (compound_variable -> IDENTIFIER .)
    RPAREN          reduce using rule 14 (compound_variable -> IDENTIFIER .)
    RBRACE          reduce using rule 14 (compound_variable -> IDENTIFIER .)
    RBRACKET        reduce using rule 14 (compound_variable -> IDENTIFIER .)
    COMMA           reduce using rule 14 (compound_variable -> IDENTIFIER .)



state 17

    (76) expr -> REQUIRE . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 42
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 18

    (71) expr -> EMPTY . LPAREN expr RPAREN

    LPAREN          shift and go to state 43



state 19

    (8) base_variable_with_function_calls -> base_variable .

    EQUAL           reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    PLUS_EQ         reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    MINUS_EQ        reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    MULTIPLY_EQ     reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    DIVIDE_EQ       reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    DOT_EQ          reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    MOD_EQ          reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    INC             reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    DEC             reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    AND_OP          reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    OR_OP           reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    AND             reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    BIT_OR          reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    BIT_XOR         reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    DOT             reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    PLUS            reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    MINUS           reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    MULT            reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    DIV             reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    BIT_LSHIFT      reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    BIT_RSHIFT      reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    MOD             reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    IDENTICAL       reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    NOT_IDENTICAL   reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    EQ_EQ           reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    NOT_EQ          reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    LESSER          reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    LESSER_EQ       reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    GREATER         reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    GREATER_EQ      reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    INSTANCEOF      reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    COMMA           reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    RPAREN          reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    SEMICOLON       reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    RBRACE          reduce using rule 8 (base_variable_with_function_calls -> base_variable .)
    RBRACKET        reduce using rule 8 (base_variable_with_function_calls -> base_variable .)



state 20

    (73) expr -> LPAREN . expr RPAREN
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 44
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 21

    (6) expr -> variable .
    (17) expr -> variable . EQUAL expr
    (18) expr -> variable . EQUAL BIT_AND expr
    (35) expr -> variable . PLUS_EQ expr
    (36) expr -> variable . MINUS_EQ expr
    (37) expr -> variable . MULTIPLY_EQ expr
    (38) expr -> variable . DIVIDE_EQ expr
    (39) expr -> variable . DOT_EQ expr
    (40) expr -> variable . MOD_EQ expr
    (69) expr -> variable . INC
    (70) expr -> variable . DEC

    AND_OP          reduce using rule 6 (expr -> variable .)
    OR_OP           reduce using rule 6 (expr -> variable .)
    AND             reduce using rule 6 (expr -> variable .)
    BIT_OR          reduce using rule 6 (expr -> variable .)
    BIT_XOR         reduce using rule 6 (expr -> variable .)
    DOT             reduce using rule 6 (expr -> variable .)
    PLUS            reduce using rule 6 (expr -> variable .)
    MINUS           reduce using rule 6 (expr -> variable .)
    MULT            reduce using rule 6 (expr -> variable .)
    DIV             reduce using rule 6 (expr -> variable .)
    BIT_LSHIFT      reduce using rule 6 (expr -> variable .)
    BIT_RSHIFT      reduce using rule 6 (expr -> variable .)
    MOD             reduce using rule 6 (expr -> variable .)
    IDENTICAL       reduce using rule 6 (expr -> variable .)
    NOT_IDENTICAL   reduce using rule 6 (expr -> variable .)
    EQ_EQ           reduce using rule 6 (expr -> variable .)
    NOT_EQ          reduce using rule 6 (expr -> variable .)
    LESSER          reduce using rule 6 (expr -> variable .)
    LESSER_EQ       reduce using rule 6 (expr -> variable .)
    GREATER         reduce using rule 6 (expr -> variable .)
    GREATER_EQ      reduce using rule 6 (expr -> variable .)
    INSTANCEOF      reduce using rule 6 (expr -> variable .)
    SEMICOLON       reduce using rule 6 (expr -> variable .)
    RPAREN          reduce using rule 6 (expr -> variable .)
    RBRACE          reduce using rule 6 (expr -> variable .)
    RBRACKET        reduce using rule 6 (expr -> variable .)
    COMMA           reduce using rule 6 (expr -> variable .)
    EQUAL           shift and go to state 48
    PLUS_EQ         shift and go to state 49
    MINUS_EQ        shift and go to state 51
    MULTIPLY_EQ     shift and go to state 46
    DIVIDE_EQ       shift and go to state 50
    DOT_EQ          shift and go to state 45
    MOD_EQ          shift and go to state 52
    INC             shift and go to state 53
    DEC             shift and go to state 47



state 22

    (77) expr -> REQUIRE_ONCE . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 54
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 23

    (75) expr -> INCLUDE_ONCE . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 55
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 24

    (13) reference_variable -> compound_variable .

    LBRACKET        reduce using rule 13 (reference_variable -> compound_variable .)
    LBRACE          reduce using rule 13 (reference_variable -> compound_variable .)
    EQUAL           reduce using rule 13 (reference_variable -> compound_variable .)
    PLUS_EQ         reduce using rule 13 (reference_variable -> compound_variable .)
    MINUS_EQ        reduce using rule 13 (reference_variable -> compound_variable .)
    MULTIPLY_EQ     reduce using rule 13 (reference_variable -> compound_variable .)
    DIVIDE_EQ       reduce using rule 13 (reference_variable -> compound_variable .)
    DOT_EQ          reduce using rule 13 (reference_variable -> compound_variable .)
    MOD_EQ          reduce using rule 13 (reference_variable -> compound_variable .)
    INC             reduce using rule 13 (reference_variable -> compound_variable .)
    DEC             reduce using rule 13 (reference_variable -> compound_variable .)
    AND_OP          reduce using rule 13 (reference_variable -> compound_variable .)
    OR_OP           reduce using rule 13 (reference_variable -> compound_variable .)
    AND             reduce using rule 13 (reference_variable -> compound_variable .)
    BIT_OR          reduce using rule 13 (reference_variable -> compound_variable .)
    BIT_XOR         reduce using rule 13 (reference_variable -> compound_variable .)
    DOT             reduce using rule 13 (reference_variable -> compound_variable .)
    PLUS            reduce using rule 13 (reference_variable -> compound_variable .)
    MINUS           reduce using rule 13 (reference_variable -> compound_variable .)
    MULT            reduce using rule 13 (reference_variable -> compound_variable .)
    DIV             reduce using rule 13 (reference_variable -> compound_variable .)
    BIT_LSHIFT      reduce using rule 13 (reference_variable -> compound_variable .)
    BIT_RSHIFT      reduce using rule 13 (reference_variable -> compound_variable .)
    MOD             reduce using rule 13 (reference_variable -> compound_variable .)
    IDENTICAL       reduce using rule 13 (reference_variable -> compound_variable .)
    NOT_IDENTICAL   reduce using rule 13 (reference_variable -> compound_variable .)
    EQ_EQ           reduce using rule 13 (reference_variable -> compound_variable .)
    NOT_EQ          reduce using rule 13 (reference_variable -> compound_variable .)
    LESSER          reduce using rule 13 (reference_variable -> compound_variable .)
    LESSER_EQ       reduce using rule 13 (reference_variable -> compound_variable .)
    GREATER         reduce using rule 13 (reference_variable -> compound_variable .)
    GREATER_EQ      reduce using rule 13 (reference_variable -> compound_variable .)
    INSTANCEOF      reduce using rule 13 (reference_variable -> compound_variable .)
    COMMA           reduce using rule 13 (reference_variable -> compound_variable .)
    RPAREN          reduce using rule 13 (reference_variable -> compound_variable .)
    SEMICOLON       reduce using rule 13 (reference_variable -> compound_variable .)
    RBRACE          reduce using rule 13 (reference_variable -> compound_variable .)
    RBRACKET        reduce using rule 13 (reference_variable -> compound_variable .)



state 25

    (5) statement -> expr . SEMICOLON
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    SEMICOLON       shift and go to state 63
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    AND             shift and go to state 72
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    NOT_EQ          shift and go to state 67
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68



state 26

    (19) expr -> CLONE . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 79
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 27

    (20) expr -> LIST . LPAREN assignment_list RPAREN EQUAL expr

    LPAREN          shift and go to state 80



state 28

    (78) expr -> EXIT .
    (79) expr -> EXIT . LPAREN RPAREN
    (80) expr -> EXIT . LPAREN expr RPAREN

    AND_OP          reduce using rule 78 (expr -> EXIT .)
    OR_OP           reduce using rule 78 (expr -> EXIT .)
    AND             reduce using rule 78 (expr -> EXIT .)
    BIT_OR          reduce using rule 78 (expr -> EXIT .)
    BIT_XOR         reduce using rule 78 (expr -> EXIT .)
    DOT             reduce using rule 78 (expr -> EXIT .)
    PLUS            reduce using rule 78 (expr -> EXIT .)
    MINUS           reduce using rule 78 (expr -> EXIT .)
    MULT            reduce using rule 78 (expr -> EXIT .)
    DIV             reduce using rule 78 (expr -> EXIT .)
    BIT_LSHIFT      reduce using rule 78 (expr -> EXIT .)
    BIT_RSHIFT      reduce using rule 78 (expr -> EXIT .)
    MOD             reduce using rule 78 (expr -> EXIT .)
    IDENTICAL       reduce using rule 78 (expr -> EXIT .)
    NOT_IDENTICAL   reduce using rule 78 (expr -> EXIT .)
    EQ_EQ           reduce using rule 78 (expr -> EXIT .)
    NOT_EQ          reduce using rule 78 (expr -> EXIT .)
    LESSER          reduce using rule 78 (expr -> EXIT .)
    LESSER_EQ       reduce using rule 78 (expr -> EXIT .)
    GREATER         reduce using rule 78 (expr -> EXIT .)
    GREATER_EQ      reduce using rule 78 (expr -> EXIT .)
    INSTANCEOF      reduce using rule 78 (expr -> EXIT .)
    SEMICOLON       reduce using rule 78 (expr -> EXIT .)
    RPAREN          reduce using rule 78 (expr -> EXIT .)
    RBRACE          reduce using rule 78 (expr -> EXIT .)
    RBRACKET        reduce using rule 78 (expr -> EXIT .)
    COMMA           reduce using rule 78 (expr -> EXIT .)
    LPAREN          shift and go to state 81



state 29

    (66) expr -> NOT . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 82
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 30

    (67) expr -> INC . variable
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 83

state 31

    (2) top_statement_list -> top_statement_list top_statement .

    CLONE           reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    LIST            reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    ARRAY           reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    PLUS            reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    MINUS           reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    BIT_NOT         reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    NOT             reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    INC             reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    DEC             reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    EMPTY           reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    EVAL            reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    LPAREN          reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    INCLUDE         reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    INCLUDE_ONCE    reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    REQUIRE         reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    REQUIRE_ONCE    reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    EXIT            reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    PRINT           reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    IDENTIFIER      reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)
    $end            reduce using rule 2 (top_statement_list -> top_statement_list top_statement .)



state 32

    (72) expr -> EVAL LPAREN . expr RPAREN
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 84
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 33

    (65) expr -> BIT_NOT expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 65 (expr -> BIT_NOT expr .)
    OR_OP           reduce using rule 65 (expr -> BIT_NOT expr .)
    AND             reduce using rule 65 (expr -> BIT_NOT expr .)
    BIT_OR          reduce using rule 65 (expr -> BIT_NOT expr .)
    BIT_XOR         reduce using rule 65 (expr -> BIT_NOT expr .)
    DOT             reduce using rule 65 (expr -> BIT_NOT expr .)
    PLUS            reduce using rule 65 (expr -> BIT_NOT expr .)
    MINUS           reduce using rule 65 (expr -> BIT_NOT expr .)
    MULT            reduce using rule 65 (expr -> BIT_NOT expr .)
    DIV             reduce using rule 65 (expr -> BIT_NOT expr .)
    BIT_LSHIFT      reduce using rule 65 (expr -> BIT_NOT expr .)
    BIT_RSHIFT      reduce using rule 65 (expr -> BIT_NOT expr .)
    MOD             reduce using rule 65 (expr -> BIT_NOT expr .)
    NOT_EQ          reduce using rule 65 (expr -> BIT_NOT expr .)
    SEMICOLON       reduce using rule 65 (expr -> BIT_NOT expr .)
    RPAREN          reduce using rule 65 (expr -> BIT_NOT expr .)
    RBRACE          reduce using rule 65 (expr -> BIT_NOT expr .)
    RBRACKET        reduce using rule 65 (expr -> BIT_NOT expr .)
    COMMA           reduce using rule 65 (expr -> BIT_NOT expr .)
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! IDENTICAL       [ reduce using rule 65 (expr -> BIT_NOT expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 65 (expr -> BIT_NOT expr .) ]
  ! EQ_EQ           [ reduce using rule 65 (expr -> BIT_NOT expr .) ]
  ! LESSER          [ reduce using rule 65 (expr -> BIT_NOT expr .) ]
  ! LESSER_EQ       [ reduce using rule 65 (expr -> BIT_NOT expr .) ]
  ! GREATER         [ reduce using rule 65 (expr -> BIT_NOT expr .) ]
  ! GREATER_EQ      [ reduce using rule 65 (expr -> BIT_NOT expr .) ]
  ! INSTANCEOF      [ reduce using rule 65 (expr -> BIT_NOT expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 34

    (12) reference_variable -> reference_variable LBRACE . expr RBRACE
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 85
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 35

    (11) reference_variable -> reference_variable LBRACKET . dim_offset RBRACKET
    (15) dim_offset -> . expr
    (16) dim_offset -> . empty
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (82) empty -> .
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    RBRACKET        reduce using rule 82 (empty -> .)
    IDENTIFIER      shift and go to state 16


    dim_offset                     shift and go to state 87
    base_variable                  shift and go to state 19
    base_variable_with_function_calls shift and go to state 11
    compound_variable              shift and go to state 24
    expr                           shift and go to state 88
    simple_indirect_reference      shift and go to state 14
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21
    empty                          shift and go to state 86

state 36

    (81) expr -> PRINT expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 81 (expr -> PRINT expr .)
    OR_OP           reduce using rule 81 (expr -> PRINT expr .)
    AND             reduce using rule 81 (expr -> PRINT expr .)
    BIT_OR          reduce using rule 81 (expr -> PRINT expr .)
    BIT_XOR         reduce using rule 81 (expr -> PRINT expr .)
    DOT             reduce using rule 81 (expr -> PRINT expr .)
    PLUS            reduce using rule 81 (expr -> PRINT expr .)
    MINUS           reduce using rule 81 (expr -> PRINT expr .)
    MULT            reduce using rule 81 (expr -> PRINT expr .)
    DIV             reduce using rule 81 (expr -> PRINT expr .)
    BIT_LSHIFT      reduce using rule 81 (expr -> PRINT expr .)
    BIT_RSHIFT      reduce using rule 81 (expr -> PRINT expr .)
    MOD             reduce using rule 81 (expr -> PRINT expr .)
    NOT_EQ          reduce using rule 81 (expr -> PRINT expr .)
    SEMICOLON       reduce using rule 81 (expr -> PRINT expr .)
    RPAREN          reduce using rule 81 (expr -> PRINT expr .)
    RBRACE          reduce using rule 81 (expr -> PRINT expr .)
    RBRACKET        reduce using rule 81 (expr -> PRINT expr .)
    COMMA           reduce using rule 81 (expr -> PRINT expr .)
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! IDENTICAL       [ reduce using rule 81 (expr -> PRINT expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 81 (expr -> PRINT expr .) ]
  ! EQ_EQ           [ reduce using rule 81 (expr -> PRINT expr .) ]
  ! LESSER          [ reduce using rule 81 (expr -> PRINT expr .) ]
  ! LESSER_EQ       [ reduce using rule 81 (expr -> PRINT expr .) ]
  ! GREATER         [ reduce using rule 81 (expr -> PRINT expr .) ]
  ! GREATER_EQ      [ reduce using rule 81 (expr -> PRINT expr .) ]
  ! INSTANCEOF      [ reduce using rule 81 (expr -> PRINT expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 37

    (68) expr -> DEC variable .

    AND_OP          reduce using rule 68 (expr -> DEC variable .)
    OR_OP           reduce using rule 68 (expr -> DEC variable .)
    AND             reduce using rule 68 (expr -> DEC variable .)
    BIT_OR          reduce using rule 68 (expr -> DEC variable .)
    BIT_XOR         reduce using rule 68 (expr -> DEC variable .)
    DOT             reduce using rule 68 (expr -> DEC variable .)
    PLUS            reduce using rule 68 (expr -> DEC variable .)
    MINUS           reduce using rule 68 (expr -> DEC variable .)
    MULT            reduce using rule 68 (expr -> DEC variable .)
    DIV             reduce using rule 68 (expr -> DEC variable .)
    BIT_LSHIFT      reduce using rule 68 (expr -> DEC variable .)
    BIT_RSHIFT      reduce using rule 68 (expr -> DEC variable .)
    MOD             reduce using rule 68 (expr -> DEC variable .)
    IDENTICAL       reduce using rule 68 (expr -> DEC variable .)
    NOT_IDENTICAL   reduce using rule 68 (expr -> DEC variable .)
    EQ_EQ           reduce using rule 68 (expr -> DEC variable .)
    NOT_EQ          reduce using rule 68 (expr -> DEC variable .)
    LESSER          reduce using rule 68 (expr -> DEC variable .)
    LESSER_EQ       reduce using rule 68 (expr -> DEC variable .)
    GREATER         reduce using rule 68 (expr -> DEC variable .)
    GREATER_EQ      reduce using rule 68 (expr -> DEC variable .)
    INSTANCEOF      reduce using rule 68 (expr -> DEC variable .)
    SEMICOLON       reduce using rule 68 (expr -> DEC variable .)
    RPAREN          reduce using rule 68 (expr -> DEC variable .)
    RBRACE          reduce using rule 68 (expr -> DEC variable .)
    RBRACKET        reduce using rule 68 (expr -> DEC variable .)
    COMMA           reduce using rule 68 (expr -> DEC variable .)



state 38

    (64) expr -> MINUS expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 64 (expr -> MINUS expr .)
    OR_OP           reduce using rule 64 (expr -> MINUS expr .)
    AND             reduce using rule 64 (expr -> MINUS expr .)
    BIT_OR          reduce using rule 64 (expr -> MINUS expr .)
    BIT_XOR         reduce using rule 64 (expr -> MINUS expr .)
    DOT             reduce using rule 64 (expr -> MINUS expr .)
    PLUS            reduce using rule 64 (expr -> MINUS expr .)
    MINUS           reduce using rule 64 (expr -> MINUS expr .)
    MULT            reduce using rule 64 (expr -> MINUS expr .)
    DIV             reduce using rule 64 (expr -> MINUS expr .)
    BIT_LSHIFT      reduce using rule 64 (expr -> MINUS expr .)
    BIT_RSHIFT      reduce using rule 64 (expr -> MINUS expr .)
    MOD             reduce using rule 64 (expr -> MINUS expr .)
    NOT_EQ          reduce using rule 64 (expr -> MINUS expr .)
    SEMICOLON       reduce using rule 64 (expr -> MINUS expr .)
    RPAREN          reduce using rule 64 (expr -> MINUS expr .)
    RBRACE          reduce using rule 64 (expr -> MINUS expr .)
    RBRACKET        reduce using rule 64 (expr -> MINUS expr .)
    COMMA           reduce using rule 64 (expr -> MINUS expr .)
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! IDENTICAL       [ reduce using rule 64 (expr -> MINUS expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 64 (expr -> MINUS expr .) ]
  ! EQ_EQ           [ reduce using rule 64 (expr -> MINUS expr .) ]
  ! LESSER          [ reduce using rule 64 (expr -> MINUS expr .) ]
  ! LESSER_EQ       [ reduce using rule 64 (expr -> MINUS expr .) ]
  ! GREATER         [ reduce using rule 64 (expr -> MINUS expr .) ]
  ! GREATER_EQ      [ reduce using rule 64 (expr -> MINUS expr .) ]
  ! INSTANCEOF      [ reduce using rule 64 (expr -> MINUS expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 39

    (74) expr -> INCLUDE expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 74 (expr -> INCLUDE expr .)
    NOT_EQ          reduce using rule 74 (expr -> INCLUDE expr .)
    SEMICOLON       reduce using rule 74 (expr -> INCLUDE expr .)
    RPAREN          reduce using rule 74 (expr -> INCLUDE expr .)
    RBRACE          reduce using rule 74 (expr -> INCLUDE expr .)
    RBRACKET        reduce using rule 74 (expr -> INCLUDE expr .)
    COMMA           reduce using rule 74 (expr -> INCLUDE expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! OR_OP           [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! BIT_OR          [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! BIT_XOR         [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! DOT             [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! PLUS            [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! MINUS           [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! MULT            [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! DIV             [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! MOD             [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! IDENTICAL       [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! EQ_EQ           [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! LESSER          [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! LESSER_EQ       [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! GREATER         [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! GREATER_EQ      [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! INSTANCEOF      [ reduce using rule 74 (expr -> INCLUDE expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 40

    (63) expr -> PLUS expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 63 (expr -> PLUS expr .)
    OR_OP           reduce using rule 63 (expr -> PLUS expr .)
    AND             reduce using rule 63 (expr -> PLUS expr .)
    BIT_OR          reduce using rule 63 (expr -> PLUS expr .)
    BIT_XOR         reduce using rule 63 (expr -> PLUS expr .)
    DOT             reduce using rule 63 (expr -> PLUS expr .)
    PLUS            reduce using rule 63 (expr -> PLUS expr .)
    MINUS           reduce using rule 63 (expr -> PLUS expr .)
    MULT            reduce using rule 63 (expr -> PLUS expr .)
    DIV             reduce using rule 63 (expr -> PLUS expr .)
    BIT_LSHIFT      reduce using rule 63 (expr -> PLUS expr .)
    BIT_RSHIFT      reduce using rule 63 (expr -> PLUS expr .)
    MOD             reduce using rule 63 (expr -> PLUS expr .)
    NOT_EQ          reduce using rule 63 (expr -> PLUS expr .)
    SEMICOLON       reduce using rule 63 (expr -> PLUS expr .)
    RPAREN          reduce using rule 63 (expr -> PLUS expr .)
    RBRACE          reduce using rule 63 (expr -> PLUS expr .)
    RBRACKET        reduce using rule 63 (expr -> PLUS expr .)
    COMMA           reduce using rule 63 (expr -> PLUS expr .)
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! IDENTICAL       [ reduce using rule 63 (expr -> PLUS expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 63 (expr -> PLUS expr .) ]
  ! EQ_EQ           [ reduce using rule 63 (expr -> PLUS expr .) ]
  ! LESSER          [ reduce using rule 63 (expr -> PLUS expr .) ]
  ! LESSER_EQ       [ reduce using rule 63 (expr -> PLUS expr .) ]
  ! GREATER         [ reduce using rule 63 (expr -> PLUS expr .) ]
  ! GREATER_EQ      [ reduce using rule 63 (expr -> PLUS expr .) ]
  ! INSTANCEOF      [ reduce using rule 63 (expr -> PLUS expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 41

    (26) expr -> ARRAY LPAREN . array_pair_list RPAREN
    (27) array_pair_list -> . empty
    (28) array_pair_list -> . non_empty_array_pair_list possible_comma
    (82) empty -> .
    (29) non_empty_array_pair_list -> . non_empty_array_pair_list COMMA BIT_AND variable
    (30) non_empty_array_pair_list -> . non_empty_array_pair_list COMMA expr
    (31) non_empty_array_pair_list -> . BIT_AND variable
    (32) non_empty_array_pair_list -> . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    RPAREN          reduce using rule 82 (empty -> .)
    BIT_AND         shift and go to state 90
    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 92
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    array_pair_list                shift and go to state 91
    empty                          shift and go to state 93
    variable                       shift and go to state 21
    reference_variable             shift and go to state 6
    non_empty_array_pair_list      shift and go to state 89

state 42

    (76) expr -> REQUIRE expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 76 (expr -> REQUIRE expr .)
    NOT_EQ          reduce using rule 76 (expr -> REQUIRE expr .)
    SEMICOLON       reduce using rule 76 (expr -> REQUIRE expr .)
    RPAREN          reduce using rule 76 (expr -> REQUIRE expr .)
    RBRACE          reduce using rule 76 (expr -> REQUIRE expr .)
    RBRACKET        reduce using rule 76 (expr -> REQUIRE expr .)
    COMMA           reduce using rule 76 (expr -> REQUIRE expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! OR_OP           [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! BIT_OR          [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! BIT_XOR         [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! DOT             [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! PLUS            [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! MINUS           [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! MULT            [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! DIV             [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! MOD             [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! IDENTICAL       [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! EQ_EQ           [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! LESSER          [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! LESSER_EQ       [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! GREATER         [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! GREATER_EQ      [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! INSTANCEOF      [ reduce using rule 76 (expr -> REQUIRE expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 43

    (71) expr -> EMPTY LPAREN . expr RPAREN
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 94
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 44

    (73) expr -> LPAREN expr . RPAREN
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    RPAREN          shift and go to state 95
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    AND             shift and go to state 72
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    NOT_EQ          shift and go to state 67
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68



state 45

    (39) expr -> variable DOT_EQ . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 96
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 46

    (37) expr -> variable MULTIPLY_EQ . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 97
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 47

    (70) expr -> variable DEC .

    AND_OP          reduce using rule 70 (expr -> variable DEC .)
    OR_OP           reduce using rule 70 (expr -> variable DEC .)
    AND             reduce using rule 70 (expr -> variable DEC .)
    BIT_OR          reduce using rule 70 (expr -> variable DEC .)
    BIT_XOR         reduce using rule 70 (expr -> variable DEC .)
    DOT             reduce using rule 70 (expr -> variable DEC .)
    PLUS            reduce using rule 70 (expr -> variable DEC .)
    MINUS           reduce using rule 70 (expr -> variable DEC .)
    MULT            reduce using rule 70 (expr -> variable DEC .)
    DIV             reduce using rule 70 (expr -> variable DEC .)
    BIT_LSHIFT      reduce using rule 70 (expr -> variable DEC .)
    BIT_RSHIFT      reduce using rule 70 (expr -> variable DEC .)
    MOD             reduce using rule 70 (expr -> variable DEC .)
    IDENTICAL       reduce using rule 70 (expr -> variable DEC .)
    NOT_IDENTICAL   reduce using rule 70 (expr -> variable DEC .)
    EQ_EQ           reduce using rule 70 (expr -> variable DEC .)
    NOT_EQ          reduce using rule 70 (expr -> variable DEC .)
    LESSER          reduce using rule 70 (expr -> variable DEC .)
    LESSER_EQ       reduce using rule 70 (expr -> variable DEC .)
    GREATER         reduce using rule 70 (expr -> variable DEC .)
    GREATER_EQ      reduce using rule 70 (expr -> variable DEC .)
    INSTANCEOF      reduce using rule 70 (expr -> variable DEC .)
    SEMICOLON       reduce using rule 70 (expr -> variable DEC .)
    RPAREN          reduce using rule 70 (expr -> variable DEC .)
    RBRACE          reduce using rule 70 (expr -> variable DEC .)
    RBRACKET        reduce using rule 70 (expr -> variable DEC .)
    COMMA           reduce using rule 70 (expr -> variable DEC .)



state 48

    (17) expr -> variable EQUAL . expr
    (18) expr -> variable EQUAL . BIT_AND expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    BIT_AND         shift and go to state 98
    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 99
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 49

    (35) expr -> variable PLUS_EQ . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 100
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 50

    (38) expr -> variable DIVIDE_EQ . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 101
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 51

    (36) expr -> variable MINUS_EQ . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 102
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 52

    (40) expr -> variable MOD_EQ . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 103
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 53

    (69) expr -> variable INC .

    AND_OP          reduce using rule 69 (expr -> variable INC .)
    OR_OP           reduce using rule 69 (expr -> variable INC .)
    AND             reduce using rule 69 (expr -> variable INC .)
    BIT_OR          reduce using rule 69 (expr -> variable INC .)
    BIT_XOR         reduce using rule 69 (expr -> variable INC .)
    DOT             reduce using rule 69 (expr -> variable INC .)
    PLUS            reduce using rule 69 (expr -> variable INC .)
    MINUS           reduce using rule 69 (expr -> variable INC .)
    MULT            reduce using rule 69 (expr -> variable INC .)
    DIV             reduce using rule 69 (expr -> variable INC .)
    BIT_LSHIFT      reduce using rule 69 (expr -> variable INC .)
    BIT_RSHIFT      reduce using rule 69 (expr -> variable INC .)
    MOD             reduce using rule 69 (expr -> variable INC .)
    IDENTICAL       reduce using rule 69 (expr -> variable INC .)
    NOT_IDENTICAL   reduce using rule 69 (expr -> variable INC .)
    EQ_EQ           reduce using rule 69 (expr -> variable INC .)
    NOT_EQ          reduce using rule 69 (expr -> variable INC .)
    LESSER          reduce using rule 69 (expr -> variable INC .)
    LESSER_EQ       reduce using rule 69 (expr -> variable INC .)
    GREATER         reduce using rule 69 (expr -> variable INC .)
    GREATER_EQ      reduce using rule 69 (expr -> variable INC .)
    INSTANCEOF      reduce using rule 69 (expr -> variable INC .)
    SEMICOLON       reduce using rule 69 (expr -> variable INC .)
    RPAREN          reduce using rule 69 (expr -> variable INC .)
    RBRACE          reduce using rule 69 (expr -> variable INC .)
    RBRACKET        reduce using rule 69 (expr -> variable INC .)
    COMMA           reduce using rule 69 (expr -> variable INC .)



state 54

    (77) expr -> REQUIRE_ONCE expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 77 (expr -> REQUIRE_ONCE expr .)
    NOT_EQ          reduce using rule 77 (expr -> REQUIRE_ONCE expr .)
    SEMICOLON       reduce using rule 77 (expr -> REQUIRE_ONCE expr .)
    RPAREN          reduce using rule 77 (expr -> REQUIRE_ONCE expr .)
    RBRACE          reduce using rule 77 (expr -> REQUIRE_ONCE expr .)
    RBRACKET        reduce using rule 77 (expr -> REQUIRE_ONCE expr .)
    COMMA           reduce using rule 77 (expr -> REQUIRE_ONCE expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! OR_OP           [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_OR          [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_XOR         [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! DOT             [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! PLUS            [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! MINUS           [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! MULT            [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! DIV             [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! MOD             [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! IDENTICAL       [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! EQ_EQ           [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! LESSER          [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! LESSER_EQ       [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! GREATER         [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! GREATER_EQ      [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! INSTANCEOF      [ reduce using rule 77 (expr -> REQUIRE_ONCE expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 55

    (75) expr -> INCLUDE_ONCE expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 75 (expr -> INCLUDE_ONCE expr .)
    NOT_EQ          reduce using rule 75 (expr -> INCLUDE_ONCE expr .)
    SEMICOLON       reduce using rule 75 (expr -> INCLUDE_ONCE expr .)
    RPAREN          reduce using rule 75 (expr -> INCLUDE_ONCE expr .)
    RBRACE          reduce using rule 75 (expr -> INCLUDE_ONCE expr .)
    RBRACKET        reduce using rule 75 (expr -> INCLUDE_ONCE expr .)
    COMMA           reduce using rule 75 (expr -> INCLUDE_ONCE expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! OR_OP           [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_OR          [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_XOR         [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! DOT             [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! PLUS            [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! MINUS           [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! MULT            [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! DIV             [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! MOD             [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! IDENTICAL       [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! EQ_EQ           [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! LESSER          [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! LESSER_EQ       [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! GREATER         [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! GREATER_EQ      [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! INSTANCEOF      [ reduce using rule 75 (expr -> INCLUDE_ONCE expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 56

    (56) expr -> expr EQ_EQ . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 104
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 57

    (61) expr -> expr GREATER_EQ . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 105
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 58

    (50) expr -> expr DIV . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 106
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 59

    (45) expr -> expr BIT_XOR . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 107
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 60

    (48) expr -> expr MINUS . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 108
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 61

    (49) expr -> expr MULT . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 109
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 62

    (54) expr -> expr IDENTICAL . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 110
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 63

    (5) statement -> expr SEMICOLON .

    CLONE           reduce using rule 5 (statement -> expr SEMICOLON .)
    LIST            reduce using rule 5 (statement -> expr SEMICOLON .)
    ARRAY           reduce using rule 5 (statement -> expr SEMICOLON .)
    PLUS            reduce using rule 5 (statement -> expr SEMICOLON .)
    MINUS           reduce using rule 5 (statement -> expr SEMICOLON .)
    BIT_NOT         reduce using rule 5 (statement -> expr SEMICOLON .)
    NOT             reduce using rule 5 (statement -> expr SEMICOLON .)
    INC             reduce using rule 5 (statement -> expr SEMICOLON .)
    DEC             reduce using rule 5 (statement -> expr SEMICOLON .)
    EMPTY           reduce using rule 5 (statement -> expr SEMICOLON .)
    EVAL            reduce using rule 5 (statement -> expr SEMICOLON .)
    LPAREN          reduce using rule 5 (statement -> expr SEMICOLON .)
    INCLUDE         reduce using rule 5 (statement -> expr SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 5 (statement -> expr SEMICOLON .)
    REQUIRE         reduce using rule 5 (statement -> expr SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 5 (statement -> expr SEMICOLON .)
    EXIT            reduce using rule 5 (statement -> expr SEMICOLON .)
    PRINT           reduce using rule 5 (statement -> expr SEMICOLON .)
    IDENTIFIER      reduce using rule 5 (statement -> expr SEMICOLON .)
    $end            reduce using rule 5 (statement -> expr SEMICOLON .)



state 64

    (42) expr -> expr OR_OP . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 111
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 65

    (47) expr -> expr PLUS . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 112
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 66

    (46) expr -> expr DOT . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 113
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 67

    (57) expr -> expr NOT_EQ . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 114
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 68

    (62) expr -> expr INSTANCEOF . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 115
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 69

    (55) expr -> expr NOT_IDENTICAL . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 116
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 70

    (59) expr -> expr LESSER_EQ . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 117
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 71

    (41) expr -> expr AND_OP . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 118
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 72

    (43) expr -> expr AND . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 119
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 73

    (60) expr -> expr GREATER . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 120
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 74

    (52) expr -> expr BIT_RSHIFT . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 121
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 75

    (44) expr -> expr BIT_OR . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 122
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 76

    (58) expr -> expr LESSER . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 123
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 77

    (51) expr -> expr BIT_LSHIFT . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 124
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 78

    (53) expr -> expr MOD . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 125
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 79

    (19) expr -> CLONE expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 19 (expr -> CLONE expr .)
    OR_OP           reduce using rule 19 (expr -> CLONE expr .)
    AND             reduce using rule 19 (expr -> CLONE expr .)
    BIT_OR          reduce using rule 19 (expr -> CLONE expr .)
    BIT_XOR         reduce using rule 19 (expr -> CLONE expr .)
    DOT             reduce using rule 19 (expr -> CLONE expr .)
    PLUS            reduce using rule 19 (expr -> CLONE expr .)
    MINUS           reduce using rule 19 (expr -> CLONE expr .)
    MULT            reduce using rule 19 (expr -> CLONE expr .)
    DIV             reduce using rule 19 (expr -> CLONE expr .)
    BIT_LSHIFT      reduce using rule 19 (expr -> CLONE expr .)
    BIT_RSHIFT      reduce using rule 19 (expr -> CLONE expr .)
    MOD             reduce using rule 19 (expr -> CLONE expr .)
    IDENTICAL       reduce using rule 19 (expr -> CLONE expr .)
    NOT_IDENTICAL   reduce using rule 19 (expr -> CLONE expr .)
    EQ_EQ           reduce using rule 19 (expr -> CLONE expr .)
    NOT_EQ          reduce using rule 19 (expr -> CLONE expr .)
    LESSER          reduce using rule 19 (expr -> CLONE expr .)
    LESSER_EQ       reduce using rule 19 (expr -> CLONE expr .)
    GREATER         reduce using rule 19 (expr -> CLONE expr .)
    GREATER_EQ      reduce using rule 19 (expr -> CLONE expr .)
    INSTANCEOF      reduce using rule 19 (expr -> CLONE expr .)
    SEMICOLON       reduce using rule 19 (expr -> CLONE expr .)
    RPAREN          reduce using rule 19 (expr -> CLONE expr .)
    RBRACE          reduce using rule 19 (expr -> CLONE expr .)
    RBRACKET        reduce using rule 19 (expr -> CLONE expr .)
    COMMA           reduce using rule 19 (expr -> CLONE expr .)

  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! IDENTICAL       [ shift and go to state 62 ]
  ! NOT_IDENTICAL   [ shift and go to state 69 ]
  ! EQ_EQ           [ shift and go to state 56 ]
  ! NOT_EQ          [ shift and go to state 67 ]
  ! LESSER          [ shift and go to state 76 ]
  ! LESSER_EQ       [ shift and go to state 70 ]
  ! GREATER         [ shift and go to state 73 ]
  ! GREATER_EQ      [ shift and go to state 57 ]
  ! INSTANCEOF      [ shift and go to state 68 ]


state 80

    (20) expr -> LIST LPAREN . assignment_list RPAREN EQUAL expr
    (21) assignment_list -> . assignment_list COMMA assignment_list_element
    (22) assignment_list -> . assignment_list_element
    (23) assignment_list_element -> . variable
    (24) assignment_list_element -> . empty
    (25) assignment_list_element -> . LIST LPAREN assignment_list RPAREN
    (7) variable -> . base_variable_with_function_calls
    (82) empty -> .
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    LIST            shift and go to state 127
    RPAREN          reduce using rule 82 (empty -> .)
    COMMA           reduce using rule 82 (empty -> .)
    IDENTIFIER      shift and go to state 16


    assignment_list_element        shift and go to state 126
    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    assignment_list                shift and go to state 128
    variable                       shift and go to state 129
    empty                          shift and go to state 130

state 81

    (79) expr -> EXIT LPAREN . RPAREN
    (80) expr -> EXIT LPAREN . expr RPAREN
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    RPAREN          shift and go to state 131
    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 132
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 82

    (66) expr -> NOT expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 66 (expr -> NOT expr .)
    OR_OP           reduce using rule 66 (expr -> NOT expr .)
    AND             reduce using rule 66 (expr -> NOT expr .)
    BIT_OR          reduce using rule 66 (expr -> NOT expr .)
    BIT_XOR         reduce using rule 66 (expr -> NOT expr .)
    DOT             reduce using rule 66 (expr -> NOT expr .)
    PLUS            reduce using rule 66 (expr -> NOT expr .)
    MINUS           reduce using rule 66 (expr -> NOT expr .)
    MULT            reduce using rule 66 (expr -> NOT expr .)
    DIV             reduce using rule 66 (expr -> NOT expr .)
    BIT_LSHIFT      reduce using rule 66 (expr -> NOT expr .)
    BIT_RSHIFT      reduce using rule 66 (expr -> NOT expr .)
    MOD             reduce using rule 66 (expr -> NOT expr .)
    NOT_EQ          reduce using rule 66 (expr -> NOT expr .)
    SEMICOLON       reduce using rule 66 (expr -> NOT expr .)
    RPAREN          reduce using rule 66 (expr -> NOT expr .)
    RBRACE          reduce using rule 66 (expr -> NOT expr .)
    RBRACKET        reduce using rule 66 (expr -> NOT expr .)
    COMMA           reduce using rule 66 (expr -> NOT expr .)
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! IDENTICAL       [ reduce using rule 66 (expr -> NOT expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 66 (expr -> NOT expr .) ]
  ! EQ_EQ           [ reduce using rule 66 (expr -> NOT expr .) ]
  ! LESSER          [ reduce using rule 66 (expr -> NOT expr .) ]
  ! LESSER_EQ       [ reduce using rule 66 (expr -> NOT expr .) ]
  ! GREATER         [ reduce using rule 66 (expr -> NOT expr .) ]
  ! GREATER_EQ      [ reduce using rule 66 (expr -> NOT expr .) ]
  ! INSTANCEOF      [ reduce using rule 66 (expr -> NOT expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 83

    (67) expr -> INC variable .

    AND_OP          reduce using rule 67 (expr -> INC variable .)
    OR_OP           reduce using rule 67 (expr -> INC variable .)
    AND             reduce using rule 67 (expr -> INC variable .)
    BIT_OR          reduce using rule 67 (expr -> INC variable .)
    BIT_XOR         reduce using rule 67 (expr -> INC variable .)
    DOT             reduce using rule 67 (expr -> INC variable .)
    PLUS            reduce using rule 67 (expr -> INC variable .)
    MINUS           reduce using rule 67 (expr -> INC variable .)
    MULT            reduce using rule 67 (expr -> INC variable .)
    DIV             reduce using rule 67 (expr -> INC variable .)
    BIT_LSHIFT      reduce using rule 67 (expr -> INC variable .)
    BIT_RSHIFT      reduce using rule 67 (expr -> INC variable .)
    MOD             reduce using rule 67 (expr -> INC variable .)
    IDENTICAL       reduce using rule 67 (expr -> INC variable .)
    NOT_IDENTICAL   reduce using rule 67 (expr -> INC variable .)
    EQ_EQ           reduce using rule 67 (expr -> INC variable .)
    NOT_EQ          reduce using rule 67 (expr -> INC variable .)
    LESSER          reduce using rule 67 (expr -> INC variable .)
    LESSER_EQ       reduce using rule 67 (expr -> INC variable .)
    GREATER         reduce using rule 67 (expr -> INC variable .)
    GREATER_EQ      reduce using rule 67 (expr -> INC variable .)
    INSTANCEOF      reduce using rule 67 (expr -> INC variable .)
    SEMICOLON       reduce using rule 67 (expr -> INC variable .)
    RPAREN          reduce using rule 67 (expr -> INC variable .)
    RBRACE          reduce using rule 67 (expr -> INC variable .)
    RBRACKET        reduce using rule 67 (expr -> INC variable .)
    COMMA           reduce using rule 67 (expr -> INC variable .)



state 84

    (72) expr -> EVAL LPAREN expr . RPAREN
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    RPAREN          shift and go to state 133
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    AND             shift and go to state 72
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    NOT_EQ          shift and go to state 67
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68



state 85

    (12) reference_variable -> reference_variable LBRACE expr . RBRACE
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    RBRACE          shift and go to state 134
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    AND             shift and go to state 72
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    NOT_EQ          shift and go to state 67
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68



state 86

    (16) dim_offset -> empty .

    RBRACKET        reduce using rule 16 (dim_offset -> empty .)



state 87

    (11) reference_variable -> reference_variable LBRACKET dim_offset . RBRACKET

    RBRACKET        shift and go to state 135



state 88

    (15) dim_offset -> expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    RBRACKET        reduce using rule 15 (dim_offset -> expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    AND             shift and go to state 72
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    NOT_EQ          shift and go to state 67
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68



state 89

    (28) array_pair_list -> non_empty_array_pair_list . possible_comma
    (29) non_empty_array_pair_list -> non_empty_array_pair_list . COMMA BIT_AND variable
    (30) non_empty_array_pair_list -> non_empty_array_pair_list . COMMA expr
    (33) possible_comma -> . empty
    (34) possible_comma -> . COMMA
    (82) empty -> .

    COMMA           shift and go to state 137
    RPAREN          reduce using rule 82 (empty -> .)


    empty                          shift and go to state 138
    possible_comma                 shift and go to state 136

state 90

    (31) non_empty_array_pair_list -> BIT_AND . variable
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 139

state 91

    (26) expr -> ARRAY LPAREN array_pair_list . RPAREN

    RPAREN          shift and go to state 140



state 92

    (32) non_empty_array_pair_list -> expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    COMMA           reduce using rule 32 (non_empty_array_pair_list -> expr .)
    RPAREN          reduce using rule 32 (non_empty_array_pair_list -> expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    AND             shift and go to state 72
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    NOT_EQ          shift and go to state 67
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68



state 93

    (27) array_pair_list -> empty .

    RPAREN          reduce using rule 27 (array_pair_list -> empty .)



state 94

    (71) expr -> EMPTY LPAREN expr . RPAREN
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    RPAREN          shift and go to state 141
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    AND             shift and go to state 72
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    NOT_EQ          shift and go to state 67
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68



state 95

    (73) expr -> LPAREN expr RPAREN .

    AND_OP          reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    OR_OP           reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    BIT_OR          reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    BIT_XOR         reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    DOT             reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    MULT            reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    DIV             reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    BIT_LSHIFT      reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    BIT_RSHIFT      reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    IDENTICAL       reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    NOT_IDENTICAL   reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    EQ_EQ           reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    LESSER          reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    LESSER_EQ       reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    INSTANCEOF      reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 73 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 73 (expr -> LPAREN expr RPAREN .)



state 96

    (39) expr -> variable DOT_EQ expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 39 (expr -> variable DOT_EQ expr .)
    BIT_OR          reduce using rule 39 (expr -> variable DOT_EQ expr .)
    BIT_XOR         reduce using rule 39 (expr -> variable DOT_EQ expr .)
    NOT_EQ          reduce using rule 39 (expr -> variable DOT_EQ expr .)
    SEMICOLON       reduce using rule 39 (expr -> variable DOT_EQ expr .)
    RPAREN          reduce using rule 39 (expr -> variable DOT_EQ expr .)
    RBRACE          reduce using rule 39 (expr -> variable DOT_EQ expr .)
    RBRACKET        reduce using rule 39 (expr -> variable DOT_EQ expr .)
    COMMA           reduce using rule 39 (expr -> variable DOT_EQ expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! OR_OP           [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! DOT             [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! PLUS            [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! MINUS           [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! MULT            [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! DIV             [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! MOD             [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! LESSER          [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! GREATER         [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 39 (expr -> variable DOT_EQ expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 97

    (37) expr -> variable MULTIPLY_EQ expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .)
    BIT_OR          reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .)
    BIT_XOR         reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .)
    NOT_EQ          reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .)
    SEMICOLON       reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .)
    RPAREN          reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .)
    RBRACE          reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .)
    RBRACKET        reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .)
    COMMA           reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! OR_OP           [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! DOT             [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! PLUS            [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! MINUS           [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! MULT            [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! DIV             [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! MOD             [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! LESSER          [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! GREATER         [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 37 (expr -> variable MULTIPLY_EQ expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 98

    (18) expr -> variable EQUAL BIT_AND . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 142
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 99

    (17) expr -> variable EQUAL expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 17 (expr -> variable EQUAL expr .)
    BIT_OR          reduce using rule 17 (expr -> variable EQUAL expr .)
    BIT_XOR         reduce using rule 17 (expr -> variable EQUAL expr .)
    NOT_EQ          reduce using rule 17 (expr -> variable EQUAL expr .)
    SEMICOLON       reduce using rule 17 (expr -> variable EQUAL expr .)
    RPAREN          reduce using rule 17 (expr -> variable EQUAL expr .)
    RBRACE          reduce using rule 17 (expr -> variable EQUAL expr .)
    RBRACKET        reduce using rule 17 (expr -> variable EQUAL expr .)
    COMMA           reduce using rule 17 (expr -> variable EQUAL expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! OR_OP           [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! DOT             [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! PLUS            [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! MINUS           [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! MULT            [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! DIV             [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! MOD             [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! IDENTICAL       [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! EQ_EQ           [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! LESSER          [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! LESSER_EQ       [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! GREATER         [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! GREATER_EQ      [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! INSTANCEOF      [ reduce using rule 17 (expr -> variable EQUAL expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 100

    (35) expr -> variable PLUS_EQ expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 35 (expr -> variable PLUS_EQ expr .)
    BIT_OR          reduce using rule 35 (expr -> variable PLUS_EQ expr .)
    BIT_XOR         reduce using rule 35 (expr -> variable PLUS_EQ expr .)
    NOT_EQ          reduce using rule 35 (expr -> variable PLUS_EQ expr .)
    SEMICOLON       reduce using rule 35 (expr -> variable PLUS_EQ expr .)
    RPAREN          reduce using rule 35 (expr -> variable PLUS_EQ expr .)
    RBRACE          reduce using rule 35 (expr -> variable PLUS_EQ expr .)
    RBRACKET        reduce using rule 35 (expr -> variable PLUS_EQ expr .)
    COMMA           reduce using rule 35 (expr -> variable PLUS_EQ expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! OR_OP           [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! DOT             [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! PLUS            [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! MINUS           [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! MULT            [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! DIV             [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! MOD             [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! LESSER          [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! GREATER         [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 35 (expr -> variable PLUS_EQ expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 101

    (38) expr -> variable DIVIDE_EQ expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 38 (expr -> variable DIVIDE_EQ expr .)
    BIT_OR          reduce using rule 38 (expr -> variable DIVIDE_EQ expr .)
    BIT_XOR         reduce using rule 38 (expr -> variable DIVIDE_EQ expr .)
    NOT_EQ          reduce using rule 38 (expr -> variable DIVIDE_EQ expr .)
    SEMICOLON       reduce using rule 38 (expr -> variable DIVIDE_EQ expr .)
    RPAREN          reduce using rule 38 (expr -> variable DIVIDE_EQ expr .)
    RBRACE          reduce using rule 38 (expr -> variable DIVIDE_EQ expr .)
    RBRACKET        reduce using rule 38 (expr -> variable DIVIDE_EQ expr .)
    COMMA           reduce using rule 38 (expr -> variable DIVIDE_EQ expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! OR_OP           [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! DOT             [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! PLUS            [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! MINUS           [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! MULT            [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! DIV             [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! MOD             [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! LESSER          [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! GREATER         [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 38 (expr -> variable DIVIDE_EQ expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 102

    (36) expr -> variable MINUS_EQ expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 36 (expr -> variable MINUS_EQ expr .)
    BIT_OR          reduce using rule 36 (expr -> variable MINUS_EQ expr .)
    BIT_XOR         reduce using rule 36 (expr -> variable MINUS_EQ expr .)
    NOT_EQ          reduce using rule 36 (expr -> variable MINUS_EQ expr .)
    SEMICOLON       reduce using rule 36 (expr -> variable MINUS_EQ expr .)
    RPAREN          reduce using rule 36 (expr -> variable MINUS_EQ expr .)
    RBRACE          reduce using rule 36 (expr -> variable MINUS_EQ expr .)
    RBRACKET        reduce using rule 36 (expr -> variable MINUS_EQ expr .)
    COMMA           reduce using rule 36 (expr -> variable MINUS_EQ expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! OR_OP           [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! DOT             [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! PLUS            [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! MINUS           [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! MULT            [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! DIV             [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! MOD             [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! LESSER          [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! GREATER         [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 36 (expr -> variable MINUS_EQ expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 103

    (40) expr -> variable MOD_EQ expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 40 (expr -> variable MOD_EQ expr .)
    BIT_OR          reduce using rule 40 (expr -> variable MOD_EQ expr .)
    BIT_XOR         reduce using rule 40 (expr -> variable MOD_EQ expr .)
    NOT_EQ          reduce using rule 40 (expr -> variable MOD_EQ expr .)
    SEMICOLON       reduce using rule 40 (expr -> variable MOD_EQ expr .)
    RPAREN          reduce using rule 40 (expr -> variable MOD_EQ expr .)
    RBRACE          reduce using rule 40 (expr -> variable MOD_EQ expr .)
    RBRACKET        reduce using rule 40 (expr -> variable MOD_EQ expr .)
    COMMA           reduce using rule 40 (expr -> variable MOD_EQ expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! OR_OP           [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! DOT             [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! PLUS            [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! MINUS           [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! MULT            [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! DIV             [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! MOD             [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! LESSER          [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! GREATER         [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 40 (expr -> variable MOD_EQ expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 104

    (56) expr -> expr EQ_EQ expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 56 (expr -> expr EQ_EQ expr .)
    OR_OP           reduce using rule 56 (expr -> expr EQ_EQ expr .)
    AND             reduce using rule 56 (expr -> expr EQ_EQ expr .)
    BIT_OR          reduce using rule 56 (expr -> expr EQ_EQ expr .)
    BIT_XOR         reduce using rule 56 (expr -> expr EQ_EQ expr .)
    DOT             reduce using rule 56 (expr -> expr EQ_EQ expr .)
    PLUS            reduce using rule 56 (expr -> expr EQ_EQ expr .)
    MINUS           reduce using rule 56 (expr -> expr EQ_EQ expr .)
    MULT            reduce using rule 56 (expr -> expr EQ_EQ expr .)
    DIV             reduce using rule 56 (expr -> expr EQ_EQ expr .)
    BIT_LSHIFT      reduce using rule 56 (expr -> expr EQ_EQ expr .)
    BIT_RSHIFT      reduce using rule 56 (expr -> expr EQ_EQ expr .)
    MOD             reduce using rule 56 (expr -> expr EQ_EQ expr .)
    IDENTICAL       reduce using rule 56 (expr -> expr EQ_EQ expr .)
    NOT_IDENTICAL   reduce using rule 56 (expr -> expr EQ_EQ expr .)
    EQ_EQ           reduce using rule 56 (expr -> expr EQ_EQ expr .)
    NOT_EQ          reduce using rule 56 (expr -> expr EQ_EQ expr .)
    LESSER          reduce using rule 56 (expr -> expr EQ_EQ expr .)
    LESSER_EQ       reduce using rule 56 (expr -> expr EQ_EQ expr .)
    GREATER         reduce using rule 56 (expr -> expr EQ_EQ expr .)
    GREATER_EQ      reduce using rule 56 (expr -> expr EQ_EQ expr .)
    SEMICOLON       reduce using rule 56 (expr -> expr EQ_EQ expr .)
    RPAREN          reduce using rule 56 (expr -> expr EQ_EQ expr .)
    RBRACE          reduce using rule 56 (expr -> expr EQ_EQ expr .)
    RBRACKET        reduce using rule 56 (expr -> expr EQ_EQ expr .)
    COMMA           reduce using rule 56 (expr -> expr EQ_EQ expr .)
    INSTANCEOF      shift and go to state 68

  ! INSTANCEOF      [ reduce using rule 56 (expr -> expr EQ_EQ expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! IDENTICAL       [ shift and go to state 62 ]
  ! NOT_IDENTICAL   [ shift and go to state 69 ]
  ! EQ_EQ           [ shift and go to state 56 ]
  ! NOT_EQ          [ shift and go to state 67 ]
  ! LESSER          [ shift and go to state 76 ]
  ! LESSER_EQ       [ shift and go to state 70 ]
  ! GREATER         [ shift and go to state 73 ]
  ! GREATER_EQ      [ shift and go to state 57 ]


state 105

    (61) expr -> expr GREATER_EQ expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    OR_OP           reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    AND             reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    BIT_OR          reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    BIT_XOR         reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    DOT             reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    PLUS            reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    MINUS           reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    MULT            reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    DIV             reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    BIT_LSHIFT      reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    BIT_RSHIFT      reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    MOD             reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    IDENTICAL       reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    NOT_IDENTICAL   reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    EQ_EQ           reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    NOT_EQ          reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    LESSER          reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    LESSER_EQ       reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    GREATER         reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    GREATER_EQ      reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    SEMICOLON       reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    RPAREN          reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    RBRACE          reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    RBRACKET        reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    COMMA           reduce using rule 61 (expr -> expr GREATER_EQ expr .)
    INSTANCEOF      shift and go to state 68

  ! INSTANCEOF      [ reduce using rule 61 (expr -> expr GREATER_EQ expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! IDENTICAL       [ shift and go to state 62 ]
  ! NOT_IDENTICAL   [ shift and go to state 69 ]
  ! EQ_EQ           [ shift and go to state 56 ]
  ! NOT_EQ          [ shift and go to state 67 ]
  ! LESSER          [ shift and go to state 76 ]
  ! LESSER_EQ       [ shift and go to state 70 ]
  ! GREATER         [ shift and go to state 73 ]
  ! GREATER_EQ      [ shift and go to state 57 ]


state 106

    (50) expr -> expr DIV expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 50 (expr -> expr DIV expr .)
    OR_OP           reduce using rule 50 (expr -> expr DIV expr .)
    AND             reduce using rule 50 (expr -> expr DIV expr .)
    BIT_OR          reduce using rule 50 (expr -> expr DIV expr .)
    BIT_XOR         reduce using rule 50 (expr -> expr DIV expr .)
    DOT             reduce using rule 50 (expr -> expr DIV expr .)
    PLUS            reduce using rule 50 (expr -> expr DIV expr .)
    MINUS           reduce using rule 50 (expr -> expr DIV expr .)
    MULT            reduce using rule 50 (expr -> expr DIV expr .)
    DIV             reduce using rule 50 (expr -> expr DIV expr .)
    BIT_LSHIFT      reduce using rule 50 (expr -> expr DIV expr .)
    BIT_RSHIFT      reduce using rule 50 (expr -> expr DIV expr .)
    MOD             reduce using rule 50 (expr -> expr DIV expr .)
    NOT_EQ          reduce using rule 50 (expr -> expr DIV expr .)
    SEMICOLON       reduce using rule 50 (expr -> expr DIV expr .)
    RPAREN          reduce using rule 50 (expr -> expr DIV expr .)
    RBRACE          reduce using rule 50 (expr -> expr DIV expr .)
    RBRACKET        reduce using rule 50 (expr -> expr DIV expr .)
    COMMA           reduce using rule 50 (expr -> expr DIV expr .)
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! IDENTICAL       [ reduce using rule 50 (expr -> expr DIV expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 50 (expr -> expr DIV expr .) ]
  ! EQ_EQ           [ reduce using rule 50 (expr -> expr DIV expr .) ]
  ! LESSER          [ reduce using rule 50 (expr -> expr DIV expr .) ]
  ! LESSER_EQ       [ reduce using rule 50 (expr -> expr DIV expr .) ]
  ! GREATER         [ reduce using rule 50 (expr -> expr DIV expr .) ]
  ! GREATER_EQ      [ reduce using rule 50 (expr -> expr DIV expr .) ]
  ! INSTANCEOF      [ reduce using rule 50 (expr -> expr DIV expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 107

    (45) expr -> expr BIT_XOR expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 45 (expr -> expr BIT_XOR expr .)
    BIT_OR          reduce using rule 45 (expr -> expr BIT_XOR expr .)
    BIT_XOR         reduce using rule 45 (expr -> expr BIT_XOR expr .)
    NOT_EQ          reduce using rule 45 (expr -> expr BIT_XOR expr .)
    SEMICOLON       reduce using rule 45 (expr -> expr BIT_XOR expr .)
    RPAREN          reduce using rule 45 (expr -> expr BIT_XOR expr .)
    RBRACE          reduce using rule 45 (expr -> expr BIT_XOR expr .)
    RBRACKET        reduce using rule 45 (expr -> expr BIT_XOR expr .)
    COMMA           reduce using rule 45 (expr -> expr BIT_XOR expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! OR_OP           [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! DOT             [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! PLUS            [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! MINUS           [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! MULT            [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! DIV             [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! MOD             [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! IDENTICAL       [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! EQ_EQ           [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! LESSER          [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! LESSER_EQ       [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! GREATER         [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! GREATER_EQ      [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! INSTANCEOF      [ reduce using rule 45 (expr -> expr BIT_XOR expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 108

    (48) expr -> expr MINUS expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 48 (expr -> expr MINUS expr .)
    OR_OP           reduce using rule 48 (expr -> expr MINUS expr .)
    AND             reduce using rule 48 (expr -> expr MINUS expr .)
    BIT_OR          reduce using rule 48 (expr -> expr MINUS expr .)
    BIT_XOR         reduce using rule 48 (expr -> expr MINUS expr .)
    DOT             reduce using rule 48 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 48 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 48 (expr -> expr MINUS expr .)
    MULT            reduce using rule 48 (expr -> expr MINUS expr .)
    DIV             reduce using rule 48 (expr -> expr MINUS expr .)
    BIT_LSHIFT      reduce using rule 48 (expr -> expr MINUS expr .)
    BIT_RSHIFT      reduce using rule 48 (expr -> expr MINUS expr .)
    MOD             reduce using rule 48 (expr -> expr MINUS expr .)
    NOT_EQ          reduce using rule 48 (expr -> expr MINUS expr .)
    SEMICOLON       reduce using rule 48 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 48 (expr -> expr MINUS expr .)
    RBRACE          reduce using rule 48 (expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 48 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 48 (expr -> expr MINUS expr .)
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! IDENTICAL       [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! EQ_EQ           [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! LESSER          [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! LESSER_EQ       [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! GREATER         [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! GREATER_EQ      [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! INSTANCEOF      [ reduce using rule 48 (expr -> expr MINUS expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 109

    (49) expr -> expr MULT expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 49 (expr -> expr MULT expr .)
    OR_OP           reduce using rule 49 (expr -> expr MULT expr .)
    AND             reduce using rule 49 (expr -> expr MULT expr .)
    BIT_OR          reduce using rule 49 (expr -> expr MULT expr .)
    BIT_XOR         reduce using rule 49 (expr -> expr MULT expr .)
    DOT             reduce using rule 49 (expr -> expr MULT expr .)
    PLUS            reduce using rule 49 (expr -> expr MULT expr .)
    MINUS           reduce using rule 49 (expr -> expr MULT expr .)
    MULT            reduce using rule 49 (expr -> expr MULT expr .)
    DIV             reduce using rule 49 (expr -> expr MULT expr .)
    BIT_LSHIFT      reduce using rule 49 (expr -> expr MULT expr .)
    BIT_RSHIFT      reduce using rule 49 (expr -> expr MULT expr .)
    MOD             reduce using rule 49 (expr -> expr MULT expr .)
    NOT_EQ          reduce using rule 49 (expr -> expr MULT expr .)
    SEMICOLON       reduce using rule 49 (expr -> expr MULT expr .)
    RPAREN          reduce using rule 49 (expr -> expr MULT expr .)
    RBRACE          reduce using rule 49 (expr -> expr MULT expr .)
    RBRACKET        reduce using rule 49 (expr -> expr MULT expr .)
    COMMA           reduce using rule 49 (expr -> expr MULT expr .)
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! IDENTICAL       [ reduce using rule 49 (expr -> expr MULT expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 49 (expr -> expr MULT expr .) ]
  ! EQ_EQ           [ reduce using rule 49 (expr -> expr MULT expr .) ]
  ! LESSER          [ reduce using rule 49 (expr -> expr MULT expr .) ]
  ! LESSER_EQ       [ reduce using rule 49 (expr -> expr MULT expr .) ]
  ! GREATER         [ reduce using rule 49 (expr -> expr MULT expr .) ]
  ! GREATER_EQ      [ reduce using rule 49 (expr -> expr MULT expr .) ]
  ! INSTANCEOF      [ reduce using rule 49 (expr -> expr MULT expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 110

    (54) expr -> expr IDENTICAL expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 54 (expr -> expr IDENTICAL expr .)
    OR_OP           reduce using rule 54 (expr -> expr IDENTICAL expr .)
    AND             reduce using rule 54 (expr -> expr IDENTICAL expr .)
    BIT_OR          reduce using rule 54 (expr -> expr IDENTICAL expr .)
    BIT_XOR         reduce using rule 54 (expr -> expr IDENTICAL expr .)
    DOT             reduce using rule 54 (expr -> expr IDENTICAL expr .)
    PLUS            reduce using rule 54 (expr -> expr IDENTICAL expr .)
    MINUS           reduce using rule 54 (expr -> expr IDENTICAL expr .)
    MULT            reduce using rule 54 (expr -> expr IDENTICAL expr .)
    DIV             reduce using rule 54 (expr -> expr IDENTICAL expr .)
    BIT_LSHIFT      reduce using rule 54 (expr -> expr IDENTICAL expr .)
    BIT_RSHIFT      reduce using rule 54 (expr -> expr IDENTICAL expr .)
    MOD             reduce using rule 54 (expr -> expr IDENTICAL expr .)
    IDENTICAL       reduce using rule 54 (expr -> expr IDENTICAL expr .)
    NOT_IDENTICAL   reduce using rule 54 (expr -> expr IDENTICAL expr .)
    EQ_EQ           reduce using rule 54 (expr -> expr IDENTICAL expr .)
    NOT_EQ          reduce using rule 54 (expr -> expr IDENTICAL expr .)
    LESSER          reduce using rule 54 (expr -> expr IDENTICAL expr .)
    LESSER_EQ       reduce using rule 54 (expr -> expr IDENTICAL expr .)
    GREATER         reduce using rule 54 (expr -> expr IDENTICAL expr .)
    GREATER_EQ      reduce using rule 54 (expr -> expr IDENTICAL expr .)
    SEMICOLON       reduce using rule 54 (expr -> expr IDENTICAL expr .)
    RPAREN          reduce using rule 54 (expr -> expr IDENTICAL expr .)
    RBRACE          reduce using rule 54 (expr -> expr IDENTICAL expr .)
    RBRACKET        reduce using rule 54 (expr -> expr IDENTICAL expr .)
    COMMA           reduce using rule 54 (expr -> expr IDENTICAL expr .)
    INSTANCEOF      shift and go to state 68

  ! INSTANCEOF      [ reduce using rule 54 (expr -> expr IDENTICAL expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! IDENTICAL       [ shift and go to state 62 ]
  ! NOT_IDENTICAL   [ shift and go to state 69 ]
  ! EQ_EQ           [ shift and go to state 56 ]
  ! NOT_EQ          [ shift and go to state 67 ]
  ! LESSER          [ shift and go to state 76 ]
  ! LESSER_EQ       [ shift and go to state 70 ]
  ! GREATER         [ shift and go to state 73 ]
  ! GREATER_EQ      [ shift and go to state 57 ]


state 111

    (42) expr -> expr OR_OP expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 42 (expr -> expr OR_OP expr .)
    OR_OP           reduce using rule 42 (expr -> expr OR_OP expr .)
    AND             reduce using rule 42 (expr -> expr OR_OP expr .)
    BIT_OR          reduce using rule 42 (expr -> expr OR_OP expr .)
    BIT_XOR         reduce using rule 42 (expr -> expr OR_OP expr .)
    NOT_EQ          reduce using rule 42 (expr -> expr OR_OP expr .)
    SEMICOLON       reduce using rule 42 (expr -> expr OR_OP expr .)
    RPAREN          reduce using rule 42 (expr -> expr OR_OP expr .)
    RBRACE          reduce using rule 42 (expr -> expr OR_OP expr .)
    RBRACKET        reduce using rule 42 (expr -> expr OR_OP expr .)
    COMMA           reduce using rule 42 (expr -> expr OR_OP expr .)
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! DOT             [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! PLUS            [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! MINUS           [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! MULT            [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! DIV             [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! MOD             [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! IDENTICAL       [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! EQ_EQ           [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! LESSER          [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! LESSER_EQ       [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! GREATER         [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! GREATER_EQ      [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! INSTANCEOF      [ reduce using rule 42 (expr -> expr OR_OP expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 112

    (47) expr -> expr PLUS expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 47 (expr -> expr PLUS expr .)
    OR_OP           reduce using rule 47 (expr -> expr PLUS expr .)
    AND             reduce using rule 47 (expr -> expr PLUS expr .)
    BIT_OR          reduce using rule 47 (expr -> expr PLUS expr .)
    BIT_XOR         reduce using rule 47 (expr -> expr PLUS expr .)
    DOT             reduce using rule 47 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 47 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 47 (expr -> expr PLUS expr .)
    MULT            reduce using rule 47 (expr -> expr PLUS expr .)
    DIV             reduce using rule 47 (expr -> expr PLUS expr .)
    BIT_LSHIFT      reduce using rule 47 (expr -> expr PLUS expr .)
    BIT_RSHIFT      reduce using rule 47 (expr -> expr PLUS expr .)
    MOD             reduce using rule 47 (expr -> expr PLUS expr .)
    NOT_EQ          reduce using rule 47 (expr -> expr PLUS expr .)
    SEMICOLON       reduce using rule 47 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 47 (expr -> expr PLUS expr .)
    RBRACE          reduce using rule 47 (expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 47 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 47 (expr -> expr PLUS expr .)
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! IDENTICAL       [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! EQ_EQ           [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! LESSER          [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! LESSER_EQ       [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! GREATER         [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! GREATER_EQ      [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! INSTANCEOF      [ reduce using rule 47 (expr -> expr PLUS expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 113

    (46) expr -> expr DOT expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 46 (expr -> expr DOT expr .)
    OR_OP           reduce using rule 46 (expr -> expr DOT expr .)
    AND             reduce using rule 46 (expr -> expr DOT expr .)
    BIT_OR          reduce using rule 46 (expr -> expr DOT expr .)
    BIT_XOR         reduce using rule 46 (expr -> expr DOT expr .)
    DOT             reduce using rule 46 (expr -> expr DOT expr .)
    PLUS            reduce using rule 46 (expr -> expr DOT expr .)
    MINUS           reduce using rule 46 (expr -> expr DOT expr .)
    MULT            reduce using rule 46 (expr -> expr DOT expr .)
    DIV             reduce using rule 46 (expr -> expr DOT expr .)
    BIT_LSHIFT      reduce using rule 46 (expr -> expr DOT expr .)
    BIT_RSHIFT      reduce using rule 46 (expr -> expr DOT expr .)
    MOD             reduce using rule 46 (expr -> expr DOT expr .)
    NOT_EQ          reduce using rule 46 (expr -> expr DOT expr .)
    SEMICOLON       reduce using rule 46 (expr -> expr DOT expr .)
    RPAREN          reduce using rule 46 (expr -> expr DOT expr .)
    RBRACE          reduce using rule 46 (expr -> expr DOT expr .)
    RBRACKET        reduce using rule 46 (expr -> expr DOT expr .)
    COMMA           reduce using rule 46 (expr -> expr DOT expr .)
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! IDENTICAL       [ reduce using rule 46 (expr -> expr DOT expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 46 (expr -> expr DOT expr .) ]
  ! EQ_EQ           [ reduce using rule 46 (expr -> expr DOT expr .) ]
  ! LESSER          [ reduce using rule 46 (expr -> expr DOT expr .) ]
  ! LESSER_EQ       [ reduce using rule 46 (expr -> expr DOT expr .) ]
  ! GREATER         [ reduce using rule 46 (expr -> expr DOT expr .) ]
  ! GREATER_EQ      [ reduce using rule 46 (expr -> expr DOT expr .) ]
  ! INSTANCEOF      [ reduce using rule 46 (expr -> expr DOT expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 114

    (57) expr -> expr NOT_EQ expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

  ! shift/reduce conflict for AND_OP resolved as shift.
  ! shift/reduce conflict for OR_OP resolved as shift.
  ! shift/reduce conflict for AND resolved as shift.
  ! shift/reduce conflict for BIT_OR resolved as shift.
  ! shift/reduce conflict for BIT_XOR resolved as shift.
  ! shift/reduce conflict for DOT resolved as shift.
  ! shift/reduce conflict for PLUS resolved as shift.
  ! shift/reduce conflict for MINUS resolved as shift.
  ! shift/reduce conflict for MULT resolved as shift.
  ! shift/reduce conflict for DIV resolved as shift.
  ! shift/reduce conflict for BIT_LSHIFT resolved as shift.
  ! shift/reduce conflict for BIT_RSHIFT resolved as shift.
  ! shift/reduce conflict for MOD resolved as shift.
  ! shift/reduce conflict for IDENTICAL resolved as shift.
  ! shift/reduce conflict for NOT_IDENTICAL resolved as shift.
  ! shift/reduce conflict for EQ_EQ resolved as shift.
  ! shift/reduce conflict for NOT_EQ resolved as shift.
  ! shift/reduce conflict for LESSER resolved as shift.
  ! shift/reduce conflict for LESSER_EQ resolved as shift.
  ! shift/reduce conflict for GREATER resolved as shift.
  ! shift/reduce conflict for GREATER_EQ resolved as shift.
  ! shift/reduce conflict for INSTANCEOF resolved as shift.
    SEMICOLON       reduce using rule 57 (expr -> expr NOT_EQ expr .)
    RPAREN          reduce using rule 57 (expr -> expr NOT_EQ expr .)
    RBRACE          reduce using rule 57 (expr -> expr NOT_EQ expr .)
    RBRACKET        reduce using rule 57 (expr -> expr NOT_EQ expr .)
    COMMA           reduce using rule 57 (expr -> expr NOT_EQ expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    AND             shift and go to state 72
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    NOT_EQ          shift and go to state 67
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! OR_OP           [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! AND             [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! BIT_OR          [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! BIT_XOR         [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! DOT             [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! PLUS            [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! MINUS           [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! MULT            [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! DIV             [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! MOD             [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! LESSER          [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! GREATER         [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 57 (expr -> expr NOT_EQ expr .) ]


state 115

    (62) expr -> expr INSTANCEOF expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    OR_OP           reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    AND             reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    BIT_OR          reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    BIT_XOR         reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    DOT             reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    PLUS            reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    MINUS           reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    MULT            reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    DIV             reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    BIT_LSHIFT      reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    BIT_RSHIFT      reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    MOD             reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    IDENTICAL       reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    NOT_IDENTICAL   reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    EQ_EQ           reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    NOT_EQ          reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    LESSER          reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    LESSER_EQ       reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    GREATER         reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    GREATER_EQ      reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    INSTANCEOF      reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    SEMICOLON       reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    RPAREN          reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    RBRACE          reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    RBRACKET        reduce using rule 62 (expr -> expr INSTANCEOF expr .)
    COMMA           reduce using rule 62 (expr -> expr INSTANCEOF expr .)

  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! IDENTICAL       [ shift and go to state 62 ]
  ! NOT_IDENTICAL   [ shift and go to state 69 ]
  ! EQ_EQ           [ shift and go to state 56 ]
  ! NOT_EQ          [ shift and go to state 67 ]
  ! LESSER          [ shift and go to state 76 ]
  ! LESSER_EQ       [ shift and go to state 70 ]
  ! GREATER         [ shift and go to state 73 ]
  ! GREATER_EQ      [ shift and go to state 57 ]
  ! INSTANCEOF      [ shift and go to state 68 ]


state 116

    (55) expr -> expr NOT_IDENTICAL expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    OR_OP           reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    AND             reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    BIT_OR          reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    BIT_XOR         reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    DOT             reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    PLUS            reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    MINUS           reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    MULT            reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    DIV             reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    BIT_LSHIFT      reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    BIT_RSHIFT      reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    MOD             reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    IDENTICAL       reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    NOT_IDENTICAL   reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    EQ_EQ           reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    NOT_EQ          reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    LESSER          reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    LESSER_EQ       reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    GREATER         reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    GREATER_EQ      reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    SEMICOLON       reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    RPAREN          reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    RBRACE          reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    RBRACKET        reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    COMMA           reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .)
    INSTANCEOF      shift and go to state 68

  ! INSTANCEOF      [ reduce using rule 55 (expr -> expr NOT_IDENTICAL expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! IDENTICAL       [ shift and go to state 62 ]
  ! NOT_IDENTICAL   [ shift and go to state 69 ]
  ! EQ_EQ           [ shift and go to state 56 ]
  ! NOT_EQ          [ shift and go to state 67 ]
  ! LESSER          [ shift and go to state 76 ]
  ! LESSER_EQ       [ shift and go to state 70 ]
  ! GREATER         [ shift and go to state 73 ]
  ! GREATER_EQ      [ shift and go to state 57 ]


state 117

    (59) expr -> expr LESSER_EQ expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    OR_OP           reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    AND             reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    BIT_OR          reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    BIT_XOR         reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    DOT             reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    PLUS            reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    MINUS           reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    MULT            reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    DIV             reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    BIT_LSHIFT      reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    BIT_RSHIFT      reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    MOD             reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    IDENTICAL       reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    NOT_IDENTICAL   reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    EQ_EQ           reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    NOT_EQ          reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    LESSER          reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    LESSER_EQ       reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    GREATER         reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    GREATER_EQ      reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    SEMICOLON       reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    RPAREN          reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    RBRACE          reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    RBRACKET        reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    COMMA           reduce using rule 59 (expr -> expr LESSER_EQ expr .)
    INSTANCEOF      shift and go to state 68

  ! INSTANCEOF      [ reduce using rule 59 (expr -> expr LESSER_EQ expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! IDENTICAL       [ shift and go to state 62 ]
  ! NOT_IDENTICAL   [ shift and go to state 69 ]
  ! EQ_EQ           [ shift and go to state 56 ]
  ! NOT_EQ          [ shift and go to state 67 ]
  ! LESSER          [ shift and go to state 76 ]
  ! LESSER_EQ       [ shift and go to state 70 ]
  ! GREATER         [ shift and go to state 73 ]
  ! GREATER_EQ      [ shift and go to state 57 ]


state 118

    (41) expr -> expr AND_OP expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 41 (expr -> expr AND_OP expr .)
    OR_OP           reduce using rule 41 (expr -> expr AND_OP expr .)
    AND             reduce using rule 41 (expr -> expr AND_OP expr .)
    BIT_OR          reduce using rule 41 (expr -> expr AND_OP expr .)
    BIT_XOR         reduce using rule 41 (expr -> expr AND_OP expr .)
    NOT_EQ          reduce using rule 41 (expr -> expr AND_OP expr .)
    SEMICOLON       reduce using rule 41 (expr -> expr AND_OP expr .)
    RPAREN          reduce using rule 41 (expr -> expr AND_OP expr .)
    RBRACE          reduce using rule 41 (expr -> expr AND_OP expr .)
    RBRACKET        reduce using rule 41 (expr -> expr AND_OP expr .)
    COMMA           reduce using rule 41 (expr -> expr AND_OP expr .)
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! DOT             [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! PLUS            [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! MINUS           [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! MULT            [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! DIV             [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! MOD             [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! IDENTICAL       [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! EQ_EQ           [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! LESSER          [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! LESSER_EQ       [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! GREATER         [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! GREATER_EQ      [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! INSTANCEOF      [ reduce using rule 41 (expr -> expr AND_OP expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 119

    (43) expr -> expr AND expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

  ! shift/reduce conflict for AND_OP resolved as shift.
  ! shift/reduce conflict for OR_OP resolved as shift.
  ! shift/reduce conflict for AND resolved as shift.
  ! shift/reduce conflict for BIT_OR resolved as shift.
  ! shift/reduce conflict for BIT_XOR resolved as shift.
  ! shift/reduce conflict for DOT resolved as shift.
  ! shift/reduce conflict for PLUS resolved as shift.
  ! shift/reduce conflict for MINUS resolved as shift.
  ! shift/reduce conflict for MULT resolved as shift.
  ! shift/reduce conflict for DIV resolved as shift.
  ! shift/reduce conflict for BIT_LSHIFT resolved as shift.
  ! shift/reduce conflict for BIT_RSHIFT resolved as shift.
  ! shift/reduce conflict for MOD resolved as shift.
  ! shift/reduce conflict for IDENTICAL resolved as shift.
  ! shift/reduce conflict for NOT_IDENTICAL resolved as shift.
  ! shift/reduce conflict for EQ_EQ resolved as shift.
  ! shift/reduce conflict for NOT_EQ resolved as shift.
  ! shift/reduce conflict for LESSER resolved as shift.
  ! shift/reduce conflict for LESSER_EQ resolved as shift.
  ! shift/reduce conflict for GREATER resolved as shift.
  ! shift/reduce conflict for GREATER_EQ resolved as shift.
  ! shift/reduce conflict for INSTANCEOF resolved as shift.
    SEMICOLON       reduce using rule 43 (expr -> expr AND expr .)
    RPAREN          reduce using rule 43 (expr -> expr AND expr .)
    RBRACE          reduce using rule 43 (expr -> expr AND expr .)
    RBRACKET        reduce using rule 43 (expr -> expr AND expr .)
    COMMA           reduce using rule 43 (expr -> expr AND expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    AND             shift and go to state 72
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    NOT_EQ          shift and go to state 67
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! OR_OP           [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! AND             [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! BIT_OR          [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! BIT_XOR         [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! DOT             [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! PLUS            [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! MULT            [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! DIV             [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! MOD             [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! IDENTICAL       [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! EQ_EQ           [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! NOT_EQ          [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! LESSER          [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! LESSER_EQ       [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! GREATER         [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! GREATER_EQ      [ reduce using rule 43 (expr -> expr AND expr .) ]
  ! INSTANCEOF      [ reduce using rule 43 (expr -> expr AND expr .) ]


state 120

    (60) expr -> expr GREATER expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 60 (expr -> expr GREATER expr .)
    OR_OP           reduce using rule 60 (expr -> expr GREATER expr .)
    AND             reduce using rule 60 (expr -> expr GREATER expr .)
    BIT_OR          reduce using rule 60 (expr -> expr GREATER expr .)
    BIT_XOR         reduce using rule 60 (expr -> expr GREATER expr .)
    DOT             reduce using rule 60 (expr -> expr GREATER expr .)
    PLUS            reduce using rule 60 (expr -> expr GREATER expr .)
    MINUS           reduce using rule 60 (expr -> expr GREATER expr .)
    MULT            reduce using rule 60 (expr -> expr GREATER expr .)
    DIV             reduce using rule 60 (expr -> expr GREATER expr .)
    BIT_LSHIFT      reduce using rule 60 (expr -> expr GREATER expr .)
    BIT_RSHIFT      reduce using rule 60 (expr -> expr GREATER expr .)
    MOD             reduce using rule 60 (expr -> expr GREATER expr .)
    IDENTICAL       reduce using rule 60 (expr -> expr GREATER expr .)
    NOT_IDENTICAL   reduce using rule 60 (expr -> expr GREATER expr .)
    EQ_EQ           reduce using rule 60 (expr -> expr GREATER expr .)
    NOT_EQ          reduce using rule 60 (expr -> expr GREATER expr .)
    LESSER          reduce using rule 60 (expr -> expr GREATER expr .)
    LESSER_EQ       reduce using rule 60 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 60 (expr -> expr GREATER expr .)
    GREATER_EQ      reduce using rule 60 (expr -> expr GREATER expr .)
    SEMICOLON       reduce using rule 60 (expr -> expr GREATER expr .)
    RPAREN          reduce using rule 60 (expr -> expr GREATER expr .)
    RBRACE          reduce using rule 60 (expr -> expr GREATER expr .)
    RBRACKET        reduce using rule 60 (expr -> expr GREATER expr .)
    COMMA           reduce using rule 60 (expr -> expr GREATER expr .)
    INSTANCEOF      shift and go to state 68

  ! INSTANCEOF      [ reduce using rule 60 (expr -> expr GREATER expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! IDENTICAL       [ shift and go to state 62 ]
  ! NOT_IDENTICAL   [ shift and go to state 69 ]
  ! EQ_EQ           [ shift and go to state 56 ]
  ! NOT_EQ          [ shift and go to state 67 ]
  ! LESSER          [ shift and go to state 76 ]
  ! LESSER_EQ       [ shift and go to state 70 ]
  ! GREATER         [ shift and go to state 73 ]
  ! GREATER_EQ      [ shift and go to state 57 ]


state 121

    (52) expr -> expr BIT_RSHIFT expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    OR_OP           reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    AND             reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    BIT_OR          reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    BIT_XOR         reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    BIT_LSHIFT      reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    BIT_RSHIFT      reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    NOT_EQ          reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    SEMICOLON       reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    RPAREN          reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    RBRACE          reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    RBRACKET        reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    COMMA           reduce using rule 52 (expr -> expr BIT_RSHIFT expr .)
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! DOT             [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! PLUS            [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! MINUS           [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! MULT            [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! DIV             [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! MOD             [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! IDENTICAL       [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! EQ_EQ           [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! LESSER          [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! LESSER_EQ       [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! GREATER         [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! GREATER_EQ      [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! INSTANCEOF      [ reduce using rule 52 (expr -> expr BIT_RSHIFT expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 122

    (44) expr -> expr BIT_OR expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 44 (expr -> expr BIT_OR expr .)
    BIT_OR          reduce using rule 44 (expr -> expr BIT_OR expr .)
    NOT_EQ          reduce using rule 44 (expr -> expr BIT_OR expr .)
    SEMICOLON       reduce using rule 44 (expr -> expr BIT_OR expr .)
    RPAREN          reduce using rule 44 (expr -> expr BIT_OR expr .)
    RBRACE          reduce using rule 44 (expr -> expr BIT_OR expr .)
    RBRACKET        reduce using rule 44 (expr -> expr BIT_OR expr .)
    COMMA           reduce using rule 44 (expr -> expr BIT_OR expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! OR_OP           [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! BIT_XOR         [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! DOT             [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! PLUS            [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! MINUS           [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! MULT            [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! DIV             [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! MOD             [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! IDENTICAL       [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! EQ_EQ           [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! LESSER          [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! LESSER_EQ       [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! GREATER         [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! GREATER_EQ      [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! INSTANCEOF      [ reduce using rule 44 (expr -> expr BIT_OR expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 123

    (58) expr -> expr LESSER expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 58 (expr -> expr LESSER expr .)
    OR_OP           reduce using rule 58 (expr -> expr LESSER expr .)
    AND             reduce using rule 58 (expr -> expr LESSER expr .)
    BIT_OR          reduce using rule 58 (expr -> expr LESSER expr .)
    BIT_XOR         reduce using rule 58 (expr -> expr LESSER expr .)
    DOT             reduce using rule 58 (expr -> expr LESSER expr .)
    PLUS            reduce using rule 58 (expr -> expr LESSER expr .)
    MINUS           reduce using rule 58 (expr -> expr LESSER expr .)
    MULT            reduce using rule 58 (expr -> expr LESSER expr .)
    DIV             reduce using rule 58 (expr -> expr LESSER expr .)
    BIT_LSHIFT      reduce using rule 58 (expr -> expr LESSER expr .)
    BIT_RSHIFT      reduce using rule 58 (expr -> expr LESSER expr .)
    MOD             reduce using rule 58 (expr -> expr LESSER expr .)
    IDENTICAL       reduce using rule 58 (expr -> expr LESSER expr .)
    NOT_IDENTICAL   reduce using rule 58 (expr -> expr LESSER expr .)
    EQ_EQ           reduce using rule 58 (expr -> expr LESSER expr .)
    NOT_EQ          reduce using rule 58 (expr -> expr LESSER expr .)
    LESSER          reduce using rule 58 (expr -> expr LESSER expr .)
    LESSER_EQ       reduce using rule 58 (expr -> expr LESSER expr .)
    GREATER         reduce using rule 58 (expr -> expr LESSER expr .)
    GREATER_EQ      reduce using rule 58 (expr -> expr LESSER expr .)
    SEMICOLON       reduce using rule 58 (expr -> expr LESSER expr .)
    RPAREN          reduce using rule 58 (expr -> expr LESSER expr .)
    RBRACE          reduce using rule 58 (expr -> expr LESSER expr .)
    RBRACKET        reduce using rule 58 (expr -> expr LESSER expr .)
    COMMA           reduce using rule 58 (expr -> expr LESSER expr .)
    INSTANCEOF      shift and go to state 68

  ! INSTANCEOF      [ reduce using rule 58 (expr -> expr LESSER expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! IDENTICAL       [ shift and go to state 62 ]
  ! NOT_IDENTICAL   [ shift and go to state 69 ]
  ! EQ_EQ           [ shift and go to state 56 ]
  ! NOT_EQ          [ shift and go to state 67 ]
  ! LESSER          [ shift and go to state 76 ]
  ! LESSER_EQ       [ shift and go to state 70 ]
  ! GREATER         [ shift and go to state 73 ]
  ! GREATER_EQ      [ shift and go to state 57 ]


state 124

    (51) expr -> expr BIT_LSHIFT expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    OR_OP           reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    AND             reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    BIT_OR          reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    BIT_XOR         reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    BIT_LSHIFT      reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    BIT_RSHIFT      reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    NOT_EQ          reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    SEMICOLON       reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    RPAREN          reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    RBRACE          reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    RBRACKET        reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    COMMA           reduce using rule 51 (expr -> expr BIT_LSHIFT expr .)
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! DOT             [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! PLUS            [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! MINUS           [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! MULT            [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! DIV             [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! MOD             [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! IDENTICAL       [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! EQ_EQ           [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! LESSER          [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! LESSER_EQ       [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! GREATER         [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! GREATER_EQ      [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! INSTANCEOF      [ reduce using rule 51 (expr -> expr BIT_LSHIFT expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 125

    (53) expr -> expr MOD expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND_OP          reduce using rule 53 (expr -> expr MOD expr .)
    OR_OP           reduce using rule 53 (expr -> expr MOD expr .)
    AND             reduce using rule 53 (expr -> expr MOD expr .)
    BIT_OR          reduce using rule 53 (expr -> expr MOD expr .)
    BIT_XOR         reduce using rule 53 (expr -> expr MOD expr .)
    DOT             reduce using rule 53 (expr -> expr MOD expr .)
    PLUS            reduce using rule 53 (expr -> expr MOD expr .)
    MINUS           reduce using rule 53 (expr -> expr MOD expr .)
    MULT            reduce using rule 53 (expr -> expr MOD expr .)
    DIV             reduce using rule 53 (expr -> expr MOD expr .)
    BIT_LSHIFT      reduce using rule 53 (expr -> expr MOD expr .)
    BIT_RSHIFT      reduce using rule 53 (expr -> expr MOD expr .)
    MOD             reduce using rule 53 (expr -> expr MOD expr .)
    NOT_EQ          reduce using rule 53 (expr -> expr MOD expr .)
    SEMICOLON       reduce using rule 53 (expr -> expr MOD expr .)
    RPAREN          reduce using rule 53 (expr -> expr MOD expr .)
    RBRACE          reduce using rule 53 (expr -> expr MOD expr .)
    RBRACKET        reduce using rule 53 (expr -> expr MOD expr .)
    COMMA           reduce using rule 53 (expr -> expr MOD expr .)
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! IDENTICAL       [ reduce using rule 53 (expr -> expr MOD expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 53 (expr -> expr MOD expr .) ]
  ! EQ_EQ           [ reduce using rule 53 (expr -> expr MOD expr .) ]
  ! LESSER          [ reduce using rule 53 (expr -> expr MOD expr .) ]
  ! LESSER_EQ       [ reduce using rule 53 (expr -> expr MOD expr .) ]
  ! GREATER         [ reduce using rule 53 (expr -> expr MOD expr .) ]
  ! GREATER_EQ      [ reduce using rule 53 (expr -> expr MOD expr .) ]
  ! INSTANCEOF      [ reduce using rule 53 (expr -> expr MOD expr .) ]
  ! AND_OP          [ shift and go to state 71 ]
  ! OR_OP           [ shift and go to state 64 ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! DOT             [ shift and go to state 66 ]
  ! PLUS            [ shift and go to state 65 ]
  ! MINUS           [ shift and go to state 60 ]
  ! MULT            [ shift and go to state 61 ]
  ! DIV             [ shift and go to state 58 ]
  ! BIT_LSHIFT      [ shift and go to state 77 ]
  ! BIT_RSHIFT      [ shift and go to state 74 ]
  ! MOD             [ shift and go to state 78 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 126

    (22) assignment_list -> assignment_list_element .

    RPAREN          reduce using rule 22 (assignment_list -> assignment_list_element .)
    COMMA           reduce using rule 22 (assignment_list -> assignment_list_element .)



state 127

    (25) assignment_list_element -> LIST . LPAREN assignment_list RPAREN

    LPAREN          shift and go to state 143



state 128

    (20) expr -> LIST LPAREN assignment_list . RPAREN EQUAL expr
    (21) assignment_list -> assignment_list . COMMA assignment_list_element

    RPAREN          shift and go to state 144
    COMMA           shift and go to state 145



state 129

    (23) assignment_list_element -> variable .

    RPAREN          reduce using rule 23 (assignment_list_element -> variable .)
    COMMA           reduce using rule 23 (assignment_list_element -> variable .)



state 130

    (24) assignment_list_element -> empty .

    RPAREN          reduce using rule 24 (assignment_list_element -> empty .)
    COMMA           reduce using rule 24 (assignment_list_element -> empty .)



state 131

    (79) expr -> EXIT LPAREN RPAREN .

    AND_OP          reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    OR_OP           reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    AND             reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    BIT_OR          reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    BIT_XOR         reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    DOT             reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    PLUS            reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    MINUS           reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    MULT            reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    DIV             reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    BIT_LSHIFT      reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    BIT_RSHIFT      reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    MOD             reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    IDENTICAL       reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    NOT_IDENTICAL   reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    EQ_EQ           reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    NOT_EQ          reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    LESSER          reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    LESSER_EQ       reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    GREATER         reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    GREATER_EQ      reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    INSTANCEOF      reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    SEMICOLON       reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    RPAREN          reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    RBRACE          reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    RBRACKET        reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)
    COMMA           reduce using rule 79 (expr -> EXIT LPAREN RPAREN .)



state 132

    (80) expr -> EXIT LPAREN expr . RPAREN
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    RPAREN          shift and go to state 146
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    AND             shift and go to state 72
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    NOT_EQ          shift and go to state 67
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68



state 133

    (72) expr -> EVAL LPAREN expr RPAREN .

    AND_OP          reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    OR_OP           reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    AND             reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_OR          reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_XOR         reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    DOT             reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    PLUS            reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    MINUS           reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    MULT            reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    DIV             reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_LSHIFT      reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_RSHIFT      reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    MOD             reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    IDENTICAL       reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    NOT_IDENTICAL   reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    EQ_EQ           reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    LESSER          reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    LESSER_EQ       reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    GREATER         reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    INSTANCEOF      reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    RPAREN          reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    RBRACE          reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)
    COMMA           reduce using rule 72 (expr -> EVAL LPAREN expr RPAREN .)



state 134

    (12) reference_variable -> reference_variable LBRACE expr RBRACE .

    LBRACKET        reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    LBRACE          reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    EQUAL           reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    PLUS_EQ         reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    MINUS_EQ        reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    MULTIPLY_EQ     reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    DIVIDE_EQ       reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    DOT_EQ          reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    MOD_EQ          reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    INC             reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    DEC             reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    AND_OP          reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    OR_OP           reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    AND             reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    BIT_OR          reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    BIT_XOR         reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    DOT             reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    PLUS            reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    MINUS           reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    MULT            reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    DIV             reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    BIT_LSHIFT      reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    BIT_RSHIFT      reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    MOD             reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    IDENTICAL       reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    NOT_IDENTICAL   reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    EQ_EQ           reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    NOT_EQ          reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    LESSER          reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    LESSER_EQ       reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    GREATER         reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    GREATER_EQ      reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    INSTANCEOF      reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    COMMA           reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    RPAREN          reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    SEMICOLON       reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    RBRACE          reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)
    RBRACKET        reduce using rule 12 (reference_variable -> reference_variable LBRACE expr RBRACE .)



state 135

    (11) reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .

    LBRACKET        reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    LBRACE          reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    EQUAL           reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    PLUS_EQ         reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    MINUS_EQ        reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    MULTIPLY_EQ     reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    DIVIDE_EQ       reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    DOT_EQ          reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    MOD_EQ          reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    INC             reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    DEC             reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    AND_OP          reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    OR_OP           reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    AND             reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    BIT_OR          reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    BIT_XOR         reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    DOT             reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    PLUS            reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    MINUS           reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    MULT            reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    DIV             reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    BIT_LSHIFT      reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    BIT_RSHIFT      reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    MOD             reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    IDENTICAL       reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    NOT_IDENTICAL   reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    EQ_EQ           reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    NOT_EQ          reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    LESSER          reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    LESSER_EQ       reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    GREATER         reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    GREATER_EQ      reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    INSTANCEOF      reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    COMMA           reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    RPAREN          reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    SEMICOLON       reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    RBRACE          reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)
    RBRACKET        reduce using rule 11 (reference_variable -> reference_variable LBRACKET dim_offset RBRACKET .)



state 136

    (28) array_pair_list -> non_empty_array_pair_list possible_comma .

    RPAREN          reduce using rule 28 (array_pair_list -> non_empty_array_pair_list possible_comma .)



state 137

    (29) non_empty_array_pair_list -> non_empty_array_pair_list COMMA . BIT_AND variable
    (30) non_empty_array_pair_list -> non_empty_array_pair_list COMMA . expr
    (34) possible_comma -> COMMA .
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    BIT_AND         shift and go to state 147
    RPAREN          reduce using rule 34 (possible_comma -> COMMA .)
    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    compound_variable              shift and go to state 24
    expr                           shift and go to state 148
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21
    base_variable                  shift and go to state 19

state 138

    (33) possible_comma -> empty .

    RPAREN          reduce using rule 33 (possible_comma -> empty .)



state 139

    (31) non_empty_array_pair_list -> BIT_AND variable .

    COMMA           reduce using rule 31 (non_empty_array_pair_list -> BIT_AND variable .)
    RPAREN          reduce using rule 31 (non_empty_array_pair_list -> BIT_AND variable .)



state 140

    (26) expr -> ARRAY LPAREN array_pair_list RPAREN .

    AND_OP          reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    OR_OP           reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    AND             reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_OR          reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_XOR         reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    DOT             reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    PLUS            reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    MINUS           reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    MULT            reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    DIV             reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_LSHIFT      reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_RSHIFT      reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    MOD             reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    IDENTICAL       reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    NOT_IDENTICAL   reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    EQ_EQ           reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    NOT_EQ          reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    LESSER          reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    LESSER_EQ       reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    GREATER         reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    GREATER_EQ      reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    INSTANCEOF      reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    SEMICOLON       reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    RPAREN          reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    RBRACE          reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    RBRACKET        reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    COMMA           reduce using rule 26 (expr -> ARRAY LPAREN array_pair_list RPAREN .)



state 141

    (71) expr -> EMPTY LPAREN expr RPAREN .

    AND_OP          reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    OR_OP           reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    AND             reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_OR          reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_XOR         reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    DOT             reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    PLUS            reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    MINUS           reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    MULT            reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    DIV             reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_LSHIFT      reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_RSHIFT      reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    MOD             reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    IDENTICAL       reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    NOT_IDENTICAL   reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    EQ_EQ           reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    LESSER          reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    LESSER_EQ       reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    GREATER         reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    INSTANCEOF      reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    RPAREN          reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    RBRACE          reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)
    COMMA           reduce using rule 71 (expr -> EMPTY LPAREN expr RPAREN .)



state 142

    (18) expr -> variable EQUAL BIT_AND expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    AND             reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .)
    BIT_OR          reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .)
    BIT_XOR         reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .)
    NOT_EQ          reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .)
    SEMICOLON       reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .)
    RPAREN          reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .)
    RBRACE          reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .)
    RBRACKET        reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .)
    COMMA           reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! OR_OP           [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! DOT             [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! PLUS            [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! MINUS           [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! MULT            [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! DIV             [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! MOD             [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! IDENTICAL       [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! EQ_EQ           [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! LESSER          [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! LESSER_EQ       [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! GREATER         [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! GREATER_EQ      [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! INSTANCEOF      [ reduce using rule 18 (expr -> variable EQUAL BIT_AND expr .) ]
  ! AND             [ shift and go to state 72 ]
  ! BIT_OR          [ shift and go to state 75 ]
  ! BIT_XOR         [ shift and go to state 59 ]
  ! NOT_EQ          [ shift and go to state 67 ]


state 143

    (25) assignment_list_element -> LIST LPAREN . assignment_list RPAREN
    (21) assignment_list -> . assignment_list COMMA assignment_list_element
    (22) assignment_list -> . assignment_list_element
    (23) assignment_list_element -> . variable
    (24) assignment_list_element -> . empty
    (25) assignment_list_element -> . LIST LPAREN assignment_list RPAREN
    (7) variable -> . base_variable_with_function_calls
    (82) empty -> .
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    LIST            shift and go to state 127
    RPAREN          reduce using rule 82 (empty -> .)
    COMMA           reduce using rule 82 (empty -> .)
    IDENTIFIER      shift and go to state 16


    assignment_list_element        shift and go to state 126
    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    assignment_list                shift and go to state 149
    variable                       shift and go to state 129
    empty                          shift and go to state 130

state 144

    (20) expr -> LIST LPAREN assignment_list RPAREN . EQUAL expr

    EQUAL           shift and go to state 150



state 145

    (21) assignment_list -> assignment_list COMMA . assignment_list_element
    (23) assignment_list_element -> . variable
    (24) assignment_list_element -> . empty
    (25) assignment_list_element -> . LIST LPAREN assignment_list RPAREN
    (7) variable -> . base_variable_with_function_calls
    (82) empty -> .
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    LIST            shift and go to state 127
    RPAREN          reduce using rule 82 (empty -> .)
    COMMA           reduce using rule 82 (empty -> .)
    IDENTIFIER      shift and go to state 16


    assignment_list_element        shift and go to state 151
    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 129
    empty                          shift and go to state 130

state 146

    (80) expr -> EXIT LPAREN expr RPAREN .

    AND_OP          reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    OR_OP           reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    AND             reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_OR          reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_XOR         reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    DOT             reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    PLUS            reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    MINUS           reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    MULT            reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    DIV             reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_LSHIFT      reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_RSHIFT      reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    MOD             reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    IDENTICAL       reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    NOT_IDENTICAL   reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    EQ_EQ           reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    LESSER          reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    LESSER_EQ       reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    GREATER         reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    INSTANCEOF      reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    RPAREN          reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    RBRACE          reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)
    COMMA           reduce using rule 80 (expr -> EXIT LPAREN expr RPAREN .)



state 147

    (29) non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND . variable
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 152

state 148

    (30) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

    COMMA           reduce using rule 30 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr .)
    RPAREN          reduce using rule 30 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    AND             shift and go to state 72
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    NOT_EQ          shift and go to state 67
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68



state 149

    (25) assignment_list_element -> LIST LPAREN assignment_list . RPAREN
    (21) assignment_list -> assignment_list . COMMA assignment_list_element

    RPAREN          shift and go to state 153
    COMMA           shift and go to state 145



state 150

    (20) expr -> LIST LPAREN assignment_list RPAREN EQUAL . expr
    (6) expr -> . variable
    (17) expr -> . variable EQUAL expr
    (18) expr -> . variable EQUAL BIT_AND expr
    (19) expr -> . CLONE expr
    (20) expr -> . LIST LPAREN assignment_list RPAREN EQUAL expr
    (26) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (35) expr -> . variable PLUS_EQ expr
    (36) expr -> . variable MINUS_EQ expr
    (37) expr -> . variable MULTIPLY_EQ expr
    (38) expr -> . variable DIVIDE_EQ expr
    (39) expr -> . variable DOT_EQ expr
    (40) expr -> . variable MOD_EQ expr
    (41) expr -> . expr AND_OP expr
    (42) expr -> . expr OR_OP expr
    (43) expr -> . expr AND expr
    (44) expr -> . expr BIT_OR expr
    (45) expr -> . expr BIT_XOR expr
    (46) expr -> . expr DOT expr
    (47) expr -> . expr PLUS expr
    (48) expr -> . expr MINUS expr
    (49) expr -> . expr MULT expr
    (50) expr -> . expr DIV expr
    (51) expr -> . expr BIT_LSHIFT expr
    (52) expr -> . expr BIT_RSHIFT expr
    (53) expr -> . expr MOD expr
    (54) expr -> . expr IDENTICAL expr
    (55) expr -> . expr NOT_IDENTICAL expr
    (56) expr -> . expr EQ_EQ expr
    (57) expr -> . expr NOT_EQ expr
    (58) expr -> . expr LESSER expr
    (59) expr -> . expr LESSER_EQ expr
    (60) expr -> . expr GREATER expr
    (61) expr -> . expr GREATER_EQ expr
    (62) expr -> . expr INSTANCEOF expr
    (63) expr -> . PLUS expr
    (64) expr -> . MINUS expr
    (65) expr -> . BIT_NOT expr
    (66) expr -> . NOT expr
    (67) expr -> . INC variable
    (68) expr -> . DEC variable
    (69) expr -> . variable INC
    (70) expr -> . variable DEC
    (71) expr -> . EMPTY LPAREN expr RPAREN
    (72) expr -> . EVAL LPAREN expr RPAREN
    (73) expr -> . LPAREN expr RPAREN
    (74) expr -> . INCLUDE expr
    (75) expr -> . INCLUDE_ONCE expr
    (76) expr -> . REQUIRE expr
    (77) expr -> . REQUIRE_ONCE expr
    (78) expr -> . EXIT
    (79) expr -> . EXIT LPAREN RPAREN
    (80) expr -> . EXIT LPAREN expr RPAREN
    (81) expr -> . PRINT expr
    (7) variable -> . base_variable_with_function_calls
    (8) base_variable_with_function_calls -> . base_variable
    (9) base_variable -> . simple_indirect_reference
    (10) simple_indirect_reference -> . reference_variable
    (11) reference_variable -> . reference_variable LBRACKET dim_offset RBRACKET
    (12) reference_variable -> . reference_variable LBRACE expr RBRACE
    (13) reference_variable -> . compound_variable
    (14) compound_variable -> . IDENTIFIER

    CLONE           shift and go to state 26
    LIST            shift and go to state 27
    ARRAY           shift and go to state 15
    PLUS            shift and go to state 12
    MINUS           shift and go to state 9
    BIT_NOT         shift and go to state 5
    NOT             shift and go to state 29
    INC             shift and go to state 30
    DEC             shift and go to state 8
    EMPTY           shift and go to state 18
    EVAL            shift and go to state 4
    LPAREN          shift and go to state 20
    INCLUDE         shift and go to state 10
    INCLUDE_ONCE    shift and go to state 23
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 22
    EXIT            shift and go to state 28
    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 16


    base_variable                  shift and go to state 19
    compound_variable              shift and go to state 24
    expr                           shift and go to state 154
    simple_indirect_reference      shift and go to state 14
    base_variable_with_function_calls shift and go to state 11
    reference_variable             shift and go to state 6
    variable                       shift and go to state 21

state 151

    (21) assignment_list -> assignment_list COMMA assignment_list_element .

    RPAREN          reduce using rule 21 (assignment_list -> assignment_list COMMA assignment_list_element .)
    COMMA           reduce using rule 21 (assignment_list -> assignment_list COMMA assignment_list_element .)



state 152

    (29) non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND variable .

    COMMA           reduce using rule 29 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND variable .)
    RPAREN          reduce using rule 29 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND variable .)



state 153

    (25) assignment_list_element -> LIST LPAREN assignment_list RPAREN .

    RPAREN          reduce using rule 25 (assignment_list_element -> LIST LPAREN assignment_list RPAREN .)
    COMMA           reduce using rule 25 (assignment_list_element -> LIST LPAREN assignment_list RPAREN .)



state 154

    (20) expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .
    (41) expr -> expr . AND_OP expr
    (42) expr -> expr . OR_OP expr
    (43) expr -> expr . AND expr
    (44) expr -> expr . BIT_OR expr
    (45) expr -> expr . BIT_XOR expr
    (46) expr -> expr . DOT expr
    (47) expr -> expr . PLUS expr
    (48) expr -> expr . MINUS expr
    (49) expr -> expr . MULT expr
    (50) expr -> expr . DIV expr
    (51) expr -> expr . BIT_LSHIFT expr
    (52) expr -> expr . BIT_RSHIFT expr
    (53) expr -> expr . MOD expr
    (54) expr -> expr . IDENTICAL expr
    (55) expr -> expr . NOT_IDENTICAL expr
    (56) expr -> expr . EQ_EQ expr
    (57) expr -> expr . NOT_EQ expr
    (58) expr -> expr . LESSER expr
    (59) expr -> expr . LESSER_EQ expr
    (60) expr -> expr . GREATER expr
    (61) expr -> expr . GREATER_EQ expr
    (62) expr -> expr . INSTANCEOF expr

  ! shift/reduce conflict for AND_OP resolved as shift.
  ! shift/reduce conflict for OR_OP resolved as shift.
  ! shift/reduce conflict for AND resolved as shift.
  ! shift/reduce conflict for BIT_OR resolved as shift.
  ! shift/reduce conflict for BIT_XOR resolved as shift.
  ! shift/reduce conflict for DOT resolved as shift.
  ! shift/reduce conflict for PLUS resolved as shift.
  ! shift/reduce conflict for MINUS resolved as shift.
  ! shift/reduce conflict for MULT resolved as shift.
  ! shift/reduce conflict for DIV resolved as shift.
  ! shift/reduce conflict for BIT_LSHIFT resolved as shift.
  ! shift/reduce conflict for BIT_RSHIFT resolved as shift.
  ! shift/reduce conflict for MOD resolved as shift.
  ! shift/reduce conflict for IDENTICAL resolved as shift.
  ! shift/reduce conflict for NOT_IDENTICAL resolved as shift.
  ! shift/reduce conflict for EQ_EQ resolved as shift.
  ! shift/reduce conflict for NOT_EQ resolved as shift.
  ! shift/reduce conflict for LESSER resolved as shift.
  ! shift/reduce conflict for LESSER_EQ resolved as shift.
  ! shift/reduce conflict for GREATER resolved as shift.
  ! shift/reduce conflict for GREATER_EQ resolved as shift.
  ! shift/reduce conflict for INSTANCEOF resolved as shift.
    SEMICOLON       reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .)
    RPAREN          reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .)
    RBRACE          reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .)
    RBRACKET        reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .)
    COMMA           reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .)
    AND_OP          shift and go to state 71
    OR_OP           shift and go to state 64
    AND             shift and go to state 72
    BIT_OR          shift and go to state 75
    BIT_XOR         shift and go to state 59
    DOT             shift and go to state 66
    PLUS            shift and go to state 65
    MINUS           shift and go to state 60
    MULT            shift and go to state 61
    DIV             shift and go to state 58
    BIT_LSHIFT      shift and go to state 77
    BIT_RSHIFT      shift and go to state 74
    MOD             shift and go to state 78
    IDENTICAL       shift and go to state 62
    NOT_IDENTICAL   shift and go to state 69
    EQ_EQ           shift and go to state 56
    NOT_EQ          shift and go to state 67
    LESSER          shift and go to state 76
    LESSER_EQ       shift and go to state 70
    GREATER         shift and go to state 73
    GREATER_EQ      shift and go to state 57
    INSTANCEOF      shift and go to state 68

  ! AND_OP          [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! OR_OP           [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! AND             [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! BIT_OR          [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! BIT_XOR         [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! DOT             [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! PLUS            [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! MINUS           [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! MULT            [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! DIV             [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! MOD             [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! IDENTICAL       [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! EQ_EQ           [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! NOT_EQ          [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! LESSER          [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! LESSER_EQ       [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! GREATER         [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! GREATER_EQ      [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]
  ! INSTANCEOF      [ reduce using rule 20 (expr -> LIST LPAREN assignment_list RPAREN EQUAL expr .) ]

