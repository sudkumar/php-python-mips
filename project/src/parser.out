

Unused terminals:

   PROTECTED
   __HALT_COMPILER
   QUOTE
   CONST_BINARY
   GOTO
   NAMESPACE
   __CLASS__
   __LINE__
   CALLABLE
   EXTENDS
   VAR
   DECLARE
   TRAIT
   ISSET
   INSTEADOF
   ACCESS_OP
   CONST_OCTAL
   INTERFACE
   OR
   FINAL
   COND_COLON
   TRY
   AND
   ENDDECLARE
   NEW
   END_TAG
   EXPONENT
   START_TAG
   CATCH
   __METHOD__
   IMPLEMENTS
   LIST
   PUBLIC
   USE
   CONST
   DIE
   ABSTRACT
   UNSET
   CONST_HEX
   PRIVATE
   CLASS
   __DIR__
   XOR
   __FILE__
   __FUNCTION__
   __TRAIT__
   __NAMESPACE__
   THROW

Grammar

Rule 1     start -> start_marker stmt_list
Rule 2     start_marker -> empty
Rule 3     stmt_list -> top_stmt jump_marker stmt_list
Rule 4     stmt_list -> empty
Rule 5     top_stmt -> stmt
Rule 6     top_stmt -> func_decl
Rule 7     func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker
Rule 8     func_table_marker -> empty
Rule 9     params -> params COMMA param
Rule 10    params -> param
Rule 11    params -> empty
Rule 12    param -> IDENTIFIER
Rule 13    param -> BIT_AND IDENTIFIER
Rule 14    param -> IDENTIFIER EQUAL scalar
Rule 15    param -> BIT_AND IDENTIFIER EQUAL scalar
Rule 16    stmt -> if_stmt
Rule 17    stmt -> alt_if_stmt
Rule 18    if_stmt -> if_stmt_without_else
Rule 19    if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt
Rule 20    if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt
Rule 21    if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt
Rule 22    alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON
Rule 23    alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
Rule 24    alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON jump_marker inner_stmts
Rule 25    alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts
Rule 26    stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker
Rule 27    while_stmt -> stmt
Rule 28    while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON
Rule 29    stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON
Rule 30    stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
Rule 31    for_expr -> empty
Rule 32    for_expr -> non_empty_for_expr
Rule 33    non_empty_for_expr -> non_empty_for_expr COMMA expr
Rule 34    non_empty_for_expr -> expr
Rule 35    for_stmt -> stmt
Rule 36    for_stmt -> COLON inner_stmts ENDFOR SEMICOLON
Rule 37    stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
Rule 38    foreach_var -> IDENTIFIER
Rule 39    foreach_var -> BIT_AND IDENTIFIER
Rule 40    foreach_arg -> empty
Rule 41    foreach_arg -> DOUBLE_ARROW foreach_var
Rule 42    foreach_stmt -> stmt
Rule 43    foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON
Rule 44    stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker
Rule 45    switch_stmt -> LBRACE case_stmt RBRACE
Rule 46    switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE
Rule 47    switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON
Rule 48    switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON
Rule 49    case_stmt -> empty
Rule 50    case_stmt -> case_stmt CASE expr case_separator jump_marker inner_stmts
Rule 51    case_stmt -> case_stmt DEFAULT case_separator jump_marker inner_stmts
Rule 52    case_separator -> COLON
Rule 53    case_separator -> SEMICOLON
Rule 54    stmt -> BREAK goto_marker SEMICOLON
Rule 55    stmt -> BREAK expr goto_marker SEMICOLON
Rule 56    stmt -> CONTINUE goto_marker SEMICOLON
Rule 57    stmt -> CONTINUE expr goto_marker SEMICOLON
Rule 58    stmt -> RETURN SEMICOLON
Rule 59    stmt -> RETURN expr SEMICOLON
Rule 60    stmt -> GLOBAL global_var_list SEMICOLON
Rule 61    global_var_list -> global_var_list COMMA IDENTIFIER
Rule 62    global_var_list -> IDENTIFIER
Rule 63    stmt -> STATIC static_var_list SEMICOLON
Rule 64    static_var_list -> static_var_list COMMA static_var
Rule 65    static_var_list -> static_var
Rule 66    static_var -> IDENTIFIER EQUAL scalar
Rule 67    static_var -> IDENTIFIER
Rule 68    stmt -> ECHO echo_expr_list SEMICOLON
Rule 69    echo_expr_list -> echo_expr_list COMMA expr
Rule 70    echo_expr_list -> expr
Rule 71    stmt -> LBRACE inner_stmts RBRACE
Rule 72    stmt -> SEMICOLON
Rule 73    stmt -> expr SEMICOLON
Rule 74    inner_stmts -> inner_stmts jump_marker inner_stmt
Rule 75    inner_stmts -> empty
Rule 76    inner_stmt -> stmt
Rule 77    inner_stmt -> func_decl
Rule 78    expr -> variable
Rule 79    variable -> base_var
Rule 80    variable -> func_call
Rule 81    func_call -> STRING LPAREN func_params RPAREN
Rule 82    func_params -> func_params COMMA func_param
Rule 83    func_params -> func_param
Rule 84    func_params -> empty
Rule 85    func_param -> expr
Rule 86    func_param -> BIT_AND variable
Rule 87    base_var -> base_var LBRACKET dim_offset RBRACKET
Rule 88    base_var -> base_var LBRACE expr RBRACE
Rule 89    base_var -> IDENTIFIER
Rule 90    dim_offset -> expr
Rule 91    dim_offset -> empty
Rule 92    expr -> base_var EQUAL expr
Rule 93    expr -> base_var EQUAL BIT_AND expr
Rule 94    expr -> CLONE expr
Rule 95    scalar -> CONST_DECIMAL
Rule 96    scalar -> CONST_DOUBLE
Rule 97    scalar -> CONST_STRING
Rule 98    scalar -> NULL
Rule 99    scalar -> TRUE
Rule 100   scalar -> FALSE
Rule 101   scalar -> PLUS scalar
Rule 102   scalar -> MINUS scalar
Rule 103   scalar -> ARRAY LPAREN scalar_array_pair_list RPAREN
Rule 104   scalar_array_pair_list -> empty
Rule 105   scalar_array_pair_list -> scalar_non_empty_array_pair_list possible_comma
Rule 106   scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar
Rule 107   scalar_non_empty_array_pair_list -> scalar
Rule 108   scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar DOUBLE_ARROW scalar
Rule 109   scalar_non_empty_array_pair_list -> scalar DOUBLE_ARROW scalar
Rule 110   expr -> ARRAY LPAREN array_pair_list RPAREN
Rule 111   array_pair_list -> empty
Rule 112   array_pair_list -> non_empty_array_pair_list possible_comma
Rule 113   possible_comma -> empty
Rule 114   possible_comma -> COMMA
Rule 115   non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND variable
Rule 116   non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr
Rule 117   non_empty_array_pair_list -> BIT_AND variable
Rule 118   non_empty_array_pair_list -> expr
Rule 119   non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW BIT_AND variable
Rule 120   non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW expr
Rule 121   non_empty_array_pair_list -> expr DOUBLE_ARROW BIT_AND variable
Rule 122   non_empty_array_pair_list -> expr DOUBLE_ARROW expr
Rule 123   expr -> variable PLUS_EQ expr
Rule 124   expr -> variable MINUS_EQ expr
Rule 125   expr -> variable MULTIPLY_EQ expr
Rule 126   expr -> variable DIVIDE_EQ expr
Rule 127   expr -> variable DOT_EQ expr
Rule 128   expr -> variable MOD_EQ expr
Rule 129   expr -> expr DOT expr
Rule 130   expr -> expr PLUS expr
Rule 131   expr -> expr MINUS expr
Rule 132   expr -> expr MULT expr
Rule 133   expr -> expr DIV expr
Rule 134   expr -> expr MOD expr
Rule 135   expr -> expr BIT_OR expr
Rule 136   expr -> expr BIT_XOR expr
Rule 137   expr -> expr BIT_AND expr
Rule 138   expr -> expr BIT_LSHIFT expr
Rule 139   expr -> expr BIT_RSHIFT expr
Rule 140   expr -> expr AND_OP jump_marker expr
Rule 141   expr -> expr OR_OP jump_marker expr
Rule 142   expr -> expr IDENTICAL expr
Rule 143   expr -> expr NOT_IDENTICAL expr
Rule 144   expr -> expr EQ_EQ expr
Rule 145   expr -> expr NOT_EQ expr
Rule 146   expr -> expr LESSER expr
Rule 147   expr -> expr LESSER_EQ expr
Rule 148   expr -> expr GREATER expr
Rule 149   expr -> expr GREATER_EQ expr
Rule 150   expr -> expr INSTANCEOF expr
Rule 151   expr -> PLUS expr
Rule 152   expr -> MINUS expr
Rule 153   expr -> BIT_NOT expr
Rule 154   expr -> NOT expr
Rule 155   expr -> CONST_DECIMAL
Rule 156   expr -> CONST_DOUBLE
Rule 157   expr -> CONST_STRING
Rule 158   expr -> NULL
Rule 159   expr -> TRUE
Rule 160   expr -> FALSE
Rule 161   expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
Rule 162   expr -> INC variable
Rule 163   expr -> DEC variable
Rule 164   expr -> variable INC
Rule 165   expr -> variable DEC
Rule 166   expr -> EMPTY LPAREN expr RPAREN
Rule 167   expr -> EVAL LPAREN expr RPAREN
Rule 168   expr -> LPAREN expr RPAREN
Rule 169   expr -> INCLUDE expr
Rule 170   expr -> INCLUDE_ONCE expr
Rule 171   expr -> REQUIRE expr
Rule 172   expr -> REQUIRE_ONCE expr
Rule 173   expr -> EXIT
Rule 174   expr -> EXIT LPAREN RPAREN
Rule 175   expr -> EXIT LPAREN expr RPAREN
Rule 176   expr -> PRINT expr
Rule 177   jump_marker -> empty
Rule 178   goto_marker -> empty
Rule 179   empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
ACCESS_OP            : 
AND                  : 
AND_OP               : 140
ARRAY                : 103 110
AS                   : 37
BIT_AND              : 13 15 39 86 93 115 117 119 121 137
BIT_LSHIFT           : 138
BIT_NOT              : 153
BIT_OR               : 135
BIT_RSHIFT           : 139
BIT_XOR              : 136
BREAK                : 54 55
CALLABLE             : 
CASE                 : 50
CATCH                : 
CLASS                : 
CLONE                : 94
COLON                : 23 24 25 28 36 43 47 48 52 161
COMMA                : 9 33 61 64 69 82 106 108 114 115 116 119 120
COND_COLON           : 
COND_OP              : 161
CONST                : 
CONST_BINARY         : 
CONST_DECIMAL        : 95 155
CONST_DOUBLE         : 96 156
CONST_HEX            : 
CONST_OCTAL          : 
CONST_STRING         : 97 157
CONTINUE             : 56 57
DEC                  : 163 165
DECLARE              : 
DEFAULT              : 51
DIE                  : 
DIV                  : 133
DIVIDE_EQ            : 126
DO                   : 29
DOT                  : 129
DOT_EQ               : 127
DOUBLE_ARROW         : 41 108 109 119 120 121 122
ECHO                 : 68
ELSE                 : 19 23
ELSEIF               : 21 25
EMPTY                : 166
ENDDECLARE           : 
ENDFOR               : 36
ENDFOREACH           : 43
ENDIF                : 22 23
ENDSWITCH            : 47 48
ENDWHILE             : 28
END_TAG              : 
EQUAL                : 14 15 66 92 93
EQ_EQ                : 144
EVAL                 : 167
EXIT                 : 173 174 175
EXPONENT             : 
EXTENDS              : 
FALSE                : 100 160
FINAL                : 
FOR                  : 30
FOREACH              : 37
FUNCTION             : 7
GLOBAL               : 60
GOTO                 : 
GREATER              : 148
GREATER_EQ           : 149
IDENTICAL            : 142
IDENTIFIER           : 12 13 14 15 38 39 61 62 66 67 89
IF                   : 20 24
IMPLEMENTS           : 
INC                  : 162 164
INCLUDE              : 169
INCLUDE_ONCE         : 170
INSTANCEOF           : 150
INSTEADOF            : 
INTERFACE            : 
ISSET                : 
LBRACE               : 7 45 46 71 88
LBRACKET             : 87
LESSER               : 146
LESSER_EQ            : 147
LIST                 : 
LPAREN               : 7 20 21 24 25 26 29 30 37 44 81 103 110 166 167 168 174 175
MINUS                : 102 131 152
MINUS_EQ             : 124
MOD                  : 134
MOD_EQ               : 128
MULT                 : 132
MULTIPLY_EQ          : 125
NAMESPACE            : 
NEW                  : 
NOT                  : 154
NOT_EQ               : 145
NOT_IDENTICAL        : 143
NULL                 : 98 158
OR                   : 
OR_OP                : 141
PLUS                 : 101 130 151
PLUS_EQ              : 123
PRINT                : 176
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
QUOTE                : 
RBRACE               : 7 45 46 71 88
RBRACKET             : 87
REQUIRE              : 171
REQUIRE_ONCE         : 172
RETURN               : 58 59
RPAREN               : 7 20 21 24 25 26 29 30 37 44 81 103 110 166 167 168 174 175
SEMICOLON            : 22 23 28 29 30 30 36 43 46 47 48 48 53 54 55 56 57 58 59 60 63 68 72 73
START_TAG            : 
STATIC               : 63
STRING               : 7 81
SWITCH               : 44
THROW                : 
TRAIT                : 
TRUE                 : 99 159
TRY                  : 
UNSET                : 
USE                  : 
VAR                  : 
WHILE                : 26 29
XOR                  : 
__CLASS__            : 
__DIR__              : 
__FILE__             : 
__FUNCTION__         : 
__HALT_COMPILER      : 
__LINE__             : 
__METHOD__           : 
__NAMESPACE__        : 
__TRAIT__            : 
error                : 

Nonterminals, with rules where they appear

alt_if_stmt          : 17
alt_if_stmt_without_else : 22 23 25
array_pair_list      : 110
base_var             : 79 87 88 92 93
case_separator       : 50 51
case_stmt            : 45 46 47 48 50 51
dim_offset           : 87
echo_expr_list       : 68 69
empty                : 2 4 8 11 31 40 49 75 84 91 104 111 113 177 178
expr                 : 20 21 24 25 26 29 33 34 37 44 50 55 57 59 69 70 73 85 88 90 92 93 94 116 118 119 120 120 121 122 122 123 124 125 126 127 128 129 129 130 130 131 131 132 132 133 133 134 134 135 135 136 136 137 137 138 138 139 139 140 140 141 141 142 142 143 143 144 144 145 145 146 146 147 147 148 148 149 149 150 150 151 152 153 154 161 161 161 166 167 168 169 170 171 172 175 176
for_expr             : 30 30 30
for_stmt             : 30
foreach_arg          : 37
foreach_stmt         : 37
foreach_var          : 37 41
func_call            : 80
func_decl            : 6 77
func_param           : 82 83
func_params          : 81 82
func_table_marker    : 7
global_var_list      : 60 61
goto_marker          : 7 19 21 23 25 26 30 30 44 54 55 56 57 161
if_stmt              : 16
if_stmt_without_else : 18 19 21
inner_stmt           : 74
inner_stmts          : 7 23 24 25 28 36 43 50 51 71 74
jump_marker          : 3 7 7 19 20 21 21 23 24 25 25 26 26 30 30 30 44 50 51 74 140 141 161 161
non_empty_array_pair_list : 112 115 116 119 120
non_empty_for_expr   : 32 33
param                : 9 10
params               : 7 9
possible_comma       : 105 112
scalar               : 14 15 66 101 102 106 107 108 108 109 109
scalar_array_pair_list : 103
scalar_non_empty_array_pair_list : 105 106 108
start                : 0
start_marker         : 1
static_var           : 64 65
static_var_list      : 63 64
stmt                 : 5 19 20 21 27 29 35 42 76
stmt_list            : 1 3
switch_stmt          : 44
top_stmt             : 3
variable             : 78 86 115 117 119 121 123 124 125 126 127 128 162 163 164 165
while_stmt           : 26


Parsing method: LALR


state 0

    (0) S' -> . start
    (1) start -> . start_marker stmt_list
    (2) start_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    $end            reduce using rule 179 (empty -> .)


    start                          shift and go to state 1
    start_marker                   shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> start .




state 2

    (1) start -> start_marker . stmt_list
    (3) stmt_list -> . top_stmt jump_marker stmt_list
    (4) stmt_list -> . empty
    (5) top_stmt -> . stmt
    (6) top_stmt -> . func_decl
    (179) empty -> .
    (16) stmt -> . if_stmt
    (17) stmt -> . alt_if_stmt
    (26) stmt -> . WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker
    (29) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (30) stmt -> . FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (37) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (44) stmt -> . SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker
    (54) stmt -> . BREAK goto_marker SEMICOLON
    (55) stmt -> . BREAK expr goto_marker SEMICOLON
    (56) stmt -> . CONTINUE goto_marker SEMICOLON
    (57) stmt -> . CONTINUE expr goto_marker SEMICOLON
    (58) stmt -> . RETURN SEMICOLON
    (59) stmt -> . RETURN expr SEMICOLON
    (60) stmt -> . GLOBAL global_var_list SEMICOLON
    (63) stmt -> . STATIC static_var_list SEMICOLON
    (68) stmt -> . ECHO echo_expr_list SEMICOLON
    (71) stmt -> . LBRACE inner_stmts RBRACE
    (72) stmt -> . SEMICOLON
    (73) stmt -> . expr SEMICOLON
    (7) func_decl -> . FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker
    (18) if_stmt -> . if_stmt_without_else
    (19) if_stmt -> . if_stmt_without_else ELSE goto_marker jump_marker stmt
    (22) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (23) alt_if_stmt -> . alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (20) if_stmt_without_else -> . IF LPAREN expr RPAREN jump_marker stmt
    (21) if_stmt_without_else -> . if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON jump_marker inner_stmts
    (25) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    $end            reduce using rule 179 (empty -> .)
    WHILE           shift and go to state 33
    DO              shift and go to state 49
    FOR             shift and go to state 24
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 36
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 30
    RETURN          shift and go to state 16
    GLOBAL          shift and go to state 32
    STATIC          shift and go to state 18
    ECHO            shift and go to state 27
    LBRACE          shift and go to state 29
    SEMICOLON       shift and go to state 35
    FUNCTION        shift and go to state 23
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    func_call                      shift and go to state 40
    empty                          shift and go to state 39
    func_decl                      shift and go to state 41
    alt_if_stmt                    shift and go to state 25
    stmt                           shift and go to state 26
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    stmt_list                      shift and go to state 55
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 13
    expr                           shift and go to state 45
    top_stmt                       shift and go to state 15

state 3

    (2) start_marker -> empty .

    WHILE           reduce using rule 2 (start_marker -> empty .)
    DO              reduce using rule 2 (start_marker -> empty .)
    FOR             reduce using rule 2 (start_marker -> empty .)
    FOREACH         reduce using rule 2 (start_marker -> empty .)
    SWITCH          reduce using rule 2 (start_marker -> empty .)
    BREAK           reduce using rule 2 (start_marker -> empty .)
    CONTINUE        reduce using rule 2 (start_marker -> empty .)
    RETURN          reduce using rule 2 (start_marker -> empty .)
    GLOBAL          reduce using rule 2 (start_marker -> empty .)
    STATIC          reduce using rule 2 (start_marker -> empty .)
    ECHO            reduce using rule 2 (start_marker -> empty .)
    LBRACE          reduce using rule 2 (start_marker -> empty .)
    SEMICOLON       reduce using rule 2 (start_marker -> empty .)
    FUNCTION        reduce using rule 2 (start_marker -> empty .)
    CLONE           reduce using rule 2 (start_marker -> empty .)
    ARRAY           reduce using rule 2 (start_marker -> empty .)
    PLUS            reduce using rule 2 (start_marker -> empty .)
    MINUS           reduce using rule 2 (start_marker -> empty .)
    BIT_NOT         reduce using rule 2 (start_marker -> empty .)
    NOT             reduce using rule 2 (start_marker -> empty .)
    CONST_DECIMAL   reduce using rule 2 (start_marker -> empty .)
    CONST_DOUBLE    reduce using rule 2 (start_marker -> empty .)
    CONST_STRING    reduce using rule 2 (start_marker -> empty .)
    NULL            reduce using rule 2 (start_marker -> empty .)
    TRUE            reduce using rule 2 (start_marker -> empty .)
    FALSE           reduce using rule 2 (start_marker -> empty .)
    INC             reduce using rule 2 (start_marker -> empty .)
    DEC             reduce using rule 2 (start_marker -> empty .)
    EMPTY           reduce using rule 2 (start_marker -> empty .)
    EVAL            reduce using rule 2 (start_marker -> empty .)
    LPAREN          reduce using rule 2 (start_marker -> empty .)
    INCLUDE         reduce using rule 2 (start_marker -> empty .)
    INCLUDE_ONCE    reduce using rule 2 (start_marker -> empty .)
    REQUIRE         reduce using rule 2 (start_marker -> empty .)
    REQUIRE_ONCE    reduce using rule 2 (start_marker -> empty .)
    EXIT            reduce using rule 2 (start_marker -> empty .)
    PRINT           reduce using rule 2 (start_marker -> empty .)
    IF              reduce using rule 2 (start_marker -> empty .)
    IDENTIFIER      reduce using rule 2 (start_marker -> empty .)
    STRING          reduce using rule 2 (start_marker -> empty .)
    $end            reduce using rule 2 (start_marker -> empty .)



state 4

    (22) alt_if_stmt -> alt_if_stmt_without_else . ENDIF SEMICOLON
    (23) alt_if_stmt -> alt_if_stmt_without_else . ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
    (25) alt_if_stmt_without_else -> alt_if_stmt_without_else . ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts

    ENDIF           shift and go to state 58
    ELSE            shift and go to state 57
    ELSEIF          shift and go to state 59



state 5

    (159) expr -> TRUE .

    DOT             reduce using rule 159 (expr -> TRUE .)
    PLUS            reduce using rule 159 (expr -> TRUE .)
    MINUS           reduce using rule 159 (expr -> TRUE .)
    MULT            reduce using rule 159 (expr -> TRUE .)
    DIV             reduce using rule 159 (expr -> TRUE .)
    MOD             reduce using rule 159 (expr -> TRUE .)
    BIT_OR          reduce using rule 159 (expr -> TRUE .)
    BIT_XOR         reduce using rule 159 (expr -> TRUE .)
    BIT_AND         reduce using rule 159 (expr -> TRUE .)
    BIT_LSHIFT      reduce using rule 159 (expr -> TRUE .)
    BIT_RSHIFT      reduce using rule 159 (expr -> TRUE .)
    AND_OP          reduce using rule 159 (expr -> TRUE .)
    OR_OP           reduce using rule 159 (expr -> TRUE .)
    IDENTICAL       reduce using rule 159 (expr -> TRUE .)
    NOT_IDENTICAL   reduce using rule 159 (expr -> TRUE .)
    EQ_EQ           reduce using rule 159 (expr -> TRUE .)
    NOT_EQ          reduce using rule 159 (expr -> TRUE .)
    LESSER          reduce using rule 159 (expr -> TRUE .)
    LESSER_EQ       reduce using rule 159 (expr -> TRUE .)
    GREATER         reduce using rule 159 (expr -> TRUE .)
    GREATER_EQ      reduce using rule 159 (expr -> TRUE .)
    INSTANCEOF      reduce using rule 159 (expr -> TRUE .)
    COND_OP         reduce using rule 159 (expr -> TRUE .)
    SEMICOLON       reduce using rule 159 (expr -> TRUE .)
    COMMA           reduce using rule 159 (expr -> TRUE .)
    RPAREN          reduce using rule 159 (expr -> TRUE .)
    AS              reduce using rule 159 (expr -> TRUE .)
    DOUBLE_ARROW    reduce using rule 159 (expr -> TRUE .)
    RBRACE          reduce using rule 159 (expr -> TRUE .)
    RBRACKET        reduce using rule 159 (expr -> TRUE .)
    COLON           reduce using rule 159 (expr -> TRUE .)



state 6

    (152) expr -> MINUS . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 60
    variable                       shift and go to state 53

state 7

    (155) expr -> CONST_DECIMAL .

    DOT             reduce using rule 155 (expr -> CONST_DECIMAL .)
    PLUS            reduce using rule 155 (expr -> CONST_DECIMAL .)
    MINUS           reduce using rule 155 (expr -> CONST_DECIMAL .)
    MULT            reduce using rule 155 (expr -> CONST_DECIMAL .)
    DIV             reduce using rule 155 (expr -> CONST_DECIMAL .)
    MOD             reduce using rule 155 (expr -> CONST_DECIMAL .)
    BIT_OR          reduce using rule 155 (expr -> CONST_DECIMAL .)
    BIT_XOR         reduce using rule 155 (expr -> CONST_DECIMAL .)
    BIT_AND         reduce using rule 155 (expr -> CONST_DECIMAL .)
    BIT_LSHIFT      reduce using rule 155 (expr -> CONST_DECIMAL .)
    BIT_RSHIFT      reduce using rule 155 (expr -> CONST_DECIMAL .)
    AND_OP          reduce using rule 155 (expr -> CONST_DECIMAL .)
    OR_OP           reduce using rule 155 (expr -> CONST_DECIMAL .)
    IDENTICAL       reduce using rule 155 (expr -> CONST_DECIMAL .)
    NOT_IDENTICAL   reduce using rule 155 (expr -> CONST_DECIMAL .)
    EQ_EQ           reduce using rule 155 (expr -> CONST_DECIMAL .)
    NOT_EQ          reduce using rule 155 (expr -> CONST_DECIMAL .)
    LESSER          reduce using rule 155 (expr -> CONST_DECIMAL .)
    LESSER_EQ       reduce using rule 155 (expr -> CONST_DECIMAL .)
    GREATER         reduce using rule 155 (expr -> CONST_DECIMAL .)
    GREATER_EQ      reduce using rule 155 (expr -> CONST_DECIMAL .)
    INSTANCEOF      reduce using rule 155 (expr -> CONST_DECIMAL .)
    COND_OP         reduce using rule 155 (expr -> CONST_DECIMAL .)
    SEMICOLON       reduce using rule 155 (expr -> CONST_DECIMAL .)
    COMMA           reduce using rule 155 (expr -> CONST_DECIMAL .)
    RPAREN          reduce using rule 155 (expr -> CONST_DECIMAL .)
    AS              reduce using rule 155 (expr -> CONST_DECIMAL .)
    DOUBLE_ARROW    reduce using rule 155 (expr -> CONST_DECIMAL .)
    RBRACE          reduce using rule 155 (expr -> CONST_DECIMAL .)
    RBRACKET        reduce using rule 155 (expr -> CONST_DECIMAL .)
    COLON           reduce using rule 155 (expr -> CONST_DECIMAL .)



state 8

    (151) expr -> PLUS . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 61
    variable                       shift and go to state 53

state 9

    (153) expr -> BIT_NOT . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 62
    variable                       shift and go to state 53

state 10

    (37) stmt -> FOREACH . LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt

    LPAREN          shift and go to state 63



state 11

    (167) expr -> EVAL . LPAREN expr RPAREN

    LPAREN          shift and go to state 64



state 12

    (170) expr -> INCLUDE_ONCE . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 65
    variable                       shift and go to state 53

state 13

    (16) stmt -> if_stmt .

    WHILE           reduce using rule 16 (stmt -> if_stmt .)
    DO              reduce using rule 16 (stmt -> if_stmt .)
    FOR             reduce using rule 16 (stmt -> if_stmt .)
    FOREACH         reduce using rule 16 (stmt -> if_stmt .)
    SWITCH          reduce using rule 16 (stmt -> if_stmt .)
    BREAK           reduce using rule 16 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 16 (stmt -> if_stmt .)
    RETURN          reduce using rule 16 (stmt -> if_stmt .)
    GLOBAL          reduce using rule 16 (stmt -> if_stmt .)
    STATIC          reduce using rule 16 (stmt -> if_stmt .)
    ECHO            reduce using rule 16 (stmt -> if_stmt .)
    LBRACE          reduce using rule 16 (stmt -> if_stmt .)
    SEMICOLON       reduce using rule 16 (stmt -> if_stmt .)
    FUNCTION        reduce using rule 16 (stmt -> if_stmt .)
    CLONE           reduce using rule 16 (stmt -> if_stmt .)
    ARRAY           reduce using rule 16 (stmt -> if_stmt .)
    PLUS            reduce using rule 16 (stmt -> if_stmt .)
    MINUS           reduce using rule 16 (stmt -> if_stmt .)
    BIT_NOT         reduce using rule 16 (stmt -> if_stmt .)
    NOT             reduce using rule 16 (stmt -> if_stmt .)
    CONST_DECIMAL   reduce using rule 16 (stmt -> if_stmt .)
    CONST_DOUBLE    reduce using rule 16 (stmt -> if_stmt .)
    CONST_STRING    reduce using rule 16 (stmt -> if_stmt .)
    NULL            reduce using rule 16 (stmt -> if_stmt .)
    TRUE            reduce using rule 16 (stmt -> if_stmt .)
    FALSE           reduce using rule 16 (stmt -> if_stmt .)
    INC             reduce using rule 16 (stmt -> if_stmt .)
    DEC             reduce using rule 16 (stmt -> if_stmt .)
    EMPTY           reduce using rule 16 (stmt -> if_stmt .)
    EVAL            reduce using rule 16 (stmt -> if_stmt .)
    LPAREN          reduce using rule 16 (stmt -> if_stmt .)
    INCLUDE         reduce using rule 16 (stmt -> if_stmt .)
    INCLUDE_ONCE    reduce using rule 16 (stmt -> if_stmt .)
    REQUIRE         reduce using rule 16 (stmt -> if_stmt .)
    REQUIRE_ONCE    reduce using rule 16 (stmt -> if_stmt .)
    EXIT            reduce using rule 16 (stmt -> if_stmt .)
    PRINT           reduce using rule 16 (stmt -> if_stmt .)
    IF              reduce using rule 16 (stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 16 (stmt -> if_stmt .)
    STRING          reduce using rule 16 (stmt -> if_stmt .)
    $end            reduce using rule 16 (stmt -> if_stmt .)
    RBRACE          reduce using rule 16 (stmt -> if_stmt .)
    ENDIF           reduce using rule 16 (stmt -> if_stmt .)
    ELSE            reduce using rule 16 (stmt -> if_stmt .)
    ELSEIF          reduce using rule 16 (stmt -> if_stmt .)
    ENDWHILE        reduce using rule 16 (stmt -> if_stmt .)
    ENDFOREACH      reduce using rule 16 (stmt -> if_stmt .)
    CASE            reduce using rule 16 (stmt -> if_stmt .)
    DEFAULT         reduce using rule 16 (stmt -> if_stmt .)
    ENDSWITCH       reduce using rule 16 (stmt -> if_stmt .)
    ENDFOR          reduce using rule 16 (stmt -> if_stmt .)



state 14

    (94) expr -> CLONE . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 66
    variable                       shift and go to state 53

state 15

    (3) stmt_list -> top_stmt . jump_marker stmt_list
    (177) jump_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    $end            reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 67
    empty                          shift and go to state 68

state 16

    (58) stmt -> RETURN . SEMICOLON
    (59) stmt -> RETURN . expr SEMICOLON
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    SEMICOLON       shift and go to state 69
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 70
    variable                       shift and go to state 53

state 17

    (171) expr -> REQUIRE . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 71
    variable                       shift and go to state 53

state 18

    (63) stmt -> STATIC . static_var_list SEMICOLON
    (64) static_var_list -> . static_var_list COMMA static_var
    (65) static_var_list -> . static_var
    (66) static_var -> . IDENTIFIER EQUAL scalar
    (67) static_var -> . IDENTIFIER

    IDENTIFIER      shift and go to state 74


    static_var                     shift and go to state 72
    static_var_list                shift and go to state 73

state 19

    (176) expr -> PRINT . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 75
    variable                       shift and go to state 53

state 20

    (163) expr -> DEC . variable
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    base_var                       shift and go to state 76
    func_call                      shift and go to state 40
    variable                       shift and go to state 77

state 21

    (166) expr -> EMPTY . LPAREN expr RPAREN

    LPAREN          shift and go to state 78



state 22

    (156) expr -> CONST_DOUBLE .

    DOT             reduce using rule 156 (expr -> CONST_DOUBLE .)
    PLUS            reduce using rule 156 (expr -> CONST_DOUBLE .)
    MINUS           reduce using rule 156 (expr -> CONST_DOUBLE .)
    MULT            reduce using rule 156 (expr -> CONST_DOUBLE .)
    DIV             reduce using rule 156 (expr -> CONST_DOUBLE .)
    MOD             reduce using rule 156 (expr -> CONST_DOUBLE .)
    BIT_OR          reduce using rule 156 (expr -> CONST_DOUBLE .)
    BIT_XOR         reduce using rule 156 (expr -> CONST_DOUBLE .)
    BIT_AND         reduce using rule 156 (expr -> CONST_DOUBLE .)
    BIT_LSHIFT      reduce using rule 156 (expr -> CONST_DOUBLE .)
    BIT_RSHIFT      reduce using rule 156 (expr -> CONST_DOUBLE .)
    AND_OP          reduce using rule 156 (expr -> CONST_DOUBLE .)
    OR_OP           reduce using rule 156 (expr -> CONST_DOUBLE .)
    IDENTICAL       reduce using rule 156 (expr -> CONST_DOUBLE .)
    NOT_IDENTICAL   reduce using rule 156 (expr -> CONST_DOUBLE .)
    EQ_EQ           reduce using rule 156 (expr -> CONST_DOUBLE .)
    NOT_EQ          reduce using rule 156 (expr -> CONST_DOUBLE .)
    LESSER          reduce using rule 156 (expr -> CONST_DOUBLE .)
    LESSER_EQ       reduce using rule 156 (expr -> CONST_DOUBLE .)
    GREATER         reduce using rule 156 (expr -> CONST_DOUBLE .)
    GREATER_EQ      reduce using rule 156 (expr -> CONST_DOUBLE .)
    INSTANCEOF      reduce using rule 156 (expr -> CONST_DOUBLE .)
    COND_OP         reduce using rule 156 (expr -> CONST_DOUBLE .)
    SEMICOLON       reduce using rule 156 (expr -> CONST_DOUBLE .)
    COMMA           reduce using rule 156 (expr -> CONST_DOUBLE .)
    RPAREN          reduce using rule 156 (expr -> CONST_DOUBLE .)
    AS              reduce using rule 156 (expr -> CONST_DOUBLE .)
    DOUBLE_ARROW    reduce using rule 156 (expr -> CONST_DOUBLE .)
    RBRACE          reduce using rule 156 (expr -> CONST_DOUBLE .)
    RBRACKET        reduce using rule 156 (expr -> CONST_DOUBLE .)
    COLON           reduce using rule 156 (expr -> CONST_DOUBLE .)



state 23

    (7) func_decl -> FUNCTION . goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker
    (178) goto_marker -> . empty
    (179) empty -> .

    STRING          reduce using rule 179 (empty -> .)


    goto_marker                    shift and go to state 79
    empty                          shift and go to state 80

state 24

    (30) stmt -> FOR . LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker

    LPAREN          shift and go to state 81



state 25

    (17) stmt -> alt_if_stmt .

    WHILE           reduce using rule 17 (stmt -> alt_if_stmt .)
    DO              reduce using rule 17 (stmt -> alt_if_stmt .)
    FOR             reduce using rule 17 (stmt -> alt_if_stmt .)
    FOREACH         reduce using rule 17 (stmt -> alt_if_stmt .)
    SWITCH          reduce using rule 17 (stmt -> alt_if_stmt .)
    BREAK           reduce using rule 17 (stmt -> alt_if_stmt .)
    CONTINUE        reduce using rule 17 (stmt -> alt_if_stmt .)
    RETURN          reduce using rule 17 (stmt -> alt_if_stmt .)
    GLOBAL          reduce using rule 17 (stmt -> alt_if_stmt .)
    STATIC          reduce using rule 17 (stmt -> alt_if_stmt .)
    ECHO            reduce using rule 17 (stmt -> alt_if_stmt .)
    LBRACE          reduce using rule 17 (stmt -> alt_if_stmt .)
    SEMICOLON       reduce using rule 17 (stmt -> alt_if_stmt .)
    FUNCTION        reduce using rule 17 (stmt -> alt_if_stmt .)
    CLONE           reduce using rule 17 (stmt -> alt_if_stmt .)
    ARRAY           reduce using rule 17 (stmt -> alt_if_stmt .)
    PLUS            reduce using rule 17 (stmt -> alt_if_stmt .)
    MINUS           reduce using rule 17 (stmt -> alt_if_stmt .)
    BIT_NOT         reduce using rule 17 (stmt -> alt_if_stmt .)
    NOT             reduce using rule 17 (stmt -> alt_if_stmt .)
    CONST_DECIMAL   reduce using rule 17 (stmt -> alt_if_stmt .)
    CONST_DOUBLE    reduce using rule 17 (stmt -> alt_if_stmt .)
    CONST_STRING    reduce using rule 17 (stmt -> alt_if_stmt .)
    NULL            reduce using rule 17 (stmt -> alt_if_stmt .)
    TRUE            reduce using rule 17 (stmt -> alt_if_stmt .)
    FALSE           reduce using rule 17 (stmt -> alt_if_stmt .)
    INC             reduce using rule 17 (stmt -> alt_if_stmt .)
    DEC             reduce using rule 17 (stmt -> alt_if_stmt .)
    EMPTY           reduce using rule 17 (stmt -> alt_if_stmt .)
    EVAL            reduce using rule 17 (stmt -> alt_if_stmt .)
    LPAREN          reduce using rule 17 (stmt -> alt_if_stmt .)
    INCLUDE         reduce using rule 17 (stmt -> alt_if_stmt .)
    INCLUDE_ONCE    reduce using rule 17 (stmt -> alt_if_stmt .)
    REQUIRE         reduce using rule 17 (stmt -> alt_if_stmt .)
    REQUIRE_ONCE    reduce using rule 17 (stmt -> alt_if_stmt .)
    EXIT            reduce using rule 17 (stmt -> alt_if_stmt .)
    PRINT           reduce using rule 17 (stmt -> alt_if_stmt .)
    IF              reduce using rule 17 (stmt -> alt_if_stmt .)
    IDENTIFIER      reduce using rule 17 (stmt -> alt_if_stmt .)
    STRING          reduce using rule 17 (stmt -> alt_if_stmt .)
    $end            reduce using rule 17 (stmt -> alt_if_stmt .)
    RBRACE          reduce using rule 17 (stmt -> alt_if_stmt .)
    ENDIF           reduce using rule 17 (stmt -> alt_if_stmt .)
    ELSE            reduce using rule 17 (stmt -> alt_if_stmt .)
    ELSEIF          reduce using rule 17 (stmt -> alt_if_stmt .)
    ENDWHILE        reduce using rule 17 (stmt -> alt_if_stmt .)
    ENDFOREACH      reduce using rule 17 (stmt -> alt_if_stmt .)
    CASE            reduce using rule 17 (stmt -> alt_if_stmt .)
    DEFAULT         reduce using rule 17 (stmt -> alt_if_stmt .)
    ENDSWITCH       reduce using rule 17 (stmt -> alt_if_stmt .)
    ENDFOR          reduce using rule 17 (stmt -> alt_if_stmt .)



state 26

    (5) top_stmt -> stmt .

    WHILE           reduce using rule 5 (top_stmt -> stmt .)
    DO              reduce using rule 5 (top_stmt -> stmt .)
    FOR             reduce using rule 5 (top_stmt -> stmt .)
    FOREACH         reduce using rule 5 (top_stmt -> stmt .)
    SWITCH          reduce using rule 5 (top_stmt -> stmt .)
    BREAK           reduce using rule 5 (top_stmt -> stmt .)
    CONTINUE        reduce using rule 5 (top_stmt -> stmt .)
    RETURN          reduce using rule 5 (top_stmt -> stmt .)
    GLOBAL          reduce using rule 5 (top_stmt -> stmt .)
    STATIC          reduce using rule 5 (top_stmt -> stmt .)
    ECHO            reduce using rule 5 (top_stmt -> stmt .)
    LBRACE          reduce using rule 5 (top_stmt -> stmt .)
    SEMICOLON       reduce using rule 5 (top_stmt -> stmt .)
    FUNCTION        reduce using rule 5 (top_stmt -> stmt .)
    CLONE           reduce using rule 5 (top_stmt -> stmt .)
    ARRAY           reduce using rule 5 (top_stmt -> stmt .)
    PLUS            reduce using rule 5 (top_stmt -> stmt .)
    MINUS           reduce using rule 5 (top_stmt -> stmt .)
    BIT_NOT         reduce using rule 5 (top_stmt -> stmt .)
    NOT             reduce using rule 5 (top_stmt -> stmt .)
    CONST_DECIMAL   reduce using rule 5 (top_stmt -> stmt .)
    CONST_DOUBLE    reduce using rule 5 (top_stmt -> stmt .)
    CONST_STRING    reduce using rule 5 (top_stmt -> stmt .)
    NULL            reduce using rule 5 (top_stmt -> stmt .)
    TRUE            reduce using rule 5 (top_stmt -> stmt .)
    FALSE           reduce using rule 5 (top_stmt -> stmt .)
    INC             reduce using rule 5 (top_stmt -> stmt .)
    DEC             reduce using rule 5 (top_stmt -> stmt .)
    EMPTY           reduce using rule 5 (top_stmt -> stmt .)
    EVAL            reduce using rule 5 (top_stmt -> stmt .)
    LPAREN          reduce using rule 5 (top_stmt -> stmt .)
    INCLUDE         reduce using rule 5 (top_stmt -> stmt .)
    INCLUDE_ONCE    reduce using rule 5 (top_stmt -> stmt .)
    REQUIRE         reduce using rule 5 (top_stmt -> stmt .)
    REQUIRE_ONCE    reduce using rule 5 (top_stmt -> stmt .)
    EXIT            reduce using rule 5 (top_stmt -> stmt .)
    PRINT           reduce using rule 5 (top_stmt -> stmt .)
    IF              reduce using rule 5 (top_stmt -> stmt .)
    IDENTIFIER      reduce using rule 5 (top_stmt -> stmt .)
    STRING          reduce using rule 5 (top_stmt -> stmt .)
    $end            reduce using rule 5 (top_stmt -> stmt .)



state 27

    (68) stmt -> ECHO . echo_expr_list SEMICOLON
    (69) echo_expr_list -> . echo_expr_list COMMA expr
    (70) echo_expr_list -> . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    echo_expr_list                 shift and go to state 82
    expr                           shift and go to state 83
    variable                       shift and go to state 53

state 28

    (172) expr -> REQUIRE_ONCE . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 84
    variable                       shift and go to state 53

state 29

    (71) stmt -> LBRACE . inner_stmts RBRACE
    (74) inner_stmts -> . inner_stmts jump_marker inner_stmt
    (75) inner_stmts -> . empty
    (179) empty -> .

    RBRACE          reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    inner_stmts                    shift and go to state 85
    empty                          shift and go to state 86

state 30

    (56) stmt -> CONTINUE . goto_marker SEMICOLON
    (57) stmt -> CONTINUE . expr goto_marker SEMICOLON
    (178) goto_marker -> . empty
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (179) empty -> .
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    SEMICOLON       reduce using rule 179 (empty -> .)
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    goto_marker                    shift and go to state 87
    base_var                       shift and go to state 43
    expr                           shift and go to state 88
    empty                          shift and go to state 80
    variable                       shift and go to state 53

state 31

    (154) expr -> NOT . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 89
    variable                       shift and go to state 53

state 32

    (60) stmt -> GLOBAL . global_var_list SEMICOLON
    (61) global_var_list -> . global_var_list COMMA IDENTIFIER
    (62) global_var_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 90


    global_var_list                shift and go to state 91

state 33

    (26) stmt -> WHILE . LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker

    LPAREN          shift and go to state 92



state 34

    (169) expr -> INCLUDE . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 93
    variable                       shift and go to state 53

state 35

    (72) stmt -> SEMICOLON .

    WHILE           reduce using rule 72 (stmt -> SEMICOLON .)
    DO              reduce using rule 72 (stmt -> SEMICOLON .)
    FOR             reduce using rule 72 (stmt -> SEMICOLON .)
    FOREACH         reduce using rule 72 (stmt -> SEMICOLON .)
    SWITCH          reduce using rule 72 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 72 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 72 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 72 (stmt -> SEMICOLON .)
    GLOBAL          reduce using rule 72 (stmt -> SEMICOLON .)
    STATIC          reduce using rule 72 (stmt -> SEMICOLON .)
    ECHO            reduce using rule 72 (stmt -> SEMICOLON .)
    LBRACE          reduce using rule 72 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 72 (stmt -> SEMICOLON .)
    FUNCTION        reduce using rule 72 (stmt -> SEMICOLON .)
    CLONE           reduce using rule 72 (stmt -> SEMICOLON .)
    ARRAY           reduce using rule 72 (stmt -> SEMICOLON .)
    PLUS            reduce using rule 72 (stmt -> SEMICOLON .)
    MINUS           reduce using rule 72 (stmt -> SEMICOLON .)
    BIT_NOT         reduce using rule 72 (stmt -> SEMICOLON .)
    NOT             reduce using rule 72 (stmt -> SEMICOLON .)
    CONST_DECIMAL   reduce using rule 72 (stmt -> SEMICOLON .)
    CONST_DOUBLE    reduce using rule 72 (stmt -> SEMICOLON .)
    CONST_STRING    reduce using rule 72 (stmt -> SEMICOLON .)
    NULL            reduce using rule 72 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 72 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 72 (stmt -> SEMICOLON .)
    INC             reduce using rule 72 (stmt -> SEMICOLON .)
    DEC             reduce using rule 72 (stmt -> SEMICOLON .)
    EMPTY           reduce using rule 72 (stmt -> SEMICOLON .)
    EVAL            reduce using rule 72 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 72 (stmt -> SEMICOLON .)
    INCLUDE         reduce using rule 72 (stmt -> SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 72 (stmt -> SEMICOLON .)
    REQUIRE         reduce using rule 72 (stmt -> SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 72 (stmt -> SEMICOLON .)
    EXIT            reduce using rule 72 (stmt -> SEMICOLON .)
    PRINT           reduce using rule 72 (stmt -> SEMICOLON .)
    IF              reduce using rule 72 (stmt -> SEMICOLON .)
    IDENTIFIER      reduce using rule 72 (stmt -> SEMICOLON .)
    STRING          reduce using rule 72 (stmt -> SEMICOLON .)
    $end            reduce using rule 72 (stmt -> SEMICOLON .)
    RBRACE          reduce using rule 72 (stmt -> SEMICOLON .)
    ENDIF           reduce using rule 72 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 72 (stmt -> SEMICOLON .)
    ELSEIF          reduce using rule 72 (stmt -> SEMICOLON .)
    ENDWHILE        reduce using rule 72 (stmt -> SEMICOLON .)
    ENDFOREACH      reduce using rule 72 (stmt -> SEMICOLON .)
    CASE            reduce using rule 72 (stmt -> SEMICOLON .)
    DEFAULT         reduce using rule 72 (stmt -> SEMICOLON .)
    ENDSWITCH       reduce using rule 72 (stmt -> SEMICOLON .)
    ENDFOR          reduce using rule 72 (stmt -> SEMICOLON .)



state 36

    (44) stmt -> SWITCH . LPAREN expr RPAREN goto_marker switch_stmt jump_marker

    LPAREN          shift and go to state 94



state 37

    (110) expr -> ARRAY . LPAREN array_pair_list RPAREN

    LPAREN          shift and go to state 95



state 38

    (89) base_var -> IDENTIFIER .

    EQUAL           reduce using rule 89 (base_var -> IDENTIFIER .)
    LBRACKET        reduce using rule 89 (base_var -> IDENTIFIER .)
    LBRACE          reduce using rule 89 (base_var -> IDENTIFIER .)
    PLUS_EQ         reduce using rule 89 (base_var -> IDENTIFIER .)
    MINUS_EQ        reduce using rule 89 (base_var -> IDENTIFIER .)
    MULTIPLY_EQ     reduce using rule 89 (base_var -> IDENTIFIER .)
    DIVIDE_EQ       reduce using rule 89 (base_var -> IDENTIFIER .)
    DOT_EQ          reduce using rule 89 (base_var -> IDENTIFIER .)
    MOD_EQ          reduce using rule 89 (base_var -> IDENTIFIER .)
    INC             reduce using rule 89 (base_var -> IDENTIFIER .)
    DEC             reduce using rule 89 (base_var -> IDENTIFIER .)
    DOT             reduce using rule 89 (base_var -> IDENTIFIER .)
    PLUS            reduce using rule 89 (base_var -> IDENTIFIER .)
    MINUS           reduce using rule 89 (base_var -> IDENTIFIER .)
    MULT            reduce using rule 89 (base_var -> IDENTIFIER .)
    DIV             reduce using rule 89 (base_var -> IDENTIFIER .)
    MOD             reduce using rule 89 (base_var -> IDENTIFIER .)
    BIT_OR          reduce using rule 89 (base_var -> IDENTIFIER .)
    BIT_XOR         reduce using rule 89 (base_var -> IDENTIFIER .)
    BIT_AND         reduce using rule 89 (base_var -> IDENTIFIER .)
    BIT_LSHIFT      reduce using rule 89 (base_var -> IDENTIFIER .)
    BIT_RSHIFT      reduce using rule 89 (base_var -> IDENTIFIER .)
    AND_OP          reduce using rule 89 (base_var -> IDENTIFIER .)
    OR_OP           reduce using rule 89 (base_var -> IDENTIFIER .)
    IDENTICAL       reduce using rule 89 (base_var -> IDENTIFIER .)
    NOT_IDENTICAL   reduce using rule 89 (base_var -> IDENTIFIER .)
    EQ_EQ           reduce using rule 89 (base_var -> IDENTIFIER .)
    NOT_EQ          reduce using rule 89 (base_var -> IDENTIFIER .)
    LESSER          reduce using rule 89 (base_var -> IDENTIFIER .)
    LESSER_EQ       reduce using rule 89 (base_var -> IDENTIFIER .)
    GREATER         reduce using rule 89 (base_var -> IDENTIFIER .)
    GREATER_EQ      reduce using rule 89 (base_var -> IDENTIFIER .)
    INSTANCEOF      reduce using rule 89 (base_var -> IDENTIFIER .)
    COND_OP         reduce using rule 89 (base_var -> IDENTIFIER .)
    COLON           reduce using rule 89 (base_var -> IDENTIFIER .)
    SEMICOLON       reduce using rule 89 (base_var -> IDENTIFIER .)
    COMMA           reduce using rule 89 (base_var -> IDENTIFIER .)
    RPAREN          reduce using rule 89 (base_var -> IDENTIFIER .)
    AS              reduce using rule 89 (base_var -> IDENTIFIER .)
    DOUBLE_ARROW    reduce using rule 89 (base_var -> IDENTIFIER .)
    RBRACE          reduce using rule 89 (base_var -> IDENTIFIER .)
    RBRACKET        reduce using rule 89 (base_var -> IDENTIFIER .)



state 39

    (4) stmt_list -> empty .

    $end            reduce using rule 4 (stmt_list -> empty .)



state 40

    (80) variable -> func_call .

    PLUS_EQ         reduce using rule 80 (variable -> func_call .)
    MINUS_EQ        reduce using rule 80 (variable -> func_call .)
    MULTIPLY_EQ     reduce using rule 80 (variable -> func_call .)
    DIVIDE_EQ       reduce using rule 80 (variable -> func_call .)
    DOT_EQ          reduce using rule 80 (variable -> func_call .)
    MOD_EQ          reduce using rule 80 (variable -> func_call .)
    INC             reduce using rule 80 (variable -> func_call .)
    DEC             reduce using rule 80 (variable -> func_call .)
    DOT             reduce using rule 80 (variable -> func_call .)
    PLUS            reduce using rule 80 (variable -> func_call .)
    MINUS           reduce using rule 80 (variable -> func_call .)
    MULT            reduce using rule 80 (variable -> func_call .)
    DIV             reduce using rule 80 (variable -> func_call .)
    MOD             reduce using rule 80 (variable -> func_call .)
    BIT_OR          reduce using rule 80 (variable -> func_call .)
    BIT_XOR         reduce using rule 80 (variable -> func_call .)
    BIT_AND         reduce using rule 80 (variable -> func_call .)
    BIT_LSHIFT      reduce using rule 80 (variable -> func_call .)
    BIT_RSHIFT      reduce using rule 80 (variable -> func_call .)
    AND_OP          reduce using rule 80 (variable -> func_call .)
    OR_OP           reduce using rule 80 (variable -> func_call .)
    IDENTICAL       reduce using rule 80 (variable -> func_call .)
    NOT_IDENTICAL   reduce using rule 80 (variable -> func_call .)
    EQ_EQ           reduce using rule 80 (variable -> func_call .)
    NOT_EQ          reduce using rule 80 (variable -> func_call .)
    LESSER          reduce using rule 80 (variable -> func_call .)
    LESSER_EQ       reduce using rule 80 (variable -> func_call .)
    GREATER         reduce using rule 80 (variable -> func_call .)
    GREATER_EQ      reduce using rule 80 (variable -> func_call .)
    INSTANCEOF      reduce using rule 80 (variable -> func_call .)
    COND_OP         reduce using rule 80 (variable -> func_call .)
    RPAREN          reduce using rule 80 (variable -> func_call .)
    COMMA           reduce using rule 80 (variable -> func_call .)
    SEMICOLON       reduce using rule 80 (variable -> func_call .)
    DOUBLE_ARROW    reduce using rule 80 (variable -> func_call .)
    AS              reduce using rule 80 (variable -> func_call .)
    RBRACE          reduce using rule 80 (variable -> func_call .)
    RBRACKET        reduce using rule 80 (variable -> func_call .)
    COLON           reduce using rule 80 (variable -> func_call .)



state 41

    (6) top_stmt -> func_decl .

    WHILE           reduce using rule 6 (top_stmt -> func_decl .)
    DO              reduce using rule 6 (top_stmt -> func_decl .)
    FOR             reduce using rule 6 (top_stmt -> func_decl .)
    FOREACH         reduce using rule 6 (top_stmt -> func_decl .)
    SWITCH          reduce using rule 6 (top_stmt -> func_decl .)
    BREAK           reduce using rule 6 (top_stmt -> func_decl .)
    CONTINUE        reduce using rule 6 (top_stmt -> func_decl .)
    RETURN          reduce using rule 6 (top_stmt -> func_decl .)
    GLOBAL          reduce using rule 6 (top_stmt -> func_decl .)
    STATIC          reduce using rule 6 (top_stmt -> func_decl .)
    ECHO            reduce using rule 6 (top_stmt -> func_decl .)
    LBRACE          reduce using rule 6 (top_stmt -> func_decl .)
    SEMICOLON       reduce using rule 6 (top_stmt -> func_decl .)
    FUNCTION        reduce using rule 6 (top_stmt -> func_decl .)
    CLONE           reduce using rule 6 (top_stmt -> func_decl .)
    ARRAY           reduce using rule 6 (top_stmt -> func_decl .)
    PLUS            reduce using rule 6 (top_stmt -> func_decl .)
    MINUS           reduce using rule 6 (top_stmt -> func_decl .)
    BIT_NOT         reduce using rule 6 (top_stmt -> func_decl .)
    NOT             reduce using rule 6 (top_stmt -> func_decl .)
    CONST_DECIMAL   reduce using rule 6 (top_stmt -> func_decl .)
    CONST_DOUBLE    reduce using rule 6 (top_stmt -> func_decl .)
    CONST_STRING    reduce using rule 6 (top_stmt -> func_decl .)
    NULL            reduce using rule 6 (top_stmt -> func_decl .)
    TRUE            reduce using rule 6 (top_stmt -> func_decl .)
    FALSE           reduce using rule 6 (top_stmt -> func_decl .)
    INC             reduce using rule 6 (top_stmt -> func_decl .)
    DEC             reduce using rule 6 (top_stmt -> func_decl .)
    EMPTY           reduce using rule 6 (top_stmt -> func_decl .)
    EVAL            reduce using rule 6 (top_stmt -> func_decl .)
    LPAREN          reduce using rule 6 (top_stmt -> func_decl .)
    INCLUDE         reduce using rule 6 (top_stmt -> func_decl .)
    INCLUDE_ONCE    reduce using rule 6 (top_stmt -> func_decl .)
    REQUIRE         reduce using rule 6 (top_stmt -> func_decl .)
    REQUIRE_ONCE    reduce using rule 6 (top_stmt -> func_decl .)
    EXIT            reduce using rule 6 (top_stmt -> func_decl .)
    PRINT           reduce using rule 6 (top_stmt -> func_decl .)
    IF              reduce using rule 6 (top_stmt -> func_decl .)
    IDENTIFIER      reduce using rule 6 (top_stmt -> func_decl .)
    STRING          reduce using rule 6 (top_stmt -> func_decl .)
    $end            reduce using rule 6 (top_stmt -> func_decl .)



state 42

    (18) if_stmt -> if_stmt_without_else .
    (19) if_stmt -> if_stmt_without_else . ELSE goto_marker jump_marker stmt
    (21) if_stmt_without_else -> if_stmt_without_else . ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt

    WHILE           reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    DO              reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    FOR             reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    FOREACH         reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    SWITCH          reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    BREAK           reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    CONTINUE        reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    RETURN          reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    GLOBAL          reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    STATIC          reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    ECHO            reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    LBRACE          reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    SEMICOLON       reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    FUNCTION        reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    CLONE           reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    ARRAY           reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    PLUS            reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    MINUS           reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    BIT_NOT         reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    NOT             reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    CONST_DECIMAL   reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    CONST_DOUBLE    reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    CONST_STRING    reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    NULL            reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    TRUE            reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    FALSE           reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    INC             reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    DEC             reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    EMPTY           reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    EVAL            reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    LPAREN          reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    INCLUDE         reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    INCLUDE_ONCE    reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    REQUIRE         reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    REQUIRE_ONCE    reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    EXIT            reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    PRINT           reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    IF              reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    IDENTIFIER      reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    STRING          reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    $end            reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    RBRACE          reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    ENDIF           reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    ENDWHILE        reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    ENDFOREACH      reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    CASE            reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    DEFAULT         reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    ENDSWITCH       reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    ENDFOR          reduce using rule 18 (if_stmt -> if_stmt_without_else .)
    ELSE            shift and go to state 96
    ELSEIF          shift and go to state 97

  ! ELSE            [ reduce using rule 18 (if_stmt -> if_stmt_without_else .) ]
  ! ELSEIF          [ reduce using rule 18 (if_stmt -> if_stmt_without_else .) ]


state 43

    (92) expr -> base_var . EQUAL expr
    (93) expr -> base_var . EQUAL BIT_AND expr
    (79) variable -> base_var .
    (87) base_var -> base_var . LBRACKET dim_offset RBRACKET
    (88) base_var -> base_var . LBRACE expr RBRACE

    EQUAL           shift and go to state 99
    PLUS_EQ         reduce using rule 79 (variable -> base_var .)
    MINUS_EQ        reduce using rule 79 (variable -> base_var .)
    MULTIPLY_EQ     reduce using rule 79 (variable -> base_var .)
    DIVIDE_EQ       reduce using rule 79 (variable -> base_var .)
    DOT_EQ          reduce using rule 79 (variable -> base_var .)
    MOD_EQ          reduce using rule 79 (variable -> base_var .)
    INC             reduce using rule 79 (variable -> base_var .)
    DEC             reduce using rule 79 (variable -> base_var .)
    DOT             reduce using rule 79 (variable -> base_var .)
    PLUS            reduce using rule 79 (variable -> base_var .)
    MINUS           reduce using rule 79 (variable -> base_var .)
    MULT            reduce using rule 79 (variable -> base_var .)
    DIV             reduce using rule 79 (variable -> base_var .)
    MOD             reduce using rule 79 (variable -> base_var .)
    BIT_OR          reduce using rule 79 (variable -> base_var .)
    BIT_XOR         reduce using rule 79 (variable -> base_var .)
    BIT_AND         reduce using rule 79 (variable -> base_var .)
    BIT_LSHIFT      reduce using rule 79 (variable -> base_var .)
    BIT_RSHIFT      reduce using rule 79 (variable -> base_var .)
    AND_OP          reduce using rule 79 (variable -> base_var .)
    OR_OP           reduce using rule 79 (variable -> base_var .)
    IDENTICAL       reduce using rule 79 (variable -> base_var .)
    NOT_IDENTICAL   reduce using rule 79 (variable -> base_var .)
    EQ_EQ           reduce using rule 79 (variable -> base_var .)
    NOT_EQ          reduce using rule 79 (variable -> base_var .)
    LESSER          reduce using rule 79 (variable -> base_var .)
    LESSER_EQ       reduce using rule 79 (variable -> base_var .)
    GREATER         reduce using rule 79 (variable -> base_var .)
    GREATER_EQ      reduce using rule 79 (variable -> base_var .)
    INSTANCEOF      reduce using rule 79 (variable -> base_var .)
    COND_OP         reduce using rule 79 (variable -> base_var .)
    RPAREN          reduce using rule 79 (variable -> base_var .)
    COMMA           reduce using rule 79 (variable -> base_var .)
    SEMICOLON       reduce using rule 79 (variable -> base_var .)
    DOUBLE_ARROW    reduce using rule 79 (variable -> base_var .)
    AS              reduce using rule 79 (variable -> base_var .)
    RBRACE          reduce using rule 79 (variable -> base_var .)
    RBRACKET        reduce using rule 79 (variable -> base_var .)
    COLON           reduce using rule 79 (variable -> base_var .)
    LBRACKET        shift and go to state 100
    LBRACE          shift and go to state 98



state 44

    (160) expr -> FALSE .

    DOT             reduce using rule 160 (expr -> FALSE .)
    PLUS            reduce using rule 160 (expr -> FALSE .)
    MINUS           reduce using rule 160 (expr -> FALSE .)
    MULT            reduce using rule 160 (expr -> FALSE .)
    DIV             reduce using rule 160 (expr -> FALSE .)
    MOD             reduce using rule 160 (expr -> FALSE .)
    BIT_OR          reduce using rule 160 (expr -> FALSE .)
    BIT_XOR         reduce using rule 160 (expr -> FALSE .)
    BIT_AND         reduce using rule 160 (expr -> FALSE .)
    BIT_LSHIFT      reduce using rule 160 (expr -> FALSE .)
    BIT_RSHIFT      reduce using rule 160 (expr -> FALSE .)
    AND_OP          reduce using rule 160 (expr -> FALSE .)
    OR_OP           reduce using rule 160 (expr -> FALSE .)
    IDENTICAL       reduce using rule 160 (expr -> FALSE .)
    NOT_IDENTICAL   reduce using rule 160 (expr -> FALSE .)
    EQ_EQ           reduce using rule 160 (expr -> FALSE .)
    NOT_EQ          reduce using rule 160 (expr -> FALSE .)
    LESSER          reduce using rule 160 (expr -> FALSE .)
    LESSER_EQ       reduce using rule 160 (expr -> FALSE .)
    GREATER         reduce using rule 160 (expr -> FALSE .)
    GREATER_EQ      reduce using rule 160 (expr -> FALSE .)
    INSTANCEOF      reduce using rule 160 (expr -> FALSE .)
    COND_OP         reduce using rule 160 (expr -> FALSE .)
    SEMICOLON       reduce using rule 160 (expr -> FALSE .)
    COMMA           reduce using rule 160 (expr -> FALSE .)
    RPAREN          reduce using rule 160 (expr -> FALSE .)
    AS              reduce using rule 160 (expr -> FALSE .)
    DOUBLE_ARROW    reduce using rule 160 (expr -> FALSE .)
    RBRACE          reduce using rule 160 (expr -> FALSE .)
    RBRACKET        reduce using rule 160 (expr -> FALSE .)
    COLON           reduce using rule 160 (expr -> FALSE .)



state 45

    (73) stmt -> expr . SEMICOLON
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    SEMICOLON       shift and go to state 108
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 46

    (157) expr -> CONST_STRING .

    DOT             reduce using rule 157 (expr -> CONST_STRING .)
    PLUS            reduce using rule 157 (expr -> CONST_STRING .)
    MINUS           reduce using rule 157 (expr -> CONST_STRING .)
    MULT            reduce using rule 157 (expr -> CONST_STRING .)
    DIV             reduce using rule 157 (expr -> CONST_STRING .)
    MOD             reduce using rule 157 (expr -> CONST_STRING .)
    BIT_OR          reduce using rule 157 (expr -> CONST_STRING .)
    BIT_XOR         reduce using rule 157 (expr -> CONST_STRING .)
    BIT_AND         reduce using rule 157 (expr -> CONST_STRING .)
    BIT_LSHIFT      reduce using rule 157 (expr -> CONST_STRING .)
    BIT_RSHIFT      reduce using rule 157 (expr -> CONST_STRING .)
    AND_OP          reduce using rule 157 (expr -> CONST_STRING .)
    OR_OP           reduce using rule 157 (expr -> CONST_STRING .)
    IDENTICAL       reduce using rule 157 (expr -> CONST_STRING .)
    NOT_IDENTICAL   reduce using rule 157 (expr -> CONST_STRING .)
    EQ_EQ           reduce using rule 157 (expr -> CONST_STRING .)
    NOT_EQ          reduce using rule 157 (expr -> CONST_STRING .)
    LESSER          reduce using rule 157 (expr -> CONST_STRING .)
    LESSER_EQ       reduce using rule 157 (expr -> CONST_STRING .)
    GREATER         reduce using rule 157 (expr -> CONST_STRING .)
    GREATER_EQ      reduce using rule 157 (expr -> CONST_STRING .)
    INSTANCEOF      reduce using rule 157 (expr -> CONST_STRING .)
    COND_OP         reduce using rule 157 (expr -> CONST_STRING .)
    SEMICOLON       reduce using rule 157 (expr -> CONST_STRING .)
    COMMA           reduce using rule 157 (expr -> CONST_STRING .)
    RPAREN          reduce using rule 157 (expr -> CONST_STRING .)
    AS              reduce using rule 157 (expr -> CONST_STRING .)
    DOUBLE_ARROW    reduce using rule 157 (expr -> CONST_STRING .)
    RBRACE          reduce using rule 157 (expr -> CONST_STRING .)
    RBRACKET        reduce using rule 157 (expr -> CONST_STRING .)
    COLON           reduce using rule 157 (expr -> CONST_STRING .)



state 47

    (54) stmt -> BREAK . goto_marker SEMICOLON
    (55) stmt -> BREAK . expr goto_marker SEMICOLON
    (178) goto_marker -> . empty
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (179) empty -> .
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    SEMICOLON       reduce using rule 179 (empty -> .)
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    goto_marker                    shift and go to state 125
    base_var                       shift and go to state 43
    expr                           shift and go to state 126
    empty                          shift and go to state 80
    variable                       shift and go to state 53

state 48

    (173) expr -> EXIT .
    (174) expr -> EXIT . LPAREN RPAREN
    (175) expr -> EXIT . LPAREN expr RPAREN

    DOT             reduce using rule 173 (expr -> EXIT .)
    PLUS            reduce using rule 173 (expr -> EXIT .)
    MINUS           reduce using rule 173 (expr -> EXIT .)
    MULT            reduce using rule 173 (expr -> EXIT .)
    DIV             reduce using rule 173 (expr -> EXIT .)
    MOD             reduce using rule 173 (expr -> EXIT .)
    BIT_OR          reduce using rule 173 (expr -> EXIT .)
    BIT_XOR         reduce using rule 173 (expr -> EXIT .)
    BIT_AND         reduce using rule 173 (expr -> EXIT .)
    BIT_LSHIFT      reduce using rule 173 (expr -> EXIT .)
    BIT_RSHIFT      reduce using rule 173 (expr -> EXIT .)
    AND_OP          reduce using rule 173 (expr -> EXIT .)
    OR_OP           reduce using rule 173 (expr -> EXIT .)
    IDENTICAL       reduce using rule 173 (expr -> EXIT .)
    NOT_IDENTICAL   reduce using rule 173 (expr -> EXIT .)
    EQ_EQ           reduce using rule 173 (expr -> EXIT .)
    NOT_EQ          reduce using rule 173 (expr -> EXIT .)
    LESSER          reduce using rule 173 (expr -> EXIT .)
    LESSER_EQ       reduce using rule 173 (expr -> EXIT .)
    GREATER         reduce using rule 173 (expr -> EXIT .)
    GREATER_EQ      reduce using rule 173 (expr -> EXIT .)
    INSTANCEOF      reduce using rule 173 (expr -> EXIT .)
    COND_OP         reduce using rule 173 (expr -> EXIT .)
    SEMICOLON       reduce using rule 173 (expr -> EXIT .)
    COMMA           reduce using rule 173 (expr -> EXIT .)
    RPAREN          reduce using rule 173 (expr -> EXIT .)
    AS              reduce using rule 173 (expr -> EXIT .)
    DOUBLE_ARROW    reduce using rule 173 (expr -> EXIT .)
    RBRACE          reduce using rule 173 (expr -> EXIT .)
    RBRACKET        reduce using rule 173 (expr -> EXIT .)
    COLON           reduce using rule 173 (expr -> EXIT .)
    LPAREN          shift and go to state 127



state 49

    (29) stmt -> DO . stmt WHILE LPAREN expr RPAREN SEMICOLON
    (16) stmt -> . if_stmt
    (17) stmt -> . alt_if_stmt
    (26) stmt -> . WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker
    (29) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (30) stmt -> . FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (37) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (44) stmt -> . SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker
    (54) stmt -> . BREAK goto_marker SEMICOLON
    (55) stmt -> . BREAK expr goto_marker SEMICOLON
    (56) stmt -> . CONTINUE goto_marker SEMICOLON
    (57) stmt -> . CONTINUE expr goto_marker SEMICOLON
    (58) stmt -> . RETURN SEMICOLON
    (59) stmt -> . RETURN expr SEMICOLON
    (60) stmt -> . GLOBAL global_var_list SEMICOLON
    (63) stmt -> . STATIC static_var_list SEMICOLON
    (68) stmt -> . ECHO echo_expr_list SEMICOLON
    (71) stmt -> . LBRACE inner_stmts RBRACE
    (72) stmt -> . SEMICOLON
    (73) stmt -> . expr SEMICOLON
    (18) if_stmt -> . if_stmt_without_else
    (19) if_stmt -> . if_stmt_without_else ELSE goto_marker jump_marker stmt
    (22) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (23) alt_if_stmt -> . alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (20) if_stmt_without_else -> . IF LPAREN expr RPAREN jump_marker stmt
    (21) if_stmt_without_else -> . if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON jump_marker inner_stmts
    (25) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    WHILE           shift and go to state 33
    DO              shift and go to state 49
    FOR             shift and go to state 24
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 36
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 30
    RETURN          shift and go to state 16
    GLOBAL          shift and go to state 32
    STATIC          shift and go to state 18
    ECHO            shift and go to state 27
    LBRACE          shift and go to state 29
    SEMICOLON       shift and go to state 35
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    alt_if_stmt                    shift and go to state 25
    stmt                           shift and go to state 128
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 13
    expr                           shift and go to state 45

state 50

    (158) expr -> NULL .

    DOT             reduce using rule 158 (expr -> NULL .)
    PLUS            reduce using rule 158 (expr -> NULL .)
    MINUS           reduce using rule 158 (expr -> NULL .)
    MULT            reduce using rule 158 (expr -> NULL .)
    DIV             reduce using rule 158 (expr -> NULL .)
    MOD             reduce using rule 158 (expr -> NULL .)
    BIT_OR          reduce using rule 158 (expr -> NULL .)
    BIT_XOR         reduce using rule 158 (expr -> NULL .)
    BIT_AND         reduce using rule 158 (expr -> NULL .)
    BIT_LSHIFT      reduce using rule 158 (expr -> NULL .)
    BIT_RSHIFT      reduce using rule 158 (expr -> NULL .)
    AND_OP          reduce using rule 158 (expr -> NULL .)
    OR_OP           reduce using rule 158 (expr -> NULL .)
    IDENTICAL       reduce using rule 158 (expr -> NULL .)
    NOT_IDENTICAL   reduce using rule 158 (expr -> NULL .)
    EQ_EQ           reduce using rule 158 (expr -> NULL .)
    NOT_EQ          reduce using rule 158 (expr -> NULL .)
    LESSER          reduce using rule 158 (expr -> NULL .)
    LESSER_EQ       reduce using rule 158 (expr -> NULL .)
    GREATER         reduce using rule 158 (expr -> NULL .)
    GREATER_EQ      reduce using rule 158 (expr -> NULL .)
    INSTANCEOF      reduce using rule 158 (expr -> NULL .)
    COND_OP         reduce using rule 158 (expr -> NULL .)
    SEMICOLON       reduce using rule 158 (expr -> NULL .)
    COMMA           reduce using rule 158 (expr -> NULL .)
    RPAREN          reduce using rule 158 (expr -> NULL .)
    AS              reduce using rule 158 (expr -> NULL .)
    DOUBLE_ARROW    reduce using rule 158 (expr -> NULL .)
    RBRACE          reduce using rule 158 (expr -> NULL .)
    RBRACKET        reduce using rule 158 (expr -> NULL .)
    COLON           reduce using rule 158 (expr -> NULL .)



state 51

    (81) func_call -> STRING . LPAREN func_params RPAREN

    LPAREN          shift and go to state 129



state 52

    (168) expr -> LPAREN . expr RPAREN
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 130
    variable                       shift and go to state 53

state 53

    (78) expr -> variable .
    (123) expr -> variable . PLUS_EQ expr
    (124) expr -> variable . MINUS_EQ expr
    (125) expr -> variable . MULTIPLY_EQ expr
    (126) expr -> variable . DIVIDE_EQ expr
    (127) expr -> variable . DOT_EQ expr
    (128) expr -> variable . MOD_EQ expr
    (164) expr -> variable . INC
    (165) expr -> variable . DEC

    DOT             reduce using rule 78 (expr -> variable .)
    PLUS            reduce using rule 78 (expr -> variable .)
    MINUS           reduce using rule 78 (expr -> variable .)
    MULT            reduce using rule 78 (expr -> variable .)
    DIV             reduce using rule 78 (expr -> variable .)
    MOD             reduce using rule 78 (expr -> variable .)
    BIT_OR          reduce using rule 78 (expr -> variable .)
    BIT_XOR         reduce using rule 78 (expr -> variable .)
    BIT_AND         reduce using rule 78 (expr -> variable .)
    BIT_LSHIFT      reduce using rule 78 (expr -> variable .)
    BIT_RSHIFT      reduce using rule 78 (expr -> variable .)
    AND_OP          reduce using rule 78 (expr -> variable .)
    OR_OP           reduce using rule 78 (expr -> variable .)
    IDENTICAL       reduce using rule 78 (expr -> variable .)
    NOT_IDENTICAL   reduce using rule 78 (expr -> variable .)
    EQ_EQ           reduce using rule 78 (expr -> variable .)
    NOT_EQ          reduce using rule 78 (expr -> variable .)
    LESSER          reduce using rule 78 (expr -> variable .)
    LESSER_EQ       reduce using rule 78 (expr -> variable .)
    GREATER         reduce using rule 78 (expr -> variable .)
    GREATER_EQ      reduce using rule 78 (expr -> variable .)
    INSTANCEOF      reduce using rule 78 (expr -> variable .)
    COND_OP         reduce using rule 78 (expr -> variable .)
    SEMICOLON       reduce using rule 78 (expr -> variable .)
    COMMA           reduce using rule 78 (expr -> variable .)
    RPAREN          reduce using rule 78 (expr -> variable .)
    AS              reduce using rule 78 (expr -> variable .)
    DOUBLE_ARROW    reduce using rule 78 (expr -> variable .)
    RBRACE          reduce using rule 78 (expr -> variable .)
    RBRACKET        reduce using rule 78 (expr -> variable .)
    COLON           reduce using rule 78 (expr -> variable .)
    PLUS_EQ         shift and go to state 135
    MINUS_EQ        shift and go to state 136
    MULTIPLY_EQ     shift and go to state 132
    DIVIDE_EQ       shift and go to state 134
    DOT_EQ          shift and go to state 131
    MOD_EQ          shift and go to state 137
    INC             shift and go to state 138
    DEC             shift and go to state 133



state 54

    (20) if_stmt_without_else -> IF . LPAREN expr RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> IF . LPAREN expr RPAREN COLON jump_marker inner_stmts

    LPAREN          shift and go to state 139



state 55

    (1) start -> start_marker stmt_list .

    $end            reduce using rule 1 (start -> start_marker stmt_list .)



state 56

    (162) expr -> INC . variable
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    base_var                       shift and go to state 76
    func_call                      shift and go to state 40
    variable                       shift and go to state 140

state 57

    (23) alt_if_stmt -> alt_if_stmt_without_else ELSE . goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
    (178) goto_marker -> . empty
    (179) empty -> .

    COLON           reduce using rule 179 (empty -> .)


    goto_marker                    shift and go to state 141
    empty                          shift and go to state 80

state 58

    (22) alt_if_stmt -> alt_if_stmt_without_else ENDIF . SEMICOLON

    SEMICOLON       shift and go to state 142



state 59

    (25) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF . goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts
    (178) goto_marker -> . empty
    (179) empty -> .

    LPAREN          reduce using rule 179 (empty -> .)


    goto_marker                    shift and go to state 143
    empty                          shift and go to state 80

state 60

    (152) expr -> MINUS expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    DOT             reduce using rule 152 (expr -> MINUS expr .)
    PLUS            reduce using rule 152 (expr -> MINUS expr .)
    MINUS           reduce using rule 152 (expr -> MINUS expr .)
    BIT_OR          reduce using rule 152 (expr -> MINUS expr .)
    BIT_XOR         reduce using rule 152 (expr -> MINUS expr .)
    BIT_AND         reduce using rule 152 (expr -> MINUS expr .)
    BIT_LSHIFT      reduce using rule 152 (expr -> MINUS expr .)
    BIT_RSHIFT      reduce using rule 152 (expr -> MINUS expr .)
    AND_OP          reduce using rule 152 (expr -> MINUS expr .)
    OR_OP           reduce using rule 152 (expr -> MINUS expr .)
    IDENTICAL       reduce using rule 152 (expr -> MINUS expr .)
    NOT_IDENTICAL   reduce using rule 152 (expr -> MINUS expr .)
    EQ_EQ           reduce using rule 152 (expr -> MINUS expr .)
    NOT_EQ          reduce using rule 152 (expr -> MINUS expr .)
    LESSER          reduce using rule 152 (expr -> MINUS expr .)
    LESSER_EQ       reduce using rule 152 (expr -> MINUS expr .)
    GREATER         reduce using rule 152 (expr -> MINUS expr .)
    GREATER_EQ      reduce using rule 152 (expr -> MINUS expr .)
    COND_OP         reduce using rule 152 (expr -> MINUS expr .)
    SEMICOLON       reduce using rule 152 (expr -> MINUS expr .)
    COMMA           reduce using rule 152 (expr -> MINUS expr .)
    RPAREN          reduce using rule 152 (expr -> MINUS expr .)
    AS              reduce using rule 152 (expr -> MINUS expr .)
    DOUBLE_ARROW    reduce using rule 152 (expr -> MINUS expr .)
    RBRACE          reduce using rule 152 (expr -> MINUS expr .)
    RBRACKET        reduce using rule 152 (expr -> MINUS expr .)
    COLON           reduce using rule 152 (expr -> MINUS expr .)
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    INSTANCEOF      shift and go to state 117

  ! MULT            [ reduce using rule 152 (expr -> MINUS expr .) ]
  ! DIV             [ reduce using rule 152 (expr -> MINUS expr .) ]
  ! MOD             [ reduce using rule 152 (expr -> MINUS expr .) ]
  ! INSTANCEOF      [ reduce using rule 152 (expr -> MINUS expr .) ]
  ! DOT             [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 110 ]
  ! MINUS           [ shift and go to state 105 ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 61

    (151) expr -> PLUS expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    DOT             reduce using rule 151 (expr -> PLUS expr .)
    PLUS            reduce using rule 151 (expr -> PLUS expr .)
    MINUS           reduce using rule 151 (expr -> PLUS expr .)
    BIT_OR          reduce using rule 151 (expr -> PLUS expr .)
    BIT_XOR         reduce using rule 151 (expr -> PLUS expr .)
    BIT_AND         reduce using rule 151 (expr -> PLUS expr .)
    BIT_LSHIFT      reduce using rule 151 (expr -> PLUS expr .)
    BIT_RSHIFT      reduce using rule 151 (expr -> PLUS expr .)
    AND_OP          reduce using rule 151 (expr -> PLUS expr .)
    OR_OP           reduce using rule 151 (expr -> PLUS expr .)
    IDENTICAL       reduce using rule 151 (expr -> PLUS expr .)
    NOT_IDENTICAL   reduce using rule 151 (expr -> PLUS expr .)
    EQ_EQ           reduce using rule 151 (expr -> PLUS expr .)
    NOT_EQ          reduce using rule 151 (expr -> PLUS expr .)
    LESSER          reduce using rule 151 (expr -> PLUS expr .)
    LESSER_EQ       reduce using rule 151 (expr -> PLUS expr .)
    GREATER         reduce using rule 151 (expr -> PLUS expr .)
    GREATER_EQ      reduce using rule 151 (expr -> PLUS expr .)
    COND_OP         reduce using rule 151 (expr -> PLUS expr .)
    SEMICOLON       reduce using rule 151 (expr -> PLUS expr .)
    COMMA           reduce using rule 151 (expr -> PLUS expr .)
    RPAREN          reduce using rule 151 (expr -> PLUS expr .)
    AS              reduce using rule 151 (expr -> PLUS expr .)
    DOUBLE_ARROW    reduce using rule 151 (expr -> PLUS expr .)
    RBRACE          reduce using rule 151 (expr -> PLUS expr .)
    RBRACKET        reduce using rule 151 (expr -> PLUS expr .)
    COLON           reduce using rule 151 (expr -> PLUS expr .)
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    INSTANCEOF      shift and go to state 117

  ! MULT            [ reduce using rule 151 (expr -> PLUS expr .) ]
  ! DIV             [ reduce using rule 151 (expr -> PLUS expr .) ]
  ! MOD             [ reduce using rule 151 (expr -> PLUS expr .) ]
  ! INSTANCEOF      [ reduce using rule 151 (expr -> PLUS expr .) ]
  ! DOT             [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 110 ]
  ! MINUS           [ shift and go to state 105 ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 62

    (153) expr -> BIT_NOT expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    DOT             reduce using rule 153 (expr -> BIT_NOT expr .)
    PLUS            reduce using rule 153 (expr -> BIT_NOT expr .)
    MINUS           reduce using rule 153 (expr -> BIT_NOT expr .)
    MULT            reduce using rule 153 (expr -> BIT_NOT expr .)
    DIV             reduce using rule 153 (expr -> BIT_NOT expr .)
    MOD             reduce using rule 153 (expr -> BIT_NOT expr .)
    BIT_OR          reduce using rule 153 (expr -> BIT_NOT expr .)
    BIT_XOR         reduce using rule 153 (expr -> BIT_NOT expr .)
    BIT_AND         reduce using rule 153 (expr -> BIT_NOT expr .)
    BIT_LSHIFT      reduce using rule 153 (expr -> BIT_NOT expr .)
    BIT_RSHIFT      reduce using rule 153 (expr -> BIT_NOT expr .)
    AND_OP          reduce using rule 153 (expr -> BIT_NOT expr .)
    OR_OP           reduce using rule 153 (expr -> BIT_NOT expr .)
    IDENTICAL       reduce using rule 153 (expr -> BIT_NOT expr .)
    NOT_IDENTICAL   reduce using rule 153 (expr -> BIT_NOT expr .)
    EQ_EQ           reduce using rule 153 (expr -> BIT_NOT expr .)
    NOT_EQ          reduce using rule 153 (expr -> BIT_NOT expr .)
    LESSER          reduce using rule 153 (expr -> BIT_NOT expr .)
    LESSER_EQ       reduce using rule 153 (expr -> BIT_NOT expr .)
    GREATER         reduce using rule 153 (expr -> BIT_NOT expr .)
    GREATER_EQ      reduce using rule 153 (expr -> BIT_NOT expr .)
    INSTANCEOF      reduce using rule 153 (expr -> BIT_NOT expr .)
    COND_OP         reduce using rule 153 (expr -> BIT_NOT expr .)
    SEMICOLON       reduce using rule 153 (expr -> BIT_NOT expr .)
    COMMA           reduce using rule 153 (expr -> BIT_NOT expr .)
    RPAREN          reduce using rule 153 (expr -> BIT_NOT expr .)
    AS              reduce using rule 153 (expr -> BIT_NOT expr .)
    DOUBLE_ARROW    reduce using rule 153 (expr -> BIT_NOT expr .)
    RBRACE          reduce using rule 153 (expr -> BIT_NOT expr .)
    RBRACKET        reduce using rule 153 (expr -> BIT_NOT expr .)
    COLON           reduce using rule 153 (expr -> BIT_NOT expr .)

  ! DOT             [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 110 ]
  ! MINUS           [ shift and go to state 105 ]
  ! MULT            [ shift and go to state 111 ]
  ! DIV             [ shift and go to state 103 ]
  ! MOD             [ shift and go to state 124 ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! INSTANCEOF      [ shift and go to state 117 ]
  ! COND_OP         [ shift and go to state 119 ]


state 63

    (37) stmt -> FOREACH LPAREN . expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 144
    variable                       shift and go to state 53

state 64

    (167) expr -> EVAL LPAREN . expr RPAREN
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 145
    variable                       shift and go to state 53

state 65

    (170) expr -> INCLUDE_ONCE expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    SEMICOLON       reduce using rule 170 (expr -> INCLUDE_ONCE expr .)
    COMMA           reduce using rule 170 (expr -> INCLUDE_ONCE expr .)
    RPAREN          reduce using rule 170 (expr -> INCLUDE_ONCE expr .)
    AS              reduce using rule 170 (expr -> INCLUDE_ONCE expr .)
    DOUBLE_ARROW    reduce using rule 170 (expr -> INCLUDE_ONCE expr .)
    RBRACE          reduce using rule 170 (expr -> INCLUDE_ONCE expr .)
    RBRACKET        reduce using rule 170 (expr -> INCLUDE_ONCE expr .)
    COLON           reduce using rule 170 (expr -> INCLUDE_ONCE expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! PLUS            [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! MINUS           [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! MULT            [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! DIV             [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! MOD             [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_OR          [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_XOR         [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_AND         [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! AND_OP          [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! OR_OP           [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! IDENTICAL       [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! EQ_EQ           [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! NOT_EQ          [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! LESSER          [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! LESSER_EQ       [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! GREATER         [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! GREATER_EQ      [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! INSTANCEOF      [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]
  ! COND_OP         [ reduce using rule 170 (expr -> INCLUDE_ONCE expr .) ]


state 66

    (94) expr -> CLONE expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    DOT             reduce using rule 94 (expr -> CLONE expr .)
    PLUS            reduce using rule 94 (expr -> CLONE expr .)
    MINUS           reduce using rule 94 (expr -> CLONE expr .)
    MULT            reduce using rule 94 (expr -> CLONE expr .)
    DIV             reduce using rule 94 (expr -> CLONE expr .)
    MOD             reduce using rule 94 (expr -> CLONE expr .)
    BIT_OR          reduce using rule 94 (expr -> CLONE expr .)
    BIT_XOR         reduce using rule 94 (expr -> CLONE expr .)
    BIT_AND         reduce using rule 94 (expr -> CLONE expr .)
    BIT_LSHIFT      reduce using rule 94 (expr -> CLONE expr .)
    BIT_RSHIFT      reduce using rule 94 (expr -> CLONE expr .)
    AND_OP          reduce using rule 94 (expr -> CLONE expr .)
    OR_OP           reduce using rule 94 (expr -> CLONE expr .)
    IDENTICAL       reduce using rule 94 (expr -> CLONE expr .)
    NOT_IDENTICAL   reduce using rule 94 (expr -> CLONE expr .)
    EQ_EQ           reduce using rule 94 (expr -> CLONE expr .)
    NOT_EQ          reduce using rule 94 (expr -> CLONE expr .)
    LESSER          reduce using rule 94 (expr -> CLONE expr .)
    LESSER_EQ       reduce using rule 94 (expr -> CLONE expr .)
    GREATER         reduce using rule 94 (expr -> CLONE expr .)
    GREATER_EQ      reduce using rule 94 (expr -> CLONE expr .)
    INSTANCEOF      reduce using rule 94 (expr -> CLONE expr .)
    COND_OP         reduce using rule 94 (expr -> CLONE expr .)
    SEMICOLON       reduce using rule 94 (expr -> CLONE expr .)
    COMMA           reduce using rule 94 (expr -> CLONE expr .)
    RPAREN          reduce using rule 94 (expr -> CLONE expr .)
    AS              reduce using rule 94 (expr -> CLONE expr .)
    DOUBLE_ARROW    reduce using rule 94 (expr -> CLONE expr .)
    RBRACE          reduce using rule 94 (expr -> CLONE expr .)
    RBRACKET        reduce using rule 94 (expr -> CLONE expr .)
    COLON           reduce using rule 94 (expr -> CLONE expr .)

  ! DOT             [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 110 ]
  ! MINUS           [ shift and go to state 105 ]
  ! MULT            [ shift and go to state 111 ]
  ! DIV             [ shift and go to state 103 ]
  ! MOD             [ shift and go to state 124 ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! INSTANCEOF      [ shift and go to state 117 ]
  ! COND_OP         [ shift and go to state 119 ]


state 67

    (3) stmt_list -> top_stmt jump_marker . stmt_list
    (3) stmt_list -> . top_stmt jump_marker stmt_list
    (4) stmt_list -> . empty
    (5) top_stmt -> . stmt
    (6) top_stmt -> . func_decl
    (179) empty -> .
    (16) stmt -> . if_stmt
    (17) stmt -> . alt_if_stmt
    (26) stmt -> . WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker
    (29) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (30) stmt -> . FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (37) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (44) stmt -> . SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker
    (54) stmt -> . BREAK goto_marker SEMICOLON
    (55) stmt -> . BREAK expr goto_marker SEMICOLON
    (56) stmt -> . CONTINUE goto_marker SEMICOLON
    (57) stmt -> . CONTINUE expr goto_marker SEMICOLON
    (58) stmt -> . RETURN SEMICOLON
    (59) stmt -> . RETURN expr SEMICOLON
    (60) stmt -> . GLOBAL global_var_list SEMICOLON
    (63) stmt -> . STATIC static_var_list SEMICOLON
    (68) stmt -> . ECHO echo_expr_list SEMICOLON
    (71) stmt -> . LBRACE inner_stmts RBRACE
    (72) stmt -> . SEMICOLON
    (73) stmt -> . expr SEMICOLON
    (7) func_decl -> . FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker
    (18) if_stmt -> . if_stmt_without_else
    (19) if_stmt -> . if_stmt_without_else ELSE goto_marker jump_marker stmt
    (22) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (23) alt_if_stmt -> . alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (20) if_stmt_without_else -> . IF LPAREN expr RPAREN jump_marker stmt
    (21) if_stmt_without_else -> . if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON jump_marker inner_stmts
    (25) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    $end            reduce using rule 179 (empty -> .)
    WHILE           shift and go to state 33
    DO              shift and go to state 49
    FOR             shift and go to state 24
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 36
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 30
    RETURN          shift and go to state 16
    GLOBAL          shift and go to state 32
    STATIC          shift and go to state 18
    ECHO            shift and go to state 27
    LBRACE          shift and go to state 29
    SEMICOLON       shift and go to state 35
    FUNCTION        shift and go to state 23
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    func_call                      shift and go to state 40
    empty                          shift and go to state 39
    func_decl                      shift and go to state 41
    alt_if_stmt                    shift and go to state 25
    stmt                           shift and go to state 26
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    stmt_list                      shift and go to state 146
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 13
    expr                           shift and go to state 45
    top_stmt                       shift and go to state 15

state 68

    (177) jump_marker -> empty .

    WHILE           reduce using rule 177 (jump_marker -> empty .)
    DO              reduce using rule 177 (jump_marker -> empty .)
    FOR             reduce using rule 177 (jump_marker -> empty .)
    FOREACH         reduce using rule 177 (jump_marker -> empty .)
    SWITCH          reduce using rule 177 (jump_marker -> empty .)
    BREAK           reduce using rule 177 (jump_marker -> empty .)
    CONTINUE        reduce using rule 177 (jump_marker -> empty .)
    RETURN          reduce using rule 177 (jump_marker -> empty .)
    GLOBAL          reduce using rule 177 (jump_marker -> empty .)
    STATIC          reduce using rule 177 (jump_marker -> empty .)
    ECHO            reduce using rule 177 (jump_marker -> empty .)
    LBRACE          reduce using rule 177 (jump_marker -> empty .)
    SEMICOLON       reduce using rule 177 (jump_marker -> empty .)
    FUNCTION        reduce using rule 177 (jump_marker -> empty .)
    CLONE           reduce using rule 177 (jump_marker -> empty .)
    ARRAY           reduce using rule 177 (jump_marker -> empty .)
    PLUS            reduce using rule 177 (jump_marker -> empty .)
    MINUS           reduce using rule 177 (jump_marker -> empty .)
    BIT_NOT         reduce using rule 177 (jump_marker -> empty .)
    NOT             reduce using rule 177 (jump_marker -> empty .)
    CONST_DECIMAL   reduce using rule 177 (jump_marker -> empty .)
    CONST_DOUBLE    reduce using rule 177 (jump_marker -> empty .)
    CONST_STRING    reduce using rule 177 (jump_marker -> empty .)
    NULL            reduce using rule 177 (jump_marker -> empty .)
    TRUE            reduce using rule 177 (jump_marker -> empty .)
    FALSE           reduce using rule 177 (jump_marker -> empty .)
    INC             reduce using rule 177 (jump_marker -> empty .)
    DEC             reduce using rule 177 (jump_marker -> empty .)
    EMPTY           reduce using rule 177 (jump_marker -> empty .)
    EVAL            reduce using rule 177 (jump_marker -> empty .)
    LPAREN          reduce using rule 177 (jump_marker -> empty .)
    INCLUDE         reduce using rule 177 (jump_marker -> empty .)
    INCLUDE_ONCE    reduce using rule 177 (jump_marker -> empty .)
    REQUIRE         reduce using rule 177 (jump_marker -> empty .)
    REQUIRE_ONCE    reduce using rule 177 (jump_marker -> empty .)
    EXIT            reduce using rule 177 (jump_marker -> empty .)
    PRINT           reduce using rule 177 (jump_marker -> empty .)
    IF              reduce using rule 177 (jump_marker -> empty .)
    IDENTIFIER      reduce using rule 177 (jump_marker -> empty .)
    STRING          reduce using rule 177 (jump_marker -> empty .)
    RBRACE          reduce using rule 177 (jump_marker -> empty .)
    CASE            reduce using rule 177 (jump_marker -> empty .)
    DEFAULT         reduce using rule 177 (jump_marker -> empty .)
    ENDSWITCH       reduce using rule 177 (jump_marker -> empty .)
    COLON           reduce using rule 177 (jump_marker -> empty .)
    BIT_AND         reduce using rule 177 (jump_marker -> empty .)
    RPAREN          reduce using rule 177 (jump_marker -> empty .)
    COMMA           reduce using rule 177 (jump_marker -> empty .)
    $end            reduce using rule 177 (jump_marker -> empty .)
    ENDIF           reduce using rule 177 (jump_marker -> empty .)
    ELSE            reduce using rule 177 (jump_marker -> empty .)
    ELSEIF          reduce using rule 177 (jump_marker -> empty .)
    ENDWHILE        reduce using rule 177 (jump_marker -> empty .)
    ENDFOREACH      reduce using rule 177 (jump_marker -> empty .)
    ENDFOR          reduce using rule 177 (jump_marker -> empty .)



state 69

    (58) stmt -> RETURN SEMICOLON .

    WHILE           reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    DO              reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    FOREACH         reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    SWITCH          reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    GLOBAL          reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    STATIC          reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    ECHO            reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    FUNCTION        reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    CLONE           reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    ARRAY           reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    PLUS            reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    MINUS           reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    BIT_NOT         reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    NOT             reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    CONST_DECIMAL   reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    CONST_DOUBLE    reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    CONST_STRING    reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    NULL            reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    TRUE            reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    FALSE           reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    INC             reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    DEC             reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    EMPTY           reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    EVAL            reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    INCLUDE         reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    REQUIRE         reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    EXIT            reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    PRINT           reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    IDENTIFIER      reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    STRING          reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    $end            reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    ENDIF           reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    ELSEIF          reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    ENDWHILE        reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    ENDFOREACH      reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    CASE            reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    DEFAULT         reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    ENDSWITCH       reduce using rule 58 (stmt -> RETURN SEMICOLON .)
    ENDFOR          reduce using rule 58 (stmt -> RETURN SEMICOLON .)



state 70

    (59) stmt -> RETURN expr . SEMICOLON
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    SEMICOLON       shift and go to state 147
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 71

    (171) expr -> REQUIRE expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    SEMICOLON       reduce using rule 171 (expr -> REQUIRE expr .)
    COMMA           reduce using rule 171 (expr -> REQUIRE expr .)
    RPAREN          reduce using rule 171 (expr -> REQUIRE expr .)
    AS              reduce using rule 171 (expr -> REQUIRE expr .)
    DOUBLE_ARROW    reduce using rule 171 (expr -> REQUIRE expr .)
    RBRACE          reduce using rule 171 (expr -> REQUIRE expr .)
    RBRACKET        reduce using rule 171 (expr -> REQUIRE expr .)
    COLON           reduce using rule 171 (expr -> REQUIRE expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! PLUS            [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! MINUS           [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! MULT            [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! DIV             [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! MOD             [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! BIT_OR          [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! BIT_XOR         [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! BIT_AND         [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! AND_OP          [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! OR_OP           [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! IDENTICAL       [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! EQ_EQ           [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! NOT_EQ          [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! LESSER          [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! LESSER_EQ       [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! GREATER         [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! GREATER_EQ      [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! INSTANCEOF      [ reduce using rule 171 (expr -> REQUIRE expr .) ]
  ! COND_OP         [ reduce using rule 171 (expr -> REQUIRE expr .) ]


state 72

    (65) static_var_list -> static_var .

    SEMICOLON       reduce using rule 65 (static_var_list -> static_var .)
    COMMA           reduce using rule 65 (static_var_list -> static_var .)



state 73

    (63) stmt -> STATIC static_var_list . SEMICOLON
    (64) static_var_list -> static_var_list . COMMA static_var

    SEMICOLON       shift and go to state 149
    COMMA           shift and go to state 148



state 74

    (66) static_var -> IDENTIFIER . EQUAL scalar
    (67) static_var -> IDENTIFIER .

    EQUAL           shift and go to state 150
    SEMICOLON       reduce using rule 67 (static_var -> IDENTIFIER .)
    COMMA           reduce using rule 67 (static_var -> IDENTIFIER .)



state 75

    (176) expr -> PRINT expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 176 (expr -> PRINT expr .)
    BIT_XOR         reduce using rule 176 (expr -> PRINT expr .)
    BIT_AND         reduce using rule 176 (expr -> PRINT expr .)
    SEMICOLON       reduce using rule 176 (expr -> PRINT expr .)
    COMMA           reduce using rule 176 (expr -> PRINT expr .)
    RPAREN          reduce using rule 176 (expr -> PRINT expr .)
    AS              reduce using rule 176 (expr -> PRINT expr .)
    DOUBLE_ARROW    reduce using rule 176 (expr -> PRINT expr .)
    RBRACE          reduce using rule 176 (expr -> PRINT expr .)
    RBRACKET        reduce using rule 176 (expr -> PRINT expr .)
    COLON           reduce using rule 176 (expr -> PRINT expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! PLUS            [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! MINUS           [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! MULT            [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! DIV             [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! MOD             [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! AND_OP          [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! OR_OP           [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! IDENTICAL       [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! EQ_EQ           [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! NOT_EQ          [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! LESSER          [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! LESSER_EQ       [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! GREATER         [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! GREATER_EQ      [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! INSTANCEOF      [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! COND_OP         [ reduce using rule 176 (expr -> PRINT expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]


state 76

    (79) variable -> base_var .
    (87) base_var -> base_var . LBRACKET dim_offset RBRACKET
    (88) base_var -> base_var . LBRACE expr RBRACE

    SEMICOLON       reduce using rule 79 (variable -> base_var .)
    DOT             reduce using rule 79 (variable -> base_var .)
    PLUS            reduce using rule 79 (variable -> base_var .)
    MINUS           reduce using rule 79 (variable -> base_var .)
    MULT            reduce using rule 79 (variable -> base_var .)
    DIV             reduce using rule 79 (variable -> base_var .)
    MOD             reduce using rule 79 (variable -> base_var .)
    BIT_OR          reduce using rule 79 (variable -> base_var .)
    BIT_XOR         reduce using rule 79 (variable -> base_var .)
    BIT_AND         reduce using rule 79 (variable -> base_var .)
    BIT_LSHIFT      reduce using rule 79 (variable -> base_var .)
    BIT_RSHIFT      reduce using rule 79 (variable -> base_var .)
    AND_OP          reduce using rule 79 (variable -> base_var .)
    OR_OP           reduce using rule 79 (variable -> base_var .)
    IDENTICAL       reduce using rule 79 (variable -> base_var .)
    NOT_IDENTICAL   reduce using rule 79 (variable -> base_var .)
    EQ_EQ           reduce using rule 79 (variable -> base_var .)
    NOT_EQ          reduce using rule 79 (variable -> base_var .)
    LESSER          reduce using rule 79 (variable -> base_var .)
    LESSER_EQ       reduce using rule 79 (variable -> base_var .)
    GREATER         reduce using rule 79 (variable -> base_var .)
    GREATER_EQ      reduce using rule 79 (variable -> base_var .)
    INSTANCEOF      reduce using rule 79 (variable -> base_var .)
    COND_OP         reduce using rule 79 (variable -> base_var .)
    COMMA           reduce using rule 79 (variable -> base_var .)
    RPAREN          reduce using rule 79 (variable -> base_var .)
    AS              reduce using rule 79 (variable -> base_var .)
    DOUBLE_ARROW    reduce using rule 79 (variable -> base_var .)
    RBRACE          reduce using rule 79 (variable -> base_var .)
    RBRACKET        reduce using rule 79 (variable -> base_var .)
    COLON           reduce using rule 79 (variable -> base_var .)
    LBRACKET        shift and go to state 100
    LBRACE          shift and go to state 98



state 77

    (163) expr -> DEC variable .

    DOT             reduce using rule 163 (expr -> DEC variable .)
    PLUS            reduce using rule 163 (expr -> DEC variable .)
    MINUS           reduce using rule 163 (expr -> DEC variable .)
    MULT            reduce using rule 163 (expr -> DEC variable .)
    DIV             reduce using rule 163 (expr -> DEC variable .)
    MOD             reduce using rule 163 (expr -> DEC variable .)
    BIT_OR          reduce using rule 163 (expr -> DEC variable .)
    BIT_XOR         reduce using rule 163 (expr -> DEC variable .)
    BIT_AND         reduce using rule 163 (expr -> DEC variable .)
    BIT_LSHIFT      reduce using rule 163 (expr -> DEC variable .)
    BIT_RSHIFT      reduce using rule 163 (expr -> DEC variable .)
    AND_OP          reduce using rule 163 (expr -> DEC variable .)
    OR_OP           reduce using rule 163 (expr -> DEC variable .)
    IDENTICAL       reduce using rule 163 (expr -> DEC variable .)
    NOT_IDENTICAL   reduce using rule 163 (expr -> DEC variable .)
    EQ_EQ           reduce using rule 163 (expr -> DEC variable .)
    NOT_EQ          reduce using rule 163 (expr -> DEC variable .)
    LESSER          reduce using rule 163 (expr -> DEC variable .)
    LESSER_EQ       reduce using rule 163 (expr -> DEC variable .)
    GREATER         reduce using rule 163 (expr -> DEC variable .)
    GREATER_EQ      reduce using rule 163 (expr -> DEC variable .)
    INSTANCEOF      reduce using rule 163 (expr -> DEC variable .)
    COND_OP         reduce using rule 163 (expr -> DEC variable .)
    SEMICOLON       reduce using rule 163 (expr -> DEC variable .)
    COMMA           reduce using rule 163 (expr -> DEC variable .)
    RPAREN          reduce using rule 163 (expr -> DEC variable .)
    AS              reduce using rule 163 (expr -> DEC variable .)
    DOUBLE_ARROW    reduce using rule 163 (expr -> DEC variable .)
    RBRACE          reduce using rule 163 (expr -> DEC variable .)
    RBRACKET        reduce using rule 163 (expr -> DEC variable .)
    COLON           reduce using rule 163 (expr -> DEC variable .)



state 78

    (166) expr -> EMPTY LPAREN . expr RPAREN
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 151
    variable                       shift and go to state 53

state 79

    (7) func_decl -> FUNCTION goto_marker . STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker

    STRING          shift and go to state 152



state 80

    (178) goto_marker -> empty .

    SEMICOLON       reduce using rule 178 (goto_marker -> empty .)
    COLON           reduce using rule 178 (goto_marker -> empty .)
    STRING          reduce using rule 178 (goto_marker -> empty .)
    LPAREN          reduce using rule 178 (goto_marker -> empty .)
    WHILE           reduce using rule 178 (goto_marker -> empty .)
    DO              reduce using rule 178 (goto_marker -> empty .)
    FOR             reduce using rule 178 (goto_marker -> empty .)
    FOREACH         reduce using rule 178 (goto_marker -> empty .)
    SWITCH          reduce using rule 178 (goto_marker -> empty .)
    BREAK           reduce using rule 178 (goto_marker -> empty .)
    CONTINUE        reduce using rule 178 (goto_marker -> empty .)
    RETURN          reduce using rule 178 (goto_marker -> empty .)
    GLOBAL          reduce using rule 178 (goto_marker -> empty .)
    STATIC          reduce using rule 178 (goto_marker -> empty .)
    ECHO            reduce using rule 178 (goto_marker -> empty .)
    LBRACE          reduce using rule 178 (goto_marker -> empty .)
    CLONE           reduce using rule 178 (goto_marker -> empty .)
    ARRAY           reduce using rule 178 (goto_marker -> empty .)
    PLUS            reduce using rule 178 (goto_marker -> empty .)
    MINUS           reduce using rule 178 (goto_marker -> empty .)
    BIT_NOT         reduce using rule 178 (goto_marker -> empty .)
    NOT             reduce using rule 178 (goto_marker -> empty .)
    CONST_DECIMAL   reduce using rule 178 (goto_marker -> empty .)
    CONST_DOUBLE    reduce using rule 178 (goto_marker -> empty .)
    CONST_STRING    reduce using rule 178 (goto_marker -> empty .)
    NULL            reduce using rule 178 (goto_marker -> empty .)
    TRUE            reduce using rule 178 (goto_marker -> empty .)
    FALSE           reduce using rule 178 (goto_marker -> empty .)
    INC             reduce using rule 178 (goto_marker -> empty .)
    DEC             reduce using rule 178 (goto_marker -> empty .)
    EMPTY           reduce using rule 178 (goto_marker -> empty .)
    EVAL            reduce using rule 178 (goto_marker -> empty .)
    INCLUDE         reduce using rule 178 (goto_marker -> empty .)
    INCLUDE_ONCE    reduce using rule 178 (goto_marker -> empty .)
    REQUIRE         reduce using rule 178 (goto_marker -> empty .)
    REQUIRE_ONCE    reduce using rule 178 (goto_marker -> empty .)
    EXIT            reduce using rule 178 (goto_marker -> empty .)
    PRINT           reduce using rule 178 (goto_marker -> empty .)
    IF              reduce using rule 178 (goto_marker -> empty .)
    IDENTIFIER      reduce using rule 178 (goto_marker -> empty .)
    FUNCTION        reduce using rule 178 (goto_marker -> empty .)
    $end            reduce using rule 178 (goto_marker -> empty .)
    RBRACE          reduce using rule 178 (goto_marker -> empty .)
    ENDIF           reduce using rule 178 (goto_marker -> empty .)
    ELSE            reduce using rule 178 (goto_marker -> empty .)
    ELSEIF          reduce using rule 178 (goto_marker -> empty .)
    ENDWHILE        reduce using rule 178 (goto_marker -> empty .)
    ENDFOREACH      reduce using rule 178 (goto_marker -> empty .)
    CASE            reduce using rule 178 (goto_marker -> empty .)
    DEFAULT         reduce using rule 178 (goto_marker -> empty .)
    ENDSWITCH       reduce using rule 178 (goto_marker -> empty .)
    ENDFOR          reduce using rule 178 (goto_marker -> empty .)
    RPAREN          reduce using rule 178 (goto_marker -> empty .)



state 81

    (30) stmt -> FOR LPAREN . for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (31) for_expr -> . empty
    (32) for_expr -> . non_empty_for_expr
    (179) empty -> .
    (33) non_empty_for_expr -> . non_empty_for_expr COMMA expr
    (34) non_empty_for_expr -> . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    SEMICOLON       reduce using rule 179 (empty -> .)
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    non_empty_for_expr             shift and go to state 153
    expr                           shift and go to state 155
    for_expr                       shift and go to state 156
    variable                       shift and go to state 53
    empty                          shift and go to state 154
    base_var                       shift and go to state 43

state 82

    (68) stmt -> ECHO echo_expr_list . SEMICOLON
    (69) echo_expr_list -> echo_expr_list . COMMA expr

    SEMICOLON       shift and go to state 158
    COMMA           shift and go to state 157



state 83

    (70) echo_expr_list -> expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    SEMICOLON       reduce using rule 70 (echo_expr_list -> expr .)
    COMMA           reduce using rule 70 (echo_expr_list -> expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 84

    (172) expr -> REQUIRE_ONCE expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    SEMICOLON       reduce using rule 172 (expr -> REQUIRE_ONCE expr .)
    COMMA           reduce using rule 172 (expr -> REQUIRE_ONCE expr .)
    RPAREN          reduce using rule 172 (expr -> REQUIRE_ONCE expr .)
    AS              reduce using rule 172 (expr -> REQUIRE_ONCE expr .)
    DOUBLE_ARROW    reduce using rule 172 (expr -> REQUIRE_ONCE expr .)
    RBRACE          reduce using rule 172 (expr -> REQUIRE_ONCE expr .)
    RBRACKET        reduce using rule 172 (expr -> REQUIRE_ONCE expr .)
    COLON           reduce using rule 172 (expr -> REQUIRE_ONCE expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! PLUS            [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! MINUS           [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! MULT            [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! DIV             [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! MOD             [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_OR          [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_XOR         [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_AND         [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! AND_OP          [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! OR_OP           [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! IDENTICAL       [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! EQ_EQ           [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! NOT_EQ          [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! LESSER          [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! LESSER_EQ       [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! GREATER         [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! GREATER_EQ      [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! INSTANCEOF      [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]
  ! COND_OP         [ reduce using rule 172 (expr -> REQUIRE_ONCE expr .) ]


state 85

    (71) stmt -> LBRACE inner_stmts . RBRACE
    (74) inner_stmts -> inner_stmts . jump_marker inner_stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    RBRACE          shift and go to state 159
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 160
    empty                          shift and go to state 68

state 86

    (75) inner_stmts -> empty .

    ENDWHILE        reduce using rule 75 (inner_stmts -> empty .)
    WHILE           reduce using rule 75 (inner_stmts -> empty .)
    DO              reduce using rule 75 (inner_stmts -> empty .)
    FOR             reduce using rule 75 (inner_stmts -> empty .)
    FOREACH         reduce using rule 75 (inner_stmts -> empty .)
    SWITCH          reduce using rule 75 (inner_stmts -> empty .)
    BREAK           reduce using rule 75 (inner_stmts -> empty .)
    CONTINUE        reduce using rule 75 (inner_stmts -> empty .)
    RETURN          reduce using rule 75 (inner_stmts -> empty .)
    GLOBAL          reduce using rule 75 (inner_stmts -> empty .)
    STATIC          reduce using rule 75 (inner_stmts -> empty .)
    ECHO            reduce using rule 75 (inner_stmts -> empty .)
    LBRACE          reduce using rule 75 (inner_stmts -> empty .)
    SEMICOLON       reduce using rule 75 (inner_stmts -> empty .)
    FUNCTION        reduce using rule 75 (inner_stmts -> empty .)
    CLONE           reduce using rule 75 (inner_stmts -> empty .)
    ARRAY           reduce using rule 75 (inner_stmts -> empty .)
    PLUS            reduce using rule 75 (inner_stmts -> empty .)
    MINUS           reduce using rule 75 (inner_stmts -> empty .)
    BIT_NOT         reduce using rule 75 (inner_stmts -> empty .)
    NOT             reduce using rule 75 (inner_stmts -> empty .)
    CONST_DECIMAL   reduce using rule 75 (inner_stmts -> empty .)
    CONST_DOUBLE    reduce using rule 75 (inner_stmts -> empty .)
    CONST_STRING    reduce using rule 75 (inner_stmts -> empty .)
    NULL            reduce using rule 75 (inner_stmts -> empty .)
    TRUE            reduce using rule 75 (inner_stmts -> empty .)
    FALSE           reduce using rule 75 (inner_stmts -> empty .)
    INC             reduce using rule 75 (inner_stmts -> empty .)
    DEC             reduce using rule 75 (inner_stmts -> empty .)
    EMPTY           reduce using rule 75 (inner_stmts -> empty .)
    EVAL            reduce using rule 75 (inner_stmts -> empty .)
    LPAREN          reduce using rule 75 (inner_stmts -> empty .)
    INCLUDE         reduce using rule 75 (inner_stmts -> empty .)
    INCLUDE_ONCE    reduce using rule 75 (inner_stmts -> empty .)
    REQUIRE         reduce using rule 75 (inner_stmts -> empty .)
    REQUIRE_ONCE    reduce using rule 75 (inner_stmts -> empty .)
    EXIT            reduce using rule 75 (inner_stmts -> empty .)
    PRINT           reduce using rule 75 (inner_stmts -> empty .)
    IF              reduce using rule 75 (inner_stmts -> empty .)
    IDENTIFIER      reduce using rule 75 (inner_stmts -> empty .)
    STRING          reduce using rule 75 (inner_stmts -> empty .)
    ENDIF           reduce using rule 75 (inner_stmts -> empty .)
    ELSE            reduce using rule 75 (inner_stmts -> empty .)
    ELSEIF          reduce using rule 75 (inner_stmts -> empty .)
    RBRACE          reduce using rule 75 (inner_stmts -> empty .)
    CASE            reduce using rule 75 (inner_stmts -> empty .)
    DEFAULT         reduce using rule 75 (inner_stmts -> empty .)
    ENDSWITCH       reduce using rule 75 (inner_stmts -> empty .)
    ENDFOR          reduce using rule 75 (inner_stmts -> empty .)
    ENDFOREACH      reduce using rule 75 (inner_stmts -> empty .)



state 87

    (56) stmt -> CONTINUE goto_marker . SEMICOLON

    SEMICOLON       shift and go to state 161



state 88

    (57) stmt -> CONTINUE expr . goto_marker SEMICOLON
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (178) goto_marker -> . empty
    (179) empty -> .

    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119
    SEMICOLON       reduce using rule 179 (empty -> .)


    empty                          shift and go to state 80
    goto_marker                    shift and go to state 162

state 89

    (154) expr -> NOT expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    DOT             reduce using rule 154 (expr -> NOT expr .)
    PLUS            reduce using rule 154 (expr -> NOT expr .)
    MINUS           reduce using rule 154 (expr -> NOT expr .)
    MULT            reduce using rule 154 (expr -> NOT expr .)
    DIV             reduce using rule 154 (expr -> NOT expr .)
    MOD             reduce using rule 154 (expr -> NOT expr .)
    BIT_OR          reduce using rule 154 (expr -> NOT expr .)
    BIT_XOR         reduce using rule 154 (expr -> NOT expr .)
    BIT_AND         reduce using rule 154 (expr -> NOT expr .)
    BIT_LSHIFT      reduce using rule 154 (expr -> NOT expr .)
    BIT_RSHIFT      reduce using rule 154 (expr -> NOT expr .)
    AND_OP          reduce using rule 154 (expr -> NOT expr .)
    OR_OP           reduce using rule 154 (expr -> NOT expr .)
    IDENTICAL       reduce using rule 154 (expr -> NOT expr .)
    NOT_IDENTICAL   reduce using rule 154 (expr -> NOT expr .)
    EQ_EQ           reduce using rule 154 (expr -> NOT expr .)
    NOT_EQ          reduce using rule 154 (expr -> NOT expr .)
    LESSER          reduce using rule 154 (expr -> NOT expr .)
    LESSER_EQ       reduce using rule 154 (expr -> NOT expr .)
    GREATER         reduce using rule 154 (expr -> NOT expr .)
    GREATER_EQ      reduce using rule 154 (expr -> NOT expr .)
    COND_OP         reduce using rule 154 (expr -> NOT expr .)
    SEMICOLON       reduce using rule 154 (expr -> NOT expr .)
    COMMA           reduce using rule 154 (expr -> NOT expr .)
    RPAREN          reduce using rule 154 (expr -> NOT expr .)
    AS              reduce using rule 154 (expr -> NOT expr .)
    DOUBLE_ARROW    reduce using rule 154 (expr -> NOT expr .)
    RBRACE          reduce using rule 154 (expr -> NOT expr .)
    RBRACKET        reduce using rule 154 (expr -> NOT expr .)
    COLON           reduce using rule 154 (expr -> NOT expr .)
    INSTANCEOF      shift and go to state 117

  ! INSTANCEOF      [ reduce using rule 154 (expr -> NOT expr .) ]
  ! DOT             [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 110 ]
  ! MINUS           [ shift and go to state 105 ]
  ! MULT            [ shift and go to state 111 ]
  ! DIV             [ shift and go to state 103 ]
  ! MOD             [ shift and go to state 124 ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 90

    (62) global_var_list -> IDENTIFIER .

    SEMICOLON       reduce using rule 62 (global_var_list -> IDENTIFIER .)
    COMMA           reduce using rule 62 (global_var_list -> IDENTIFIER .)



state 91

    (60) stmt -> GLOBAL global_var_list . SEMICOLON
    (61) global_var_list -> global_var_list . COMMA IDENTIFIER

    SEMICOLON       shift and go to state 164
    COMMA           shift and go to state 163



state 92

    (26) stmt -> WHILE LPAREN . jump_marker expr jump_marker RPAREN while_stmt goto_marker
    (177) jump_marker -> . empty
    (179) empty -> .

    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 165
    empty                          shift and go to state 68

state 93

    (169) expr -> INCLUDE expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    SEMICOLON       reduce using rule 169 (expr -> INCLUDE expr .)
    COMMA           reduce using rule 169 (expr -> INCLUDE expr .)
    RPAREN          reduce using rule 169 (expr -> INCLUDE expr .)
    AS              reduce using rule 169 (expr -> INCLUDE expr .)
    DOUBLE_ARROW    reduce using rule 169 (expr -> INCLUDE expr .)
    RBRACE          reduce using rule 169 (expr -> INCLUDE expr .)
    RBRACKET        reduce using rule 169 (expr -> INCLUDE expr .)
    COLON           reduce using rule 169 (expr -> INCLUDE expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! PLUS            [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! MINUS           [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! MULT            [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! DIV             [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! MOD             [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! BIT_OR          [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! BIT_XOR         [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! BIT_AND         [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! AND_OP          [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! OR_OP           [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! IDENTICAL       [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! EQ_EQ           [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! NOT_EQ          [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! LESSER          [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! LESSER_EQ       [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! GREATER         [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! GREATER_EQ      [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! INSTANCEOF      [ reduce using rule 169 (expr -> INCLUDE expr .) ]
  ! COND_OP         [ reduce using rule 169 (expr -> INCLUDE expr .) ]


state 94

    (44) stmt -> SWITCH LPAREN . expr RPAREN goto_marker switch_stmt jump_marker
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 166
    variable                       shift and go to state 53

state 95

    (110) expr -> ARRAY LPAREN . array_pair_list RPAREN
    (111) array_pair_list -> . empty
    (112) array_pair_list -> . non_empty_array_pair_list possible_comma
    (179) empty -> .
    (115) non_empty_array_pair_list -> . non_empty_array_pair_list COMMA BIT_AND variable
    (116) non_empty_array_pair_list -> . non_empty_array_pair_list COMMA expr
    (117) non_empty_array_pair_list -> . BIT_AND variable
    (118) non_empty_array_pair_list -> . expr
    (119) non_empty_array_pair_list -> . non_empty_array_pair_list COMMA expr DOUBLE_ARROW BIT_AND variable
    (120) non_empty_array_pair_list -> . non_empty_array_pair_list COMMA expr DOUBLE_ARROW expr
    (121) non_empty_array_pair_list -> . expr DOUBLE_ARROW BIT_AND variable
    (122) non_empty_array_pair_list -> . expr DOUBLE_ARROW expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    RPAREN          reduce using rule 179 (empty -> .)
    BIT_AND         shift and go to state 168
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 170
    array_pair_list                shift and go to state 169
    empty                          shift and go to state 171
    variable                       shift and go to state 53
    non_empty_array_pair_list      shift and go to state 167

state 96

    (19) if_stmt -> if_stmt_without_else ELSE . goto_marker jump_marker stmt
    (178) goto_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    goto_marker                    shift and go to state 172
    empty                          shift and go to state 80

state 97

    (21) if_stmt_without_else -> if_stmt_without_else ELSEIF . goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt
    (178) goto_marker -> . empty
    (179) empty -> .

    LPAREN          reduce using rule 179 (empty -> .)


    goto_marker                    shift and go to state 173
    empty                          shift and go to state 80

state 98

    (88) base_var -> base_var LBRACE . expr RBRACE
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 174
    variable                       shift and go to state 53

state 99

    (92) expr -> base_var EQUAL . expr
    (93) expr -> base_var EQUAL . BIT_AND expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    BIT_AND         shift and go to state 175
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 176
    variable                       shift and go to state 53

state 100

    (87) base_var -> base_var LBRACKET . dim_offset RBRACKET
    (90) dim_offset -> . expr
    (91) dim_offset -> . empty
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (179) empty -> .
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    RBRACKET        reduce using rule 179 (empty -> .)
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    dim_offset                     shift and go to state 178
    expr                           shift and go to state 179
    empty                          shift and go to state 177
    variable                       shift and go to state 53

state 101

    (144) expr -> expr EQ_EQ . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 180
    variable                       shift and go to state 53

state 102

    (149) expr -> expr GREATER_EQ . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 181
    variable                       shift and go to state 53

state 103

    (133) expr -> expr DIV . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 182
    variable                       shift and go to state 53

state 104

    (136) expr -> expr BIT_XOR . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 183
    variable                       shift and go to state 53

state 105

    (131) expr -> expr MINUS . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 184
    variable                       shift and go to state 53

state 106

    (129) expr -> expr DOT . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 185
    variable                       shift and go to state 53

state 107

    (142) expr -> expr IDENTICAL . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 186
    variable                       shift and go to state 53

state 108

    (73) stmt -> expr SEMICOLON .

    WHILE           reduce using rule 73 (stmt -> expr SEMICOLON .)
    DO              reduce using rule 73 (stmt -> expr SEMICOLON .)
    FOR             reduce using rule 73 (stmt -> expr SEMICOLON .)
    FOREACH         reduce using rule 73 (stmt -> expr SEMICOLON .)
    SWITCH          reduce using rule 73 (stmt -> expr SEMICOLON .)
    BREAK           reduce using rule 73 (stmt -> expr SEMICOLON .)
    CONTINUE        reduce using rule 73 (stmt -> expr SEMICOLON .)
    RETURN          reduce using rule 73 (stmt -> expr SEMICOLON .)
    GLOBAL          reduce using rule 73 (stmt -> expr SEMICOLON .)
    STATIC          reduce using rule 73 (stmt -> expr SEMICOLON .)
    ECHO            reduce using rule 73 (stmt -> expr SEMICOLON .)
    LBRACE          reduce using rule 73 (stmt -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 73 (stmt -> expr SEMICOLON .)
    FUNCTION        reduce using rule 73 (stmt -> expr SEMICOLON .)
    CLONE           reduce using rule 73 (stmt -> expr SEMICOLON .)
    ARRAY           reduce using rule 73 (stmt -> expr SEMICOLON .)
    PLUS            reduce using rule 73 (stmt -> expr SEMICOLON .)
    MINUS           reduce using rule 73 (stmt -> expr SEMICOLON .)
    BIT_NOT         reduce using rule 73 (stmt -> expr SEMICOLON .)
    NOT             reduce using rule 73 (stmt -> expr SEMICOLON .)
    CONST_DECIMAL   reduce using rule 73 (stmt -> expr SEMICOLON .)
    CONST_DOUBLE    reduce using rule 73 (stmt -> expr SEMICOLON .)
    CONST_STRING    reduce using rule 73 (stmt -> expr SEMICOLON .)
    NULL            reduce using rule 73 (stmt -> expr SEMICOLON .)
    TRUE            reduce using rule 73 (stmt -> expr SEMICOLON .)
    FALSE           reduce using rule 73 (stmt -> expr SEMICOLON .)
    INC             reduce using rule 73 (stmt -> expr SEMICOLON .)
    DEC             reduce using rule 73 (stmt -> expr SEMICOLON .)
    EMPTY           reduce using rule 73 (stmt -> expr SEMICOLON .)
    EVAL            reduce using rule 73 (stmt -> expr SEMICOLON .)
    LPAREN          reduce using rule 73 (stmt -> expr SEMICOLON .)
    INCLUDE         reduce using rule 73 (stmt -> expr SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 73 (stmt -> expr SEMICOLON .)
    REQUIRE         reduce using rule 73 (stmt -> expr SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 73 (stmt -> expr SEMICOLON .)
    EXIT            reduce using rule 73 (stmt -> expr SEMICOLON .)
    PRINT           reduce using rule 73 (stmt -> expr SEMICOLON .)
    IF              reduce using rule 73 (stmt -> expr SEMICOLON .)
    IDENTIFIER      reduce using rule 73 (stmt -> expr SEMICOLON .)
    STRING          reduce using rule 73 (stmt -> expr SEMICOLON .)
    $end            reduce using rule 73 (stmt -> expr SEMICOLON .)
    RBRACE          reduce using rule 73 (stmt -> expr SEMICOLON .)
    ENDIF           reduce using rule 73 (stmt -> expr SEMICOLON .)
    ELSE            reduce using rule 73 (stmt -> expr SEMICOLON .)
    ELSEIF          reduce using rule 73 (stmt -> expr SEMICOLON .)
    ENDWHILE        reduce using rule 73 (stmt -> expr SEMICOLON .)
    ENDFOREACH      reduce using rule 73 (stmt -> expr SEMICOLON .)
    CASE            reduce using rule 73 (stmt -> expr SEMICOLON .)
    DEFAULT         reduce using rule 73 (stmt -> expr SEMICOLON .)
    ENDSWITCH       reduce using rule 73 (stmt -> expr SEMICOLON .)
    ENDFOR          reduce using rule 73 (stmt -> expr SEMICOLON .)



state 109

    (141) expr -> expr OR_OP . jump_marker expr
    (177) jump_marker -> . empty
    (179) empty -> .

    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 187
    empty                          shift and go to state 68

state 110

    (130) expr -> expr PLUS . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 188
    variable                       shift and go to state 53

state 111

    (132) expr -> expr MULT . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 189
    variable                       shift and go to state 53

state 112

    (145) expr -> expr NOT_EQ . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 190
    variable                       shift and go to state 53

state 113

    (143) expr -> expr NOT_IDENTICAL . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 191
    variable                       shift and go to state 53

state 114

    (137) expr -> expr BIT_AND . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 192
    variable                       shift and go to state 53

state 115

    (147) expr -> expr LESSER_EQ . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 193
    variable                       shift and go to state 53

state 116

    (140) expr -> expr AND_OP . jump_marker expr
    (177) jump_marker -> . empty
    (179) empty -> .

    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 194
    empty                          shift and go to state 68

state 117

    (150) expr -> expr INSTANCEOF . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 195
    variable                       shift and go to state 53

state 118

    (148) expr -> expr GREATER . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 196
    variable                       shift and go to state 53

state 119

    (161) expr -> expr COND_OP . jump_marker expr goto_marker jump_marker COLON expr
    (177) jump_marker -> . empty
    (179) empty -> .

    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 197
    empty                          shift and go to state 68

state 120

    (139) expr -> expr BIT_RSHIFT . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 198
    variable                       shift and go to state 53

state 121

    (135) expr -> expr BIT_OR . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 199
    variable                       shift and go to state 53

state 122

    (146) expr -> expr LESSER . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 200
    variable                       shift and go to state 53

state 123

    (138) expr -> expr BIT_LSHIFT . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 201
    variable                       shift and go to state 53

state 124

    (134) expr -> expr MOD . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 202
    variable                       shift and go to state 53

state 125

    (54) stmt -> BREAK goto_marker . SEMICOLON

    SEMICOLON       shift and go to state 203



state 126

    (55) stmt -> BREAK expr . goto_marker SEMICOLON
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (178) goto_marker -> . empty
    (179) empty -> .

    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119
    SEMICOLON       reduce using rule 179 (empty -> .)


    empty                          shift and go to state 80
    goto_marker                    shift and go to state 204

state 127

    (174) expr -> EXIT LPAREN . RPAREN
    (175) expr -> EXIT LPAREN . expr RPAREN
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    RPAREN          shift and go to state 205
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 206
    variable                       shift and go to state 53

state 128

    (29) stmt -> DO stmt . WHILE LPAREN expr RPAREN SEMICOLON

    WHILE           shift and go to state 207



state 129

    (81) func_call -> STRING LPAREN . func_params RPAREN
    (82) func_params -> . func_params COMMA func_param
    (83) func_params -> . func_param
    (84) func_params -> . empty
    (85) func_param -> . expr
    (86) func_param -> . BIT_AND variable
    (179) empty -> .
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    BIT_AND         shift and go to state 211
    RPAREN          reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_params                    shift and go to state 208
    base_var                       shift and go to state 43
    func_param                     shift and go to state 210
    func_call                      shift and go to state 40
    expr                           shift and go to state 212
    variable                       shift and go to state 53
    empty                          shift and go to state 209

state 130

    (168) expr -> LPAREN expr . RPAREN
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    RPAREN          shift and go to state 213
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 131

    (127) expr -> variable DOT_EQ . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 214
    variable                       shift and go to state 53

state 132

    (125) expr -> variable MULTIPLY_EQ . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 215
    variable                       shift and go to state 53

state 133

    (165) expr -> variable DEC .

    DOT             reduce using rule 165 (expr -> variable DEC .)
    PLUS            reduce using rule 165 (expr -> variable DEC .)
    MINUS           reduce using rule 165 (expr -> variable DEC .)
    MULT            reduce using rule 165 (expr -> variable DEC .)
    DIV             reduce using rule 165 (expr -> variable DEC .)
    MOD             reduce using rule 165 (expr -> variable DEC .)
    BIT_OR          reduce using rule 165 (expr -> variable DEC .)
    BIT_XOR         reduce using rule 165 (expr -> variable DEC .)
    BIT_AND         reduce using rule 165 (expr -> variable DEC .)
    BIT_LSHIFT      reduce using rule 165 (expr -> variable DEC .)
    BIT_RSHIFT      reduce using rule 165 (expr -> variable DEC .)
    AND_OP          reduce using rule 165 (expr -> variable DEC .)
    OR_OP           reduce using rule 165 (expr -> variable DEC .)
    IDENTICAL       reduce using rule 165 (expr -> variable DEC .)
    NOT_IDENTICAL   reduce using rule 165 (expr -> variable DEC .)
    EQ_EQ           reduce using rule 165 (expr -> variable DEC .)
    NOT_EQ          reduce using rule 165 (expr -> variable DEC .)
    LESSER          reduce using rule 165 (expr -> variable DEC .)
    LESSER_EQ       reduce using rule 165 (expr -> variable DEC .)
    GREATER         reduce using rule 165 (expr -> variable DEC .)
    GREATER_EQ      reduce using rule 165 (expr -> variable DEC .)
    INSTANCEOF      reduce using rule 165 (expr -> variable DEC .)
    COND_OP         reduce using rule 165 (expr -> variable DEC .)
    SEMICOLON       reduce using rule 165 (expr -> variable DEC .)
    COMMA           reduce using rule 165 (expr -> variable DEC .)
    RPAREN          reduce using rule 165 (expr -> variable DEC .)
    AS              reduce using rule 165 (expr -> variable DEC .)
    DOUBLE_ARROW    reduce using rule 165 (expr -> variable DEC .)
    RBRACE          reduce using rule 165 (expr -> variable DEC .)
    RBRACKET        reduce using rule 165 (expr -> variable DEC .)
    COLON           reduce using rule 165 (expr -> variable DEC .)



state 134

    (126) expr -> variable DIVIDE_EQ . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 216
    variable                       shift and go to state 53

state 135

    (123) expr -> variable PLUS_EQ . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 217
    variable                       shift and go to state 53

state 136

    (124) expr -> variable MINUS_EQ . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 218
    variable                       shift and go to state 53

state 137

    (128) expr -> variable MOD_EQ . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 219
    variable                       shift and go to state 53

state 138

    (164) expr -> variable INC .

    DOT             reduce using rule 164 (expr -> variable INC .)
    PLUS            reduce using rule 164 (expr -> variable INC .)
    MINUS           reduce using rule 164 (expr -> variable INC .)
    MULT            reduce using rule 164 (expr -> variable INC .)
    DIV             reduce using rule 164 (expr -> variable INC .)
    MOD             reduce using rule 164 (expr -> variable INC .)
    BIT_OR          reduce using rule 164 (expr -> variable INC .)
    BIT_XOR         reduce using rule 164 (expr -> variable INC .)
    BIT_AND         reduce using rule 164 (expr -> variable INC .)
    BIT_LSHIFT      reduce using rule 164 (expr -> variable INC .)
    BIT_RSHIFT      reduce using rule 164 (expr -> variable INC .)
    AND_OP          reduce using rule 164 (expr -> variable INC .)
    OR_OP           reduce using rule 164 (expr -> variable INC .)
    IDENTICAL       reduce using rule 164 (expr -> variable INC .)
    NOT_IDENTICAL   reduce using rule 164 (expr -> variable INC .)
    EQ_EQ           reduce using rule 164 (expr -> variable INC .)
    NOT_EQ          reduce using rule 164 (expr -> variable INC .)
    LESSER          reduce using rule 164 (expr -> variable INC .)
    LESSER_EQ       reduce using rule 164 (expr -> variable INC .)
    GREATER         reduce using rule 164 (expr -> variable INC .)
    GREATER_EQ      reduce using rule 164 (expr -> variable INC .)
    INSTANCEOF      reduce using rule 164 (expr -> variable INC .)
    COND_OP         reduce using rule 164 (expr -> variable INC .)
    SEMICOLON       reduce using rule 164 (expr -> variable INC .)
    COMMA           reduce using rule 164 (expr -> variable INC .)
    RPAREN          reduce using rule 164 (expr -> variable INC .)
    AS              reduce using rule 164 (expr -> variable INC .)
    DOUBLE_ARROW    reduce using rule 164 (expr -> variable INC .)
    RBRACE          reduce using rule 164 (expr -> variable INC .)
    RBRACKET        reduce using rule 164 (expr -> variable INC .)
    COLON           reduce using rule 164 (expr -> variable INC .)



state 139

    (20) if_stmt_without_else -> IF LPAREN . expr RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> IF LPAREN . expr RPAREN COLON jump_marker inner_stmts
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 220
    variable                       shift and go to state 53

state 140

    (162) expr -> INC variable .

    DOT             reduce using rule 162 (expr -> INC variable .)
    PLUS            reduce using rule 162 (expr -> INC variable .)
    MINUS           reduce using rule 162 (expr -> INC variable .)
    MULT            reduce using rule 162 (expr -> INC variable .)
    DIV             reduce using rule 162 (expr -> INC variable .)
    MOD             reduce using rule 162 (expr -> INC variable .)
    BIT_OR          reduce using rule 162 (expr -> INC variable .)
    BIT_XOR         reduce using rule 162 (expr -> INC variable .)
    BIT_AND         reduce using rule 162 (expr -> INC variable .)
    BIT_LSHIFT      reduce using rule 162 (expr -> INC variable .)
    BIT_RSHIFT      reduce using rule 162 (expr -> INC variable .)
    AND_OP          reduce using rule 162 (expr -> INC variable .)
    OR_OP           reduce using rule 162 (expr -> INC variable .)
    IDENTICAL       reduce using rule 162 (expr -> INC variable .)
    NOT_IDENTICAL   reduce using rule 162 (expr -> INC variable .)
    EQ_EQ           reduce using rule 162 (expr -> INC variable .)
    NOT_EQ          reduce using rule 162 (expr -> INC variable .)
    LESSER          reduce using rule 162 (expr -> INC variable .)
    LESSER_EQ       reduce using rule 162 (expr -> INC variable .)
    GREATER         reduce using rule 162 (expr -> INC variable .)
    GREATER_EQ      reduce using rule 162 (expr -> INC variable .)
    INSTANCEOF      reduce using rule 162 (expr -> INC variable .)
    COND_OP         reduce using rule 162 (expr -> INC variable .)
    SEMICOLON       reduce using rule 162 (expr -> INC variable .)
    COMMA           reduce using rule 162 (expr -> INC variable .)
    RPAREN          reduce using rule 162 (expr -> INC variable .)
    AS              reduce using rule 162 (expr -> INC variable .)
    DOUBLE_ARROW    reduce using rule 162 (expr -> INC variable .)
    RBRACE          reduce using rule 162 (expr -> INC variable .)
    RBRACKET        reduce using rule 162 (expr -> INC variable .)
    COLON           reduce using rule 162 (expr -> INC variable .)



state 141

    (23) alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker . jump_marker COLON inner_stmts ENDIF SEMICOLON
    (177) jump_marker -> . empty
    (179) empty -> .

    COLON           reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 221
    empty                          shift and go to state 68

state 142

    (22) alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .

    WHILE           reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    DO              reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    FOR             reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    FOREACH         reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    SWITCH          reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    BREAK           reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    CONTINUE        reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    RETURN          reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    GLOBAL          reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    STATIC          reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ECHO            reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    LBRACE          reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    SEMICOLON       reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    FUNCTION        reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    CLONE           reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ARRAY           reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    PLUS            reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    MINUS           reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    BIT_NOT         reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    NOT             reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    CONST_DECIMAL   reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    CONST_DOUBLE    reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    CONST_STRING    reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    NULL            reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    TRUE            reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    FALSE           reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    INC             reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    DEC             reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    EMPTY           reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    EVAL            reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    LPAREN          reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    INCLUDE         reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    REQUIRE         reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    EXIT            reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    PRINT           reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    IF              reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    IDENTIFIER      reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    STRING          reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    $end            reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    RBRACE          reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ENDIF           reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ELSE            reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ELSEIF          reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ENDWHILE        reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ENDFOREACH      reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    CASE            reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    DEFAULT         reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ENDSWITCH       reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)
    ENDFOR          reduce using rule 22 (alt_if_stmt -> alt_if_stmt_without_else ENDIF SEMICOLON .)



state 143

    (25) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF goto_marker . LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts

    LPAREN          shift and go to state 222



state 144

    (37) stmt -> FOREACH LPAREN expr . AS foreach_var foreach_arg RPAREN foreach_stmt
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    AS              shift and go to state 223
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 145

    (167) expr -> EVAL LPAREN expr . RPAREN
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    RPAREN          shift and go to state 224
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 146

    (3) stmt_list -> top_stmt jump_marker stmt_list .

    $end            reduce using rule 3 (stmt_list -> top_stmt jump_marker stmt_list .)



state 147

    (59) stmt -> RETURN expr SEMICOLON .

    WHILE           reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    DO              reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    FOREACH         reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    SWITCH          reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    BREAK           reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    CONTINUE        reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    GLOBAL          reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    STATIC          reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    ECHO            reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    FUNCTION        reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    CLONE           reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    ARRAY           reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    PLUS            reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    MINUS           reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    BIT_NOT         reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    NOT             reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    CONST_DECIMAL   reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    CONST_DOUBLE    reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    CONST_STRING    reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    NULL            reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    TRUE            reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    FALSE           reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    INC             reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    DEC             reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    EMPTY           reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    EVAL            reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    INCLUDE         reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    REQUIRE         reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    EXIT            reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    PRINT           reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    IF              reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    IDENTIFIER      reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    STRING          reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    $end            reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    ENDIF           reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    ELSEIF          reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    ENDWHILE        reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    ENDFOREACH      reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    CASE            reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    DEFAULT         reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    ENDSWITCH       reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)
    ENDFOR          reduce using rule 59 (stmt -> RETURN expr SEMICOLON .)



state 148

    (64) static_var_list -> static_var_list COMMA . static_var
    (66) static_var -> . IDENTIFIER EQUAL scalar
    (67) static_var -> . IDENTIFIER

    IDENTIFIER      shift and go to state 74


    static_var                     shift and go to state 225

state 149

    (63) stmt -> STATIC static_var_list SEMICOLON .

    WHILE           reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    DO              reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    FOR             reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    FOREACH         reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    SWITCH          reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    BREAK           reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    CONTINUE        reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    RETURN          reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    GLOBAL          reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    STATIC          reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    ECHO            reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    LBRACE          reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    SEMICOLON       reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    FUNCTION        reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    CLONE           reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    ARRAY           reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    PLUS            reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    MINUS           reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    BIT_NOT         reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    NOT             reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    CONST_DECIMAL   reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    CONST_DOUBLE    reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    CONST_STRING    reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    NULL            reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    TRUE            reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    FALSE           reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    INC             reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    DEC             reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    EMPTY           reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    EVAL            reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    LPAREN          reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    INCLUDE         reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    REQUIRE         reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    EXIT            reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    PRINT           reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    IF              reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    IDENTIFIER      reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    STRING          reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    $end            reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    RBRACE          reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    ENDIF           reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    ELSE            reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    ELSEIF          reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    ENDWHILE        reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    ENDFOREACH      reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    CASE            reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    DEFAULT         reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    ENDSWITCH       reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)
    ENDFOR          reduce using rule 63 (stmt -> STATIC static_var_list SEMICOLON .)



state 150

    (66) static_var -> IDENTIFIER EQUAL . scalar
    (95) scalar -> . CONST_DECIMAL
    (96) scalar -> . CONST_DOUBLE
    (97) scalar -> . CONST_STRING
    (98) scalar -> . NULL
    (99) scalar -> . TRUE
    (100) scalar -> . FALSE
    (101) scalar -> . PLUS scalar
    (102) scalar -> . MINUS scalar
    (103) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 229
    CONST_DOUBLE    shift and go to state 230
    CONST_STRING    shift and go to state 228
    NULL            shift and go to state 226
    TRUE            shift and go to state 234
    FALSE           shift and go to state 227
    PLUS            shift and go to state 232
    MINUS           shift and go to state 235
    ARRAY           shift and go to state 233


    scalar                         shift and go to state 231

state 151

    (166) expr -> EMPTY LPAREN expr . RPAREN
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    RPAREN          shift and go to state 236
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 152

    (7) func_decl -> FUNCTION goto_marker STRING . func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker
    (8) func_table_marker -> . empty
    (179) empty -> .

    LPAREN          reduce using rule 179 (empty -> .)


    func_table_marker              shift and go to state 237
    empty                          shift and go to state 238

state 153

    (32) for_expr -> non_empty_for_expr .
    (33) non_empty_for_expr -> non_empty_for_expr . COMMA expr

    SEMICOLON       reduce using rule 32 (for_expr -> non_empty_for_expr .)
    RPAREN          reduce using rule 32 (for_expr -> non_empty_for_expr .)
    COMMA           shift and go to state 239



state 154

    (31) for_expr -> empty .

    SEMICOLON       reduce using rule 31 (for_expr -> empty .)
    RPAREN          reduce using rule 31 (for_expr -> empty .)



state 155

    (34) non_empty_for_expr -> expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    COMMA           reduce using rule 34 (non_empty_for_expr -> expr .)
    SEMICOLON       reduce using rule 34 (non_empty_for_expr -> expr .)
    RPAREN          reduce using rule 34 (non_empty_for_expr -> expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 156

    (30) stmt -> FOR LPAREN for_expr . SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker

    SEMICOLON       shift and go to state 240



state 157

    (69) echo_expr_list -> echo_expr_list COMMA . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 241
    variable                       shift and go to state 53

state 158

    (68) stmt -> ECHO echo_expr_list SEMICOLON .

    WHILE           reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    DO              reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    FOR             reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    FOREACH         reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    SWITCH          reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    BREAK           reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    CONTINUE        reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    RETURN          reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    GLOBAL          reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    STATIC          reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ECHO            reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    LBRACE          reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    SEMICOLON       reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    FUNCTION        reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    CLONE           reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ARRAY           reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    PLUS            reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    MINUS           reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    BIT_NOT         reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    NOT             reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    CONST_DECIMAL   reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    CONST_DOUBLE    reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    CONST_STRING    reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    NULL            reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    TRUE            reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    FALSE           reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    INC             reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    DEC             reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    EMPTY           reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    EVAL            reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    LPAREN          reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    INCLUDE         reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    REQUIRE         reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    EXIT            reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    PRINT           reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    IF              reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    IDENTIFIER      reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    STRING          reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    $end            reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    RBRACE          reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ENDIF           reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ELSE            reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ELSEIF          reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ENDWHILE        reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ENDFOREACH      reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    CASE            reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    DEFAULT         reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ENDSWITCH       reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)
    ENDFOR          reduce using rule 68 (stmt -> ECHO echo_expr_list SEMICOLON .)



state 159

    (71) stmt -> LBRACE inner_stmts RBRACE .

    WHILE           reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    DO              reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    FOR             reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    FOREACH         reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    SWITCH          reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    BREAK           reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    CONTINUE        reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    RETURN          reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    GLOBAL          reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    STATIC          reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    ECHO            reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    LBRACE          reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    SEMICOLON       reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    FUNCTION        reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    CLONE           reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    ARRAY           reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    PLUS            reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    MINUS           reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    BIT_NOT         reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    NOT             reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    CONST_DECIMAL   reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    CONST_DOUBLE    reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    CONST_STRING    reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    NULL            reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    TRUE            reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    FALSE           reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    INC             reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    DEC             reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    EMPTY           reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    EVAL            reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    LPAREN          reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    INCLUDE         reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    INCLUDE_ONCE    reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    REQUIRE         reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    REQUIRE_ONCE    reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    EXIT            reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    PRINT           reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    IF              reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    IDENTIFIER      reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    STRING          reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    $end            reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    RBRACE          reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    ENDIF           reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    ELSE            reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    ELSEIF          reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    ENDWHILE        reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    ENDFOREACH      reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    CASE            reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    DEFAULT         reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    ENDSWITCH       reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)
    ENDFOR          reduce using rule 71 (stmt -> LBRACE inner_stmts RBRACE .)



state 160

    (74) inner_stmts -> inner_stmts jump_marker . inner_stmt
    (76) inner_stmt -> . stmt
    (77) inner_stmt -> . func_decl
    (16) stmt -> . if_stmt
    (17) stmt -> . alt_if_stmt
    (26) stmt -> . WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker
    (29) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (30) stmt -> . FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (37) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (44) stmt -> . SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker
    (54) stmt -> . BREAK goto_marker SEMICOLON
    (55) stmt -> . BREAK expr goto_marker SEMICOLON
    (56) stmt -> . CONTINUE goto_marker SEMICOLON
    (57) stmt -> . CONTINUE expr goto_marker SEMICOLON
    (58) stmt -> . RETURN SEMICOLON
    (59) stmt -> . RETURN expr SEMICOLON
    (60) stmt -> . GLOBAL global_var_list SEMICOLON
    (63) stmt -> . STATIC static_var_list SEMICOLON
    (68) stmt -> . ECHO echo_expr_list SEMICOLON
    (71) stmt -> . LBRACE inner_stmts RBRACE
    (72) stmt -> . SEMICOLON
    (73) stmt -> . expr SEMICOLON
    (7) func_decl -> . FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker
    (18) if_stmt -> . if_stmt_without_else
    (19) if_stmt -> . if_stmt_without_else ELSE goto_marker jump_marker stmt
    (22) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (23) alt_if_stmt -> . alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (20) if_stmt_without_else -> . IF LPAREN expr RPAREN jump_marker stmt
    (21) if_stmt_without_else -> . if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON jump_marker inner_stmts
    (25) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    WHILE           shift and go to state 33
    DO              shift and go to state 49
    FOR             shift and go to state 24
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 36
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 30
    RETURN          shift and go to state 16
    GLOBAL          shift and go to state 32
    STATIC          shift and go to state 18
    ECHO            shift and go to state 27
    LBRACE          shift and go to state 29
    SEMICOLON       shift and go to state 35
    FUNCTION        shift and go to state 23
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    inner_stmt                     shift and go to state 244
    func_decl                      shift and go to state 243
    alt_if_stmt                    shift and go to state 25
    stmt                           shift and go to state 242
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 13
    expr                           shift and go to state 45

state 161

    (56) stmt -> CONTINUE goto_marker SEMICOLON .

    WHILE           reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    DO              reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    FOR             reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    FOREACH         reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    SWITCH          reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    BREAK           reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    CONTINUE        reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    RETURN          reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    GLOBAL          reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    STATIC          reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    ECHO            reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    LBRACE          reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    SEMICOLON       reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    FUNCTION        reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    CLONE           reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    ARRAY           reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    PLUS            reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    MINUS           reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    BIT_NOT         reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    NOT             reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    CONST_DECIMAL   reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    CONST_DOUBLE    reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    CONST_STRING    reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    NULL            reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    TRUE            reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    FALSE           reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    INC             reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    DEC             reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    EMPTY           reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    EVAL            reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    LPAREN          reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    INCLUDE         reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    REQUIRE         reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    EXIT            reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    PRINT           reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    IF              reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    IDENTIFIER      reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    STRING          reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    $end            reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    RBRACE          reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    ENDIF           reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    ELSE            reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    ELSEIF          reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    ENDWHILE        reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    ENDFOREACH      reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    CASE            reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    DEFAULT         reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    ENDSWITCH       reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)
    ENDFOR          reduce using rule 56 (stmt -> CONTINUE goto_marker SEMICOLON .)



state 162

    (57) stmt -> CONTINUE expr goto_marker . SEMICOLON

    SEMICOLON       shift and go to state 245



state 163

    (61) global_var_list -> global_var_list COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 246



state 164

    (60) stmt -> GLOBAL global_var_list SEMICOLON .

    WHILE           reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    DO              reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    FOR             reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    FOREACH         reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    SWITCH          reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    BREAK           reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    CONTINUE        reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    RETURN          reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    GLOBAL          reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    STATIC          reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ECHO            reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    LBRACE          reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    SEMICOLON       reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    FUNCTION        reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    CLONE           reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ARRAY           reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    PLUS            reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    MINUS           reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    BIT_NOT         reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    NOT             reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    CONST_DECIMAL   reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    CONST_DOUBLE    reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    CONST_STRING    reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    NULL            reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    TRUE            reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    FALSE           reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    INC             reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    DEC             reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    EMPTY           reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    EVAL            reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    LPAREN          reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    INCLUDE         reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    REQUIRE         reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    EXIT            reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    PRINT           reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    IF              reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    IDENTIFIER      reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    STRING          reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    $end            reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    RBRACE          reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ENDIF           reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ELSE            reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ELSEIF          reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ENDWHILE        reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ENDFOREACH      reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    CASE            reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    DEFAULT         reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ENDSWITCH       reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)
    ENDFOR          reduce using rule 60 (stmt -> GLOBAL global_var_list SEMICOLON .)



state 165

    (26) stmt -> WHILE LPAREN jump_marker . expr jump_marker RPAREN while_stmt goto_marker
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 247
    variable                       shift and go to state 53

state 166

    (44) stmt -> SWITCH LPAREN expr . RPAREN goto_marker switch_stmt jump_marker
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    RPAREN          shift and go to state 248
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 167

    (112) array_pair_list -> non_empty_array_pair_list . possible_comma
    (115) non_empty_array_pair_list -> non_empty_array_pair_list . COMMA BIT_AND variable
    (116) non_empty_array_pair_list -> non_empty_array_pair_list . COMMA expr
    (119) non_empty_array_pair_list -> non_empty_array_pair_list . COMMA expr DOUBLE_ARROW BIT_AND variable
    (120) non_empty_array_pair_list -> non_empty_array_pair_list . COMMA expr DOUBLE_ARROW expr
    (113) possible_comma -> . empty
    (114) possible_comma -> . COMMA
    (179) empty -> .

    COMMA           shift and go to state 250
    RPAREN          reduce using rule 179 (empty -> .)


    empty                          shift and go to state 251
    possible_comma                 shift and go to state 249

state 168

    (117) non_empty_array_pair_list -> BIT_AND . variable
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    base_var                       shift and go to state 76
    func_call                      shift and go to state 40
    variable                       shift and go to state 252

state 169

    (110) expr -> ARRAY LPAREN array_pair_list . RPAREN

    RPAREN          shift and go to state 253



state 170

    (118) non_empty_array_pair_list -> expr .
    (121) non_empty_array_pair_list -> expr . DOUBLE_ARROW BIT_AND variable
    (122) non_empty_array_pair_list -> expr . DOUBLE_ARROW expr
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    COMMA           reduce using rule 118 (non_empty_array_pair_list -> expr .)
    RPAREN          reduce using rule 118 (non_empty_array_pair_list -> expr .)
    DOUBLE_ARROW    shift and go to state 254
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 171

    (111) array_pair_list -> empty .

    RPAREN          reduce using rule 111 (array_pair_list -> empty .)



state 172

    (19) if_stmt -> if_stmt_without_else ELSE goto_marker . jump_marker stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 255
    empty                          shift and go to state 68

state 173

    (21) if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker . LPAREN jump_marker expr RPAREN jump_marker stmt

    LPAREN          shift and go to state 256



state 174

    (88) base_var -> base_var LBRACE expr . RBRACE
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    RBRACE          shift and go to state 257
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 175

    (93) expr -> base_var EQUAL BIT_AND . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 258
    variable                       shift and go to state 53

state 176

    (92) expr -> base_var EQUAL expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 92 (expr -> base_var EQUAL expr .)
    BIT_XOR         reduce using rule 92 (expr -> base_var EQUAL expr .)
    BIT_AND         reduce using rule 92 (expr -> base_var EQUAL expr .)
    SEMICOLON       reduce using rule 92 (expr -> base_var EQUAL expr .)
    COMMA           reduce using rule 92 (expr -> base_var EQUAL expr .)
    RPAREN          reduce using rule 92 (expr -> base_var EQUAL expr .)
    AS              reduce using rule 92 (expr -> base_var EQUAL expr .)
    DOUBLE_ARROW    reduce using rule 92 (expr -> base_var EQUAL expr .)
    RBRACE          reduce using rule 92 (expr -> base_var EQUAL expr .)
    RBRACKET        reduce using rule 92 (expr -> base_var EQUAL expr .)
    COLON           reduce using rule 92 (expr -> base_var EQUAL expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! PLUS            [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! MINUS           [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! MULT            [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! DIV             [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! MOD             [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! AND_OP          [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! OR_OP           [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! IDENTICAL       [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! EQ_EQ           [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! NOT_EQ          [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! LESSER          [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! LESSER_EQ       [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! GREATER         [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! GREATER_EQ      [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! INSTANCEOF      [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! COND_OP         [ reduce using rule 92 (expr -> base_var EQUAL expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]


state 177

    (91) dim_offset -> empty .

    RBRACKET        reduce using rule 91 (dim_offset -> empty .)



state 178

    (87) base_var -> base_var LBRACKET dim_offset . RBRACKET

    RBRACKET        shift and go to state 259



state 179

    (90) dim_offset -> expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    RBRACKET        reduce using rule 90 (dim_offset -> expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 180

    (144) expr -> expr EQ_EQ expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 144 (expr -> expr EQ_EQ expr .)
    BIT_XOR         reduce using rule 144 (expr -> expr EQ_EQ expr .)
    BIT_AND         reduce using rule 144 (expr -> expr EQ_EQ expr .)
    AND_OP          reduce using rule 144 (expr -> expr EQ_EQ expr .)
    OR_OP           reduce using rule 144 (expr -> expr EQ_EQ expr .)
    IDENTICAL       reduce using rule 144 (expr -> expr EQ_EQ expr .)
    NOT_IDENTICAL   reduce using rule 144 (expr -> expr EQ_EQ expr .)
    EQ_EQ           reduce using rule 144 (expr -> expr EQ_EQ expr .)
    NOT_EQ          reduce using rule 144 (expr -> expr EQ_EQ expr .)
    COND_OP         reduce using rule 144 (expr -> expr EQ_EQ expr .)
    SEMICOLON       reduce using rule 144 (expr -> expr EQ_EQ expr .)
    COMMA           reduce using rule 144 (expr -> expr EQ_EQ expr .)
    RPAREN          reduce using rule 144 (expr -> expr EQ_EQ expr .)
    AS              reduce using rule 144 (expr -> expr EQ_EQ expr .)
    DOUBLE_ARROW    reduce using rule 144 (expr -> expr EQ_EQ expr .)
    RBRACE          reduce using rule 144 (expr -> expr EQ_EQ expr .)
    RBRACKET        reduce using rule 144 (expr -> expr EQ_EQ expr .)
    COLON           reduce using rule 144 (expr -> expr EQ_EQ expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! PLUS            [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! MINUS           [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! MULT            [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! DIV             [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! MOD             [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! LESSER          [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! GREATER         [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 144 (expr -> expr EQ_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! COND_OP         [ shift and go to state 119 ]


state 181

    (149) expr -> expr GREATER_EQ expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    BIT_XOR         reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    BIT_AND         reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    AND_OP          reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    OR_OP           reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    IDENTICAL       reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    NOT_IDENTICAL   reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    EQ_EQ           reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    NOT_EQ          reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    LESSER          reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    LESSER_EQ       reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    GREATER         reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    GREATER_EQ      reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    COND_OP         reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    SEMICOLON       reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    COMMA           reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    RPAREN          reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    AS              reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    DOUBLE_ARROW    reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    RBRACE          reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    RBRACKET        reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    COLON           reduce using rule 149 (expr -> expr GREATER_EQ expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 149 (expr -> expr GREATER_EQ expr .) ]
  ! PLUS            [ reduce using rule 149 (expr -> expr GREATER_EQ expr .) ]
  ! MINUS           [ reduce using rule 149 (expr -> expr GREATER_EQ expr .) ]
  ! MULT            [ reduce using rule 149 (expr -> expr GREATER_EQ expr .) ]
  ! DIV             [ reduce using rule 149 (expr -> expr GREATER_EQ expr .) ]
  ! MOD             [ reduce using rule 149 (expr -> expr GREATER_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 149 (expr -> expr GREATER_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 149 (expr -> expr GREATER_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 149 (expr -> expr GREATER_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 182

    (133) expr -> expr DIV expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    DOT             reduce using rule 133 (expr -> expr DIV expr .)
    PLUS            reduce using rule 133 (expr -> expr DIV expr .)
    MINUS           reduce using rule 133 (expr -> expr DIV expr .)
    MULT            reduce using rule 133 (expr -> expr DIV expr .)
    DIV             reduce using rule 133 (expr -> expr DIV expr .)
    MOD             reduce using rule 133 (expr -> expr DIV expr .)
    BIT_OR          reduce using rule 133 (expr -> expr DIV expr .)
    BIT_XOR         reduce using rule 133 (expr -> expr DIV expr .)
    BIT_AND         reduce using rule 133 (expr -> expr DIV expr .)
    BIT_LSHIFT      reduce using rule 133 (expr -> expr DIV expr .)
    BIT_RSHIFT      reduce using rule 133 (expr -> expr DIV expr .)
    AND_OP          reduce using rule 133 (expr -> expr DIV expr .)
    OR_OP           reduce using rule 133 (expr -> expr DIV expr .)
    IDENTICAL       reduce using rule 133 (expr -> expr DIV expr .)
    NOT_IDENTICAL   reduce using rule 133 (expr -> expr DIV expr .)
    EQ_EQ           reduce using rule 133 (expr -> expr DIV expr .)
    NOT_EQ          reduce using rule 133 (expr -> expr DIV expr .)
    LESSER          reduce using rule 133 (expr -> expr DIV expr .)
    LESSER_EQ       reduce using rule 133 (expr -> expr DIV expr .)
    GREATER         reduce using rule 133 (expr -> expr DIV expr .)
    GREATER_EQ      reduce using rule 133 (expr -> expr DIV expr .)
    COND_OP         reduce using rule 133 (expr -> expr DIV expr .)
    SEMICOLON       reduce using rule 133 (expr -> expr DIV expr .)
    COMMA           reduce using rule 133 (expr -> expr DIV expr .)
    RPAREN          reduce using rule 133 (expr -> expr DIV expr .)
    AS              reduce using rule 133 (expr -> expr DIV expr .)
    DOUBLE_ARROW    reduce using rule 133 (expr -> expr DIV expr .)
    RBRACE          reduce using rule 133 (expr -> expr DIV expr .)
    RBRACKET        reduce using rule 133 (expr -> expr DIV expr .)
    COLON           reduce using rule 133 (expr -> expr DIV expr .)
    INSTANCEOF      shift and go to state 117

  ! INSTANCEOF      [ reduce using rule 133 (expr -> expr DIV expr .) ]
  ! DOT             [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 110 ]
  ! MINUS           [ shift and go to state 105 ]
  ! MULT            [ shift and go to state 111 ]
  ! DIV             [ shift and go to state 103 ]
  ! MOD             [ shift and go to state 124 ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 183

    (136) expr -> expr BIT_XOR expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 136 (expr -> expr BIT_XOR expr .)
    BIT_XOR         reduce using rule 136 (expr -> expr BIT_XOR expr .)
    SEMICOLON       reduce using rule 136 (expr -> expr BIT_XOR expr .)
    COMMA           reduce using rule 136 (expr -> expr BIT_XOR expr .)
    RPAREN          reduce using rule 136 (expr -> expr BIT_XOR expr .)
    AS              reduce using rule 136 (expr -> expr BIT_XOR expr .)
    DOUBLE_ARROW    reduce using rule 136 (expr -> expr BIT_XOR expr .)
    RBRACE          reduce using rule 136 (expr -> expr BIT_XOR expr .)
    RBRACKET        reduce using rule 136 (expr -> expr BIT_XOR expr .)
    COLON           reduce using rule 136 (expr -> expr BIT_XOR expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! PLUS            [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! MINUS           [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! MULT            [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! DIV             [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! MOD             [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! BIT_AND         [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! AND_OP          [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! OR_OP           [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! IDENTICAL       [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! EQ_EQ           [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! NOT_EQ          [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! LESSER          [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! LESSER_EQ       [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! GREATER         [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! GREATER_EQ      [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! INSTANCEOF      [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! COND_OP         [ reduce using rule 136 (expr -> expr BIT_XOR expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]


state 184

    (131) expr -> expr MINUS expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    DOT             reduce using rule 131 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 131 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 131 (expr -> expr MINUS expr .)
    BIT_OR          reduce using rule 131 (expr -> expr MINUS expr .)
    BIT_XOR         reduce using rule 131 (expr -> expr MINUS expr .)
    BIT_AND         reduce using rule 131 (expr -> expr MINUS expr .)
    BIT_LSHIFT      reduce using rule 131 (expr -> expr MINUS expr .)
    BIT_RSHIFT      reduce using rule 131 (expr -> expr MINUS expr .)
    AND_OP          reduce using rule 131 (expr -> expr MINUS expr .)
    OR_OP           reduce using rule 131 (expr -> expr MINUS expr .)
    IDENTICAL       reduce using rule 131 (expr -> expr MINUS expr .)
    NOT_IDENTICAL   reduce using rule 131 (expr -> expr MINUS expr .)
    EQ_EQ           reduce using rule 131 (expr -> expr MINUS expr .)
    NOT_EQ          reduce using rule 131 (expr -> expr MINUS expr .)
    LESSER          reduce using rule 131 (expr -> expr MINUS expr .)
    LESSER_EQ       reduce using rule 131 (expr -> expr MINUS expr .)
    GREATER         reduce using rule 131 (expr -> expr MINUS expr .)
    GREATER_EQ      reduce using rule 131 (expr -> expr MINUS expr .)
    COND_OP         reduce using rule 131 (expr -> expr MINUS expr .)
    SEMICOLON       reduce using rule 131 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 131 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 131 (expr -> expr MINUS expr .)
    AS              reduce using rule 131 (expr -> expr MINUS expr .)
    DOUBLE_ARROW    reduce using rule 131 (expr -> expr MINUS expr .)
    RBRACE          reduce using rule 131 (expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 131 (expr -> expr MINUS expr .)
    COLON           reduce using rule 131 (expr -> expr MINUS expr .)
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    INSTANCEOF      shift and go to state 117

  ! MULT            [ reduce using rule 131 (expr -> expr MINUS expr .) ]
  ! DIV             [ reduce using rule 131 (expr -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 131 (expr -> expr MINUS expr .) ]
  ! INSTANCEOF      [ reduce using rule 131 (expr -> expr MINUS expr .) ]
  ! DOT             [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 110 ]
  ! MINUS           [ shift and go to state 105 ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 185

    (129) expr -> expr DOT expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    DOT             reduce using rule 129 (expr -> expr DOT expr .)
    PLUS            reduce using rule 129 (expr -> expr DOT expr .)
    MINUS           reduce using rule 129 (expr -> expr DOT expr .)
    BIT_OR          reduce using rule 129 (expr -> expr DOT expr .)
    BIT_XOR         reduce using rule 129 (expr -> expr DOT expr .)
    BIT_AND         reduce using rule 129 (expr -> expr DOT expr .)
    BIT_LSHIFT      reduce using rule 129 (expr -> expr DOT expr .)
    BIT_RSHIFT      reduce using rule 129 (expr -> expr DOT expr .)
    AND_OP          reduce using rule 129 (expr -> expr DOT expr .)
    OR_OP           reduce using rule 129 (expr -> expr DOT expr .)
    IDENTICAL       reduce using rule 129 (expr -> expr DOT expr .)
    NOT_IDENTICAL   reduce using rule 129 (expr -> expr DOT expr .)
    EQ_EQ           reduce using rule 129 (expr -> expr DOT expr .)
    NOT_EQ          reduce using rule 129 (expr -> expr DOT expr .)
    LESSER          reduce using rule 129 (expr -> expr DOT expr .)
    LESSER_EQ       reduce using rule 129 (expr -> expr DOT expr .)
    GREATER         reduce using rule 129 (expr -> expr DOT expr .)
    GREATER_EQ      reduce using rule 129 (expr -> expr DOT expr .)
    COND_OP         reduce using rule 129 (expr -> expr DOT expr .)
    SEMICOLON       reduce using rule 129 (expr -> expr DOT expr .)
    COMMA           reduce using rule 129 (expr -> expr DOT expr .)
    RPAREN          reduce using rule 129 (expr -> expr DOT expr .)
    AS              reduce using rule 129 (expr -> expr DOT expr .)
    DOUBLE_ARROW    reduce using rule 129 (expr -> expr DOT expr .)
    RBRACE          reduce using rule 129 (expr -> expr DOT expr .)
    RBRACKET        reduce using rule 129 (expr -> expr DOT expr .)
    COLON           reduce using rule 129 (expr -> expr DOT expr .)
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    INSTANCEOF      shift and go to state 117

  ! MULT            [ reduce using rule 129 (expr -> expr DOT expr .) ]
  ! DIV             [ reduce using rule 129 (expr -> expr DOT expr .) ]
  ! MOD             [ reduce using rule 129 (expr -> expr DOT expr .) ]
  ! INSTANCEOF      [ reduce using rule 129 (expr -> expr DOT expr .) ]
  ! DOT             [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 110 ]
  ! MINUS           [ shift and go to state 105 ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 186

    (142) expr -> expr IDENTICAL expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 142 (expr -> expr IDENTICAL expr .)
    BIT_XOR         reduce using rule 142 (expr -> expr IDENTICAL expr .)
    BIT_AND         reduce using rule 142 (expr -> expr IDENTICAL expr .)
    AND_OP          reduce using rule 142 (expr -> expr IDENTICAL expr .)
    OR_OP           reduce using rule 142 (expr -> expr IDENTICAL expr .)
    IDENTICAL       reduce using rule 142 (expr -> expr IDENTICAL expr .)
    NOT_IDENTICAL   reduce using rule 142 (expr -> expr IDENTICAL expr .)
    EQ_EQ           reduce using rule 142 (expr -> expr IDENTICAL expr .)
    NOT_EQ          reduce using rule 142 (expr -> expr IDENTICAL expr .)
    COND_OP         reduce using rule 142 (expr -> expr IDENTICAL expr .)
    SEMICOLON       reduce using rule 142 (expr -> expr IDENTICAL expr .)
    COMMA           reduce using rule 142 (expr -> expr IDENTICAL expr .)
    RPAREN          reduce using rule 142 (expr -> expr IDENTICAL expr .)
    AS              reduce using rule 142 (expr -> expr IDENTICAL expr .)
    DOUBLE_ARROW    reduce using rule 142 (expr -> expr IDENTICAL expr .)
    RBRACE          reduce using rule 142 (expr -> expr IDENTICAL expr .)
    RBRACKET        reduce using rule 142 (expr -> expr IDENTICAL expr .)
    COLON           reduce using rule 142 (expr -> expr IDENTICAL expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! PLUS            [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! MINUS           [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! MULT            [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! DIV             [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! MOD             [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! LESSER          [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! LESSER_EQ       [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! GREATER         [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! GREATER_EQ      [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! INSTANCEOF      [ reduce using rule 142 (expr -> expr IDENTICAL expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! COND_OP         [ shift and go to state 119 ]


state 187

    (141) expr -> expr OR_OP jump_marker . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 260
    variable                       shift and go to state 53

state 188

    (130) expr -> expr PLUS expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    DOT             reduce using rule 130 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 130 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 130 (expr -> expr PLUS expr .)
    BIT_OR          reduce using rule 130 (expr -> expr PLUS expr .)
    BIT_XOR         reduce using rule 130 (expr -> expr PLUS expr .)
    BIT_AND         reduce using rule 130 (expr -> expr PLUS expr .)
    BIT_LSHIFT      reduce using rule 130 (expr -> expr PLUS expr .)
    BIT_RSHIFT      reduce using rule 130 (expr -> expr PLUS expr .)
    AND_OP          reduce using rule 130 (expr -> expr PLUS expr .)
    OR_OP           reduce using rule 130 (expr -> expr PLUS expr .)
    IDENTICAL       reduce using rule 130 (expr -> expr PLUS expr .)
    NOT_IDENTICAL   reduce using rule 130 (expr -> expr PLUS expr .)
    EQ_EQ           reduce using rule 130 (expr -> expr PLUS expr .)
    NOT_EQ          reduce using rule 130 (expr -> expr PLUS expr .)
    LESSER          reduce using rule 130 (expr -> expr PLUS expr .)
    LESSER_EQ       reduce using rule 130 (expr -> expr PLUS expr .)
    GREATER         reduce using rule 130 (expr -> expr PLUS expr .)
    GREATER_EQ      reduce using rule 130 (expr -> expr PLUS expr .)
    COND_OP         reduce using rule 130 (expr -> expr PLUS expr .)
    SEMICOLON       reduce using rule 130 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 130 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 130 (expr -> expr PLUS expr .)
    AS              reduce using rule 130 (expr -> expr PLUS expr .)
    DOUBLE_ARROW    reduce using rule 130 (expr -> expr PLUS expr .)
    RBRACE          reduce using rule 130 (expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 130 (expr -> expr PLUS expr .)
    COLON           reduce using rule 130 (expr -> expr PLUS expr .)
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    INSTANCEOF      shift and go to state 117

  ! MULT            [ reduce using rule 130 (expr -> expr PLUS expr .) ]
  ! DIV             [ reduce using rule 130 (expr -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 130 (expr -> expr PLUS expr .) ]
  ! INSTANCEOF      [ reduce using rule 130 (expr -> expr PLUS expr .) ]
  ! DOT             [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 110 ]
  ! MINUS           [ shift and go to state 105 ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 189

    (132) expr -> expr MULT expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    DOT             reduce using rule 132 (expr -> expr MULT expr .)
    PLUS            reduce using rule 132 (expr -> expr MULT expr .)
    MINUS           reduce using rule 132 (expr -> expr MULT expr .)
    MULT            reduce using rule 132 (expr -> expr MULT expr .)
    DIV             reduce using rule 132 (expr -> expr MULT expr .)
    MOD             reduce using rule 132 (expr -> expr MULT expr .)
    BIT_OR          reduce using rule 132 (expr -> expr MULT expr .)
    BIT_XOR         reduce using rule 132 (expr -> expr MULT expr .)
    BIT_AND         reduce using rule 132 (expr -> expr MULT expr .)
    BIT_LSHIFT      reduce using rule 132 (expr -> expr MULT expr .)
    BIT_RSHIFT      reduce using rule 132 (expr -> expr MULT expr .)
    AND_OP          reduce using rule 132 (expr -> expr MULT expr .)
    OR_OP           reduce using rule 132 (expr -> expr MULT expr .)
    IDENTICAL       reduce using rule 132 (expr -> expr MULT expr .)
    NOT_IDENTICAL   reduce using rule 132 (expr -> expr MULT expr .)
    EQ_EQ           reduce using rule 132 (expr -> expr MULT expr .)
    NOT_EQ          reduce using rule 132 (expr -> expr MULT expr .)
    LESSER          reduce using rule 132 (expr -> expr MULT expr .)
    LESSER_EQ       reduce using rule 132 (expr -> expr MULT expr .)
    GREATER         reduce using rule 132 (expr -> expr MULT expr .)
    GREATER_EQ      reduce using rule 132 (expr -> expr MULT expr .)
    COND_OP         reduce using rule 132 (expr -> expr MULT expr .)
    SEMICOLON       reduce using rule 132 (expr -> expr MULT expr .)
    COMMA           reduce using rule 132 (expr -> expr MULT expr .)
    RPAREN          reduce using rule 132 (expr -> expr MULT expr .)
    AS              reduce using rule 132 (expr -> expr MULT expr .)
    DOUBLE_ARROW    reduce using rule 132 (expr -> expr MULT expr .)
    RBRACE          reduce using rule 132 (expr -> expr MULT expr .)
    RBRACKET        reduce using rule 132 (expr -> expr MULT expr .)
    COLON           reduce using rule 132 (expr -> expr MULT expr .)
    INSTANCEOF      shift and go to state 117

  ! INSTANCEOF      [ reduce using rule 132 (expr -> expr MULT expr .) ]
  ! DOT             [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 110 ]
  ! MINUS           [ shift and go to state 105 ]
  ! MULT            [ shift and go to state 111 ]
  ! DIV             [ shift and go to state 103 ]
  ! MOD             [ shift and go to state 124 ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 190

    (145) expr -> expr NOT_EQ expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 145 (expr -> expr NOT_EQ expr .)
    BIT_XOR         reduce using rule 145 (expr -> expr NOT_EQ expr .)
    BIT_AND         reduce using rule 145 (expr -> expr NOT_EQ expr .)
    AND_OP          reduce using rule 145 (expr -> expr NOT_EQ expr .)
    OR_OP           reduce using rule 145 (expr -> expr NOT_EQ expr .)
    IDENTICAL       reduce using rule 145 (expr -> expr NOT_EQ expr .)
    NOT_IDENTICAL   reduce using rule 145 (expr -> expr NOT_EQ expr .)
    EQ_EQ           reduce using rule 145 (expr -> expr NOT_EQ expr .)
    NOT_EQ          reduce using rule 145 (expr -> expr NOT_EQ expr .)
    COND_OP         reduce using rule 145 (expr -> expr NOT_EQ expr .)
    SEMICOLON       reduce using rule 145 (expr -> expr NOT_EQ expr .)
    COMMA           reduce using rule 145 (expr -> expr NOT_EQ expr .)
    RPAREN          reduce using rule 145 (expr -> expr NOT_EQ expr .)
    AS              reduce using rule 145 (expr -> expr NOT_EQ expr .)
    DOUBLE_ARROW    reduce using rule 145 (expr -> expr NOT_EQ expr .)
    RBRACE          reduce using rule 145 (expr -> expr NOT_EQ expr .)
    RBRACKET        reduce using rule 145 (expr -> expr NOT_EQ expr .)
    COLON           reduce using rule 145 (expr -> expr NOT_EQ expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! PLUS            [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! MINUS           [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! MULT            [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! DIV             [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! MOD             [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! LESSER          [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! GREATER         [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 145 (expr -> expr NOT_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! COND_OP         [ shift and go to state 119 ]


state 191

    (143) expr -> expr NOT_IDENTICAL expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    BIT_XOR         reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    BIT_AND         reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    AND_OP          reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    OR_OP           reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    IDENTICAL       reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    NOT_IDENTICAL   reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    EQ_EQ           reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    NOT_EQ          reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    COND_OP         reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    SEMICOLON       reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    COMMA           reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    RPAREN          reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    AS              reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    DOUBLE_ARROW    reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    RBRACE          reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    RBRACKET        reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    COLON           reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! PLUS            [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! MINUS           [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! MULT            [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! DIV             [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! MOD             [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! LESSER          [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! LESSER_EQ       [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! GREATER         [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! GREATER_EQ      [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! INSTANCEOF      [ reduce using rule 143 (expr -> expr NOT_IDENTICAL expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! COND_OP         [ shift and go to state 119 ]


state 192

    (137) expr -> expr BIT_AND expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 137 (expr -> expr BIT_AND expr .)
    BIT_XOR         reduce using rule 137 (expr -> expr BIT_AND expr .)
    BIT_AND         reduce using rule 137 (expr -> expr BIT_AND expr .)
    SEMICOLON       reduce using rule 137 (expr -> expr BIT_AND expr .)
    COMMA           reduce using rule 137 (expr -> expr BIT_AND expr .)
    RPAREN          reduce using rule 137 (expr -> expr BIT_AND expr .)
    AS              reduce using rule 137 (expr -> expr BIT_AND expr .)
    DOUBLE_ARROW    reduce using rule 137 (expr -> expr BIT_AND expr .)
    RBRACE          reduce using rule 137 (expr -> expr BIT_AND expr .)
    RBRACKET        reduce using rule 137 (expr -> expr BIT_AND expr .)
    COLON           reduce using rule 137 (expr -> expr BIT_AND expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! PLUS            [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! MINUS           [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! MULT            [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! DIV             [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! MOD             [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! AND_OP          [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! OR_OP           [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! IDENTICAL       [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! EQ_EQ           [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! NOT_EQ          [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! LESSER          [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! LESSER_EQ       [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! GREATER         [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! GREATER_EQ      [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! INSTANCEOF      [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! COND_OP         [ reduce using rule 137 (expr -> expr BIT_AND expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]


state 193

    (147) expr -> expr LESSER_EQ expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    BIT_XOR         reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    BIT_AND         reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    AND_OP          reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    OR_OP           reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    IDENTICAL       reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    NOT_IDENTICAL   reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    EQ_EQ           reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    NOT_EQ          reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    LESSER          reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    LESSER_EQ       reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    GREATER         reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    GREATER_EQ      reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    COND_OP         reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    SEMICOLON       reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    COMMA           reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    RPAREN          reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    AS              reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    DOUBLE_ARROW    reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    RBRACE          reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    RBRACKET        reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    COLON           reduce using rule 147 (expr -> expr LESSER_EQ expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 147 (expr -> expr LESSER_EQ expr .) ]
  ! PLUS            [ reduce using rule 147 (expr -> expr LESSER_EQ expr .) ]
  ! MINUS           [ reduce using rule 147 (expr -> expr LESSER_EQ expr .) ]
  ! MULT            [ reduce using rule 147 (expr -> expr LESSER_EQ expr .) ]
  ! DIV             [ reduce using rule 147 (expr -> expr LESSER_EQ expr .) ]
  ! MOD             [ reduce using rule 147 (expr -> expr LESSER_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 147 (expr -> expr LESSER_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 147 (expr -> expr LESSER_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 147 (expr -> expr LESSER_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 194

    (140) expr -> expr AND_OP jump_marker . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 261
    variable                       shift and go to state 53

state 195

    (150) expr -> expr INSTANCEOF expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    DOT             reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    PLUS            reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    MINUS           reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    MULT            reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    DIV             reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    MOD             reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    BIT_OR          reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    BIT_XOR         reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    BIT_AND         reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    BIT_LSHIFT      reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    BIT_RSHIFT      reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    AND_OP          reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    OR_OP           reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    IDENTICAL       reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    NOT_IDENTICAL   reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    EQ_EQ           reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    NOT_EQ          reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    LESSER          reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    LESSER_EQ       reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    GREATER         reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    GREATER_EQ      reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    INSTANCEOF      reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    COND_OP         reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    SEMICOLON       reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    COMMA           reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    RPAREN          reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    AS              reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    DOUBLE_ARROW    reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    RBRACE          reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    RBRACKET        reduce using rule 150 (expr -> expr INSTANCEOF expr .)
    COLON           reduce using rule 150 (expr -> expr INSTANCEOF expr .)

  ! DOT             [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 110 ]
  ! MINUS           [ shift and go to state 105 ]
  ! MULT            [ shift and go to state 111 ]
  ! DIV             [ shift and go to state 103 ]
  ! MOD             [ shift and go to state 124 ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! INSTANCEOF      [ shift and go to state 117 ]
  ! COND_OP         [ shift and go to state 119 ]


state 196

    (148) expr -> expr GREATER expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 148 (expr -> expr GREATER expr .)
    BIT_XOR         reduce using rule 148 (expr -> expr GREATER expr .)
    BIT_AND         reduce using rule 148 (expr -> expr GREATER expr .)
    AND_OP          reduce using rule 148 (expr -> expr GREATER expr .)
    OR_OP           reduce using rule 148 (expr -> expr GREATER expr .)
    IDENTICAL       reduce using rule 148 (expr -> expr GREATER expr .)
    NOT_IDENTICAL   reduce using rule 148 (expr -> expr GREATER expr .)
    EQ_EQ           reduce using rule 148 (expr -> expr GREATER expr .)
    NOT_EQ          reduce using rule 148 (expr -> expr GREATER expr .)
    LESSER          reduce using rule 148 (expr -> expr GREATER expr .)
    LESSER_EQ       reduce using rule 148 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 148 (expr -> expr GREATER expr .)
    GREATER_EQ      reduce using rule 148 (expr -> expr GREATER expr .)
    COND_OP         reduce using rule 148 (expr -> expr GREATER expr .)
    SEMICOLON       reduce using rule 148 (expr -> expr GREATER expr .)
    COMMA           reduce using rule 148 (expr -> expr GREATER expr .)
    RPAREN          reduce using rule 148 (expr -> expr GREATER expr .)
    AS              reduce using rule 148 (expr -> expr GREATER expr .)
    DOUBLE_ARROW    reduce using rule 148 (expr -> expr GREATER expr .)
    RBRACE          reduce using rule 148 (expr -> expr GREATER expr .)
    RBRACKET        reduce using rule 148 (expr -> expr GREATER expr .)
    COLON           reduce using rule 148 (expr -> expr GREATER expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 148 (expr -> expr GREATER expr .) ]
  ! PLUS            [ reduce using rule 148 (expr -> expr GREATER expr .) ]
  ! MINUS           [ reduce using rule 148 (expr -> expr GREATER expr .) ]
  ! MULT            [ reduce using rule 148 (expr -> expr GREATER expr .) ]
  ! DIV             [ reduce using rule 148 (expr -> expr GREATER expr .) ]
  ! MOD             [ reduce using rule 148 (expr -> expr GREATER expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 148 (expr -> expr GREATER expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 148 (expr -> expr GREATER expr .) ]
  ! INSTANCEOF      [ reduce using rule 148 (expr -> expr GREATER expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 197

    (161) expr -> expr COND_OP jump_marker . expr goto_marker jump_marker COLON expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 262
    variable                       shift and go to state 53

state 198

    (139) expr -> expr BIT_RSHIFT expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    BIT_XOR         reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    BIT_AND         reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    BIT_LSHIFT      reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    BIT_RSHIFT      reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    AND_OP          reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    OR_OP           reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    IDENTICAL       reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    NOT_IDENTICAL   reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    EQ_EQ           reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    NOT_EQ          reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    LESSER          reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    LESSER_EQ       reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    GREATER         reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    GREATER_EQ      reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    COND_OP         reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    SEMICOLON       reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    COMMA           reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    RPAREN          reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    AS              reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    DOUBLE_ARROW    reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    RBRACE          reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    RBRACKET        reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    COLON           reduce using rule 139 (expr -> expr BIT_RSHIFT expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 139 (expr -> expr BIT_RSHIFT expr .) ]
  ! PLUS            [ reduce using rule 139 (expr -> expr BIT_RSHIFT expr .) ]
  ! MINUS           [ reduce using rule 139 (expr -> expr BIT_RSHIFT expr .) ]
  ! MULT            [ reduce using rule 139 (expr -> expr BIT_RSHIFT expr .) ]
  ! DIV             [ reduce using rule 139 (expr -> expr BIT_RSHIFT expr .) ]
  ! MOD             [ reduce using rule 139 (expr -> expr BIT_RSHIFT expr .) ]
  ! INSTANCEOF      [ reduce using rule 139 (expr -> expr BIT_RSHIFT expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 199

    (135) expr -> expr BIT_OR expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 135 (expr -> expr BIT_OR expr .)
    SEMICOLON       reduce using rule 135 (expr -> expr BIT_OR expr .)
    COMMA           reduce using rule 135 (expr -> expr BIT_OR expr .)
    RPAREN          reduce using rule 135 (expr -> expr BIT_OR expr .)
    AS              reduce using rule 135 (expr -> expr BIT_OR expr .)
    DOUBLE_ARROW    reduce using rule 135 (expr -> expr BIT_OR expr .)
    RBRACE          reduce using rule 135 (expr -> expr BIT_OR expr .)
    RBRACKET        reduce using rule 135 (expr -> expr BIT_OR expr .)
    COLON           reduce using rule 135 (expr -> expr BIT_OR expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! PLUS            [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! MINUS           [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! MULT            [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! DIV             [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! MOD             [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! BIT_XOR         [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! BIT_AND         [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! AND_OP          [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! OR_OP           [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! IDENTICAL       [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! EQ_EQ           [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! NOT_EQ          [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! LESSER          [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! LESSER_EQ       [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! GREATER         [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! GREATER_EQ      [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! INSTANCEOF      [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! COND_OP         [ reduce using rule 135 (expr -> expr BIT_OR expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]


state 200

    (146) expr -> expr LESSER expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 146 (expr -> expr LESSER expr .)
    BIT_XOR         reduce using rule 146 (expr -> expr LESSER expr .)
    BIT_AND         reduce using rule 146 (expr -> expr LESSER expr .)
    AND_OP          reduce using rule 146 (expr -> expr LESSER expr .)
    OR_OP           reduce using rule 146 (expr -> expr LESSER expr .)
    IDENTICAL       reduce using rule 146 (expr -> expr LESSER expr .)
    NOT_IDENTICAL   reduce using rule 146 (expr -> expr LESSER expr .)
    EQ_EQ           reduce using rule 146 (expr -> expr LESSER expr .)
    NOT_EQ          reduce using rule 146 (expr -> expr LESSER expr .)
    LESSER          reduce using rule 146 (expr -> expr LESSER expr .)
    LESSER_EQ       reduce using rule 146 (expr -> expr LESSER expr .)
    GREATER         reduce using rule 146 (expr -> expr LESSER expr .)
    GREATER_EQ      reduce using rule 146 (expr -> expr LESSER expr .)
    COND_OP         reduce using rule 146 (expr -> expr LESSER expr .)
    SEMICOLON       reduce using rule 146 (expr -> expr LESSER expr .)
    COMMA           reduce using rule 146 (expr -> expr LESSER expr .)
    RPAREN          reduce using rule 146 (expr -> expr LESSER expr .)
    AS              reduce using rule 146 (expr -> expr LESSER expr .)
    DOUBLE_ARROW    reduce using rule 146 (expr -> expr LESSER expr .)
    RBRACE          reduce using rule 146 (expr -> expr LESSER expr .)
    RBRACKET        reduce using rule 146 (expr -> expr LESSER expr .)
    COLON           reduce using rule 146 (expr -> expr LESSER expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 146 (expr -> expr LESSER expr .) ]
  ! PLUS            [ reduce using rule 146 (expr -> expr LESSER expr .) ]
  ! MINUS           [ reduce using rule 146 (expr -> expr LESSER expr .) ]
  ! MULT            [ reduce using rule 146 (expr -> expr LESSER expr .) ]
  ! DIV             [ reduce using rule 146 (expr -> expr LESSER expr .) ]
  ! MOD             [ reduce using rule 146 (expr -> expr LESSER expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 146 (expr -> expr LESSER expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 146 (expr -> expr LESSER expr .) ]
  ! INSTANCEOF      [ reduce using rule 146 (expr -> expr LESSER expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 201

    (138) expr -> expr BIT_LSHIFT expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    BIT_XOR         reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    BIT_AND         reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    BIT_LSHIFT      reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    BIT_RSHIFT      reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    AND_OP          reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    OR_OP           reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    IDENTICAL       reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    NOT_IDENTICAL   reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    EQ_EQ           reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    NOT_EQ          reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    LESSER          reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    LESSER_EQ       reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    GREATER         reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    GREATER_EQ      reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    COND_OP         reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    SEMICOLON       reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    COMMA           reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    RPAREN          reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    AS              reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    DOUBLE_ARROW    reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    RBRACE          reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    RBRACKET        reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    COLON           reduce using rule 138 (expr -> expr BIT_LSHIFT expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 138 (expr -> expr BIT_LSHIFT expr .) ]
  ! PLUS            [ reduce using rule 138 (expr -> expr BIT_LSHIFT expr .) ]
  ! MINUS           [ reduce using rule 138 (expr -> expr BIT_LSHIFT expr .) ]
  ! MULT            [ reduce using rule 138 (expr -> expr BIT_LSHIFT expr .) ]
  ! DIV             [ reduce using rule 138 (expr -> expr BIT_LSHIFT expr .) ]
  ! MOD             [ reduce using rule 138 (expr -> expr BIT_LSHIFT expr .) ]
  ! INSTANCEOF      [ reduce using rule 138 (expr -> expr BIT_LSHIFT expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 202

    (134) expr -> expr MOD expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    DOT             reduce using rule 134 (expr -> expr MOD expr .)
    PLUS            reduce using rule 134 (expr -> expr MOD expr .)
    MINUS           reduce using rule 134 (expr -> expr MOD expr .)
    MULT            reduce using rule 134 (expr -> expr MOD expr .)
    DIV             reduce using rule 134 (expr -> expr MOD expr .)
    MOD             reduce using rule 134 (expr -> expr MOD expr .)
    BIT_OR          reduce using rule 134 (expr -> expr MOD expr .)
    BIT_XOR         reduce using rule 134 (expr -> expr MOD expr .)
    BIT_AND         reduce using rule 134 (expr -> expr MOD expr .)
    BIT_LSHIFT      reduce using rule 134 (expr -> expr MOD expr .)
    BIT_RSHIFT      reduce using rule 134 (expr -> expr MOD expr .)
    AND_OP          reduce using rule 134 (expr -> expr MOD expr .)
    OR_OP           reduce using rule 134 (expr -> expr MOD expr .)
    IDENTICAL       reduce using rule 134 (expr -> expr MOD expr .)
    NOT_IDENTICAL   reduce using rule 134 (expr -> expr MOD expr .)
    EQ_EQ           reduce using rule 134 (expr -> expr MOD expr .)
    NOT_EQ          reduce using rule 134 (expr -> expr MOD expr .)
    LESSER          reduce using rule 134 (expr -> expr MOD expr .)
    LESSER_EQ       reduce using rule 134 (expr -> expr MOD expr .)
    GREATER         reduce using rule 134 (expr -> expr MOD expr .)
    GREATER_EQ      reduce using rule 134 (expr -> expr MOD expr .)
    COND_OP         reduce using rule 134 (expr -> expr MOD expr .)
    SEMICOLON       reduce using rule 134 (expr -> expr MOD expr .)
    COMMA           reduce using rule 134 (expr -> expr MOD expr .)
    RPAREN          reduce using rule 134 (expr -> expr MOD expr .)
    AS              reduce using rule 134 (expr -> expr MOD expr .)
    DOUBLE_ARROW    reduce using rule 134 (expr -> expr MOD expr .)
    RBRACE          reduce using rule 134 (expr -> expr MOD expr .)
    RBRACKET        reduce using rule 134 (expr -> expr MOD expr .)
    COLON           reduce using rule 134 (expr -> expr MOD expr .)
    INSTANCEOF      shift and go to state 117

  ! INSTANCEOF      [ reduce using rule 134 (expr -> expr MOD expr .) ]
  ! DOT             [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 110 ]
  ! MINUS           [ shift and go to state 105 ]
  ! MULT            [ shift and go to state 111 ]
  ! DIV             [ shift and go to state 103 ]
  ! MOD             [ shift and go to state 124 ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! BIT_LSHIFT      [ shift and go to state 123 ]
  ! BIT_RSHIFT      [ shift and go to state 120 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! IDENTICAL       [ shift and go to state 107 ]
  ! NOT_IDENTICAL   [ shift and go to state 113 ]
  ! EQ_EQ           [ shift and go to state 101 ]
  ! NOT_EQ          [ shift and go to state 112 ]
  ! LESSER          [ shift and go to state 122 ]
  ! LESSER_EQ       [ shift and go to state 115 ]
  ! GREATER         [ shift and go to state 118 ]
  ! GREATER_EQ      [ shift and go to state 102 ]
  ! COND_OP         [ shift and go to state 119 ]


state 203

    (54) stmt -> BREAK goto_marker SEMICOLON .

    WHILE           reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    DO              reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    FOR             reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    FOREACH         reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    SWITCH          reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    BREAK           reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    CONTINUE        reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    RETURN          reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    GLOBAL          reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    STATIC          reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    ECHO            reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    LBRACE          reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    SEMICOLON       reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    FUNCTION        reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    CLONE           reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    ARRAY           reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    PLUS            reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    MINUS           reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    BIT_NOT         reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    NOT             reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    CONST_DECIMAL   reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    CONST_DOUBLE    reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    CONST_STRING    reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    NULL            reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    TRUE            reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    FALSE           reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    INC             reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    DEC             reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    EMPTY           reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    EVAL            reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    LPAREN          reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    INCLUDE         reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    REQUIRE         reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    EXIT            reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    PRINT           reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    IF              reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    IDENTIFIER      reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    STRING          reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    $end            reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    RBRACE          reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    ENDIF           reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    ELSE            reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    ELSEIF          reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    ENDWHILE        reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    ENDFOREACH      reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    CASE            reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    DEFAULT         reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    ENDSWITCH       reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)
    ENDFOR          reduce using rule 54 (stmt -> BREAK goto_marker SEMICOLON .)



state 204

    (55) stmt -> BREAK expr goto_marker . SEMICOLON

    SEMICOLON       shift and go to state 263



state 205

    (174) expr -> EXIT LPAREN RPAREN .

    DOT             reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    PLUS            reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    MINUS           reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    MULT            reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    DIV             reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    MOD             reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    BIT_OR          reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    BIT_XOR         reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    BIT_AND         reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    BIT_LSHIFT      reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    BIT_RSHIFT      reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    AND_OP          reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    OR_OP           reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    IDENTICAL       reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    NOT_IDENTICAL   reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    EQ_EQ           reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    NOT_EQ          reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    LESSER          reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    LESSER_EQ       reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    GREATER         reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    GREATER_EQ      reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    INSTANCEOF      reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    COND_OP         reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    SEMICOLON       reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    COMMA           reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    RPAREN          reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    AS              reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    DOUBLE_ARROW    reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    RBRACE          reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    RBRACKET        reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)
    COLON           reduce using rule 174 (expr -> EXIT LPAREN RPAREN .)



state 206

    (175) expr -> EXIT LPAREN expr . RPAREN
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    RPAREN          shift and go to state 264
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 207

    (29) stmt -> DO stmt WHILE . LPAREN expr RPAREN SEMICOLON

    LPAREN          shift and go to state 265



state 208

    (81) func_call -> STRING LPAREN func_params . RPAREN
    (82) func_params -> func_params . COMMA func_param

    RPAREN          shift and go to state 266
    COMMA           shift and go to state 267



state 209

    (84) func_params -> empty .

    RPAREN          reduce using rule 84 (func_params -> empty .)
    COMMA           reduce using rule 84 (func_params -> empty .)



state 210

    (83) func_params -> func_param .

    RPAREN          reduce using rule 83 (func_params -> func_param .)
    COMMA           reduce using rule 83 (func_params -> func_param .)



state 211

    (86) func_param -> BIT_AND . variable
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    base_var                       shift and go to state 76
    func_call                      shift and go to state 40
    variable                       shift and go to state 268

state 212

    (85) func_param -> expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    RPAREN          reduce using rule 85 (func_param -> expr .)
    COMMA           reduce using rule 85 (func_param -> expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 213

    (168) expr -> LPAREN expr RPAREN .

    DOT             reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    MULT            reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    DIV             reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    BIT_OR          reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    BIT_XOR         reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    BIT_AND         reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    BIT_LSHIFT      reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    BIT_RSHIFT      reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    AND_OP          reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    OR_OP           reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    IDENTICAL       reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    NOT_IDENTICAL   reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    EQ_EQ           reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    LESSER          reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    LESSER_EQ       reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    INSTANCEOF      reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    COND_OP         reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    AS              reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    DOUBLE_ARROW    reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 168 (expr -> LPAREN expr RPAREN .)
    COLON           reduce using rule 168 (expr -> LPAREN expr RPAREN .)



state 214

    (127) expr -> variable DOT_EQ expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 127 (expr -> variable DOT_EQ expr .)
    BIT_XOR         reduce using rule 127 (expr -> variable DOT_EQ expr .)
    BIT_AND         reduce using rule 127 (expr -> variable DOT_EQ expr .)
    SEMICOLON       reduce using rule 127 (expr -> variable DOT_EQ expr .)
    COMMA           reduce using rule 127 (expr -> variable DOT_EQ expr .)
    RPAREN          reduce using rule 127 (expr -> variable DOT_EQ expr .)
    AS              reduce using rule 127 (expr -> variable DOT_EQ expr .)
    DOUBLE_ARROW    reduce using rule 127 (expr -> variable DOT_EQ expr .)
    RBRACE          reduce using rule 127 (expr -> variable DOT_EQ expr .)
    RBRACKET        reduce using rule 127 (expr -> variable DOT_EQ expr .)
    COLON           reduce using rule 127 (expr -> variable DOT_EQ expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! PLUS            [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! MINUS           [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! MULT            [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! DIV             [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! MOD             [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! AND_OP          [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! OR_OP           [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! LESSER          [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! GREATER         [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! COND_OP         [ reduce using rule 127 (expr -> variable DOT_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]


state 215

    (125) expr -> variable MULTIPLY_EQ expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .)
    BIT_XOR         reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .)
    BIT_AND         reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .)
    SEMICOLON       reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .)
    COMMA           reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .)
    RPAREN          reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .)
    AS              reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .)
    DOUBLE_ARROW    reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .)
    RBRACE          reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .)
    RBRACKET        reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .)
    COLON           reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! PLUS            [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! MINUS           [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! MULT            [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! DIV             [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! MOD             [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! AND_OP          [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! OR_OP           [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! LESSER          [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! GREATER         [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! COND_OP         [ reduce using rule 125 (expr -> variable MULTIPLY_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]


state 216

    (126) expr -> variable DIVIDE_EQ expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 126 (expr -> variable DIVIDE_EQ expr .)
    BIT_XOR         reduce using rule 126 (expr -> variable DIVIDE_EQ expr .)
    BIT_AND         reduce using rule 126 (expr -> variable DIVIDE_EQ expr .)
    SEMICOLON       reduce using rule 126 (expr -> variable DIVIDE_EQ expr .)
    COMMA           reduce using rule 126 (expr -> variable DIVIDE_EQ expr .)
    RPAREN          reduce using rule 126 (expr -> variable DIVIDE_EQ expr .)
    AS              reduce using rule 126 (expr -> variable DIVIDE_EQ expr .)
    DOUBLE_ARROW    reduce using rule 126 (expr -> variable DIVIDE_EQ expr .)
    RBRACE          reduce using rule 126 (expr -> variable DIVIDE_EQ expr .)
    RBRACKET        reduce using rule 126 (expr -> variable DIVIDE_EQ expr .)
    COLON           reduce using rule 126 (expr -> variable DIVIDE_EQ expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! PLUS            [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! MINUS           [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! MULT            [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! DIV             [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! MOD             [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! AND_OP          [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! OR_OP           [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! LESSER          [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! GREATER         [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! COND_OP         [ reduce using rule 126 (expr -> variable DIVIDE_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]


state 217

    (123) expr -> variable PLUS_EQ expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 123 (expr -> variable PLUS_EQ expr .)
    BIT_XOR         reduce using rule 123 (expr -> variable PLUS_EQ expr .)
    BIT_AND         reduce using rule 123 (expr -> variable PLUS_EQ expr .)
    SEMICOLON       reduce using rule 123 (expr -> variable PLUS_EQ expr .)
    COMMA           reduce using rule 123 (expr -> variable PLUS_EQ expr .)
    RPAREN          reduce using rule 123 (expr -> variable PLUS_EQ expr .)
    AS              reduce using rule 123 (expr -> variable PLUS_EQ expr .)
    DOUBLE_ARROW    reduce using rule 123 (expr -> variable PLUS_EQ expr .)
    RBRACE          reduce using rule 123 (expr -> variable PLUS_EQ expr .)
    RBRACKET        reduce using rule 123 (expr -> variable PLUS_EQ expr .)
    COLON           reduce using rule 123 (expr -> variable PLUS_EQ expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! PLUS            [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! MINUS           [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! MULT            [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! DIV             [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! MOD             [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! AND_OP          [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! OR_OP           [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! LESSER          [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! GREATER         [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! COND_OP         [ reduce using rule 123 (expr -> variable PLUS_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]


state 218

    (124) expr -> variable MINUS_EQ expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 124 (expr -> variable MINUS_EQ expr .)
    BIT_XOR         reduce using rule 124 (expr -> variable MINUS_EQ expr .)
    BIT_AND         reduce using rule 124 (expr -> variable MINUS_EQ expr .)
    SEMICOLON       reduce using rule 124 (expr -> variable MINUS_EQ expr .)
    COMMA           reduce using rule 124 (expr -> variable MINUS_EQ expr .)
    RPAREN          reduce using rule 124 (expr -> variable MINUS_EQ expr .)
    AS              reduce using rule 124 (expr -> variable MINUS_EQ expr .)
    DOUBLE_ARROW    reduce using rule 124 (expr -> variable MINUS_EQ expr .)
    RBRACE          reduce using rule 124 (expr -> variable MINUS_EQ expr .)
    RBRACKET        reduce using rule 124 (expr -> variable MINUS_EQ expr .)
    COLON           reduce using rule 124 (expr -> variable MINUS_EQ expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! PLUS            [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! MINUS           [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! MULT            [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! DIV             [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! MOD             [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! AND_OP          [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! OR_OP           [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! LESSER          [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! GREATER         [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! COND_OP         [ reduce using rule 124 (expr -> variable MINUS_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]


state 219

    (128) expr -> variable MOD_EQ expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 128 (expr -> variable MOD_EQ expr .)
    BIT_XOR         reduce using rule 128 (expr -> variable MOD_EQ expr .)
    BIT_AND         reduce using rule 128 (expr -> variable MOD_EQ expr .)
    SEMICOLON       reduce using rule 128 (expr -> variable MOD_EQ expr .)
    COMMA           reduce using rule 128 (expr -> variable MOD_EQ expr .)
    RPAREN          reduce using rule 128 (expr -> variable MOD_EQ expr .)
    AS              reduce using rule 128 (expr -> variable MOD_EQ expr .)
    DOUBLE_ARROW    reduce using rule 128 (expr -> variable MOD_EQ expr .)
    RBRACE          reduce using rule 128 (expr -> variable MOD_EQ expr .)
    RBRACKET        reduce using rule 128 (expr -> variable MOD_EQ expr .)
    COLON           reduce using rule 128 (expr -> variable MOD_EQ expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! PLUS            [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! MINUS           [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! MULT            [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! DIV             [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! MOD             [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! AND_OP          [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! OR_OP           [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! IDENTICAL       [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! EQ_EQ           [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! LESSER          [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! LESSER_EQ       [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! GREATER         [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! GREATER_EQ      [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! INSTANCEOF      [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! COND_OP         [ reduce using rule 128 (expr -> variable MOD_EQ expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]


state 220

    (20) if_stmt_without_else -> IF LPAREN expr . RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> IF LPAREN expr . RPAREN COLON jump_marker inner_stmts
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    RPAREN          shift and go to state 269
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 221

    (23) alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker . COLON inner_stmts ENDIF SEMICOLON

    COLON           shift and go to state 270



state 222

    (25) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF goto_marker LPAREN . jump_marker expr RPAREN COLON jump_marker inner_stmts
    (177) jump_marker -> . empty
    (179) empty -> .

    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 271
    empty                          shift and go to state 68

state 223

    (37) stmt -> FOREACH LPAREN expr AS . foreach_var foreach_arg RPAREN foreach_stmt
    (38) foreach_var -> . IDENTIFIER
    (39) foreach_var -> . BIT_AND IDENTIFIER

    IDENTIFIER      shift and go to state 274
    BIT_AND         shift and go to state 272


    foreach_var                    shift and go to state 273

state 224

    (167) expr -> EVAL LPAREN expr RPAREN .

    DOT             reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    PLUS            reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    MINUS           reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    MULT            reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    DIV             reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    MOD             reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_OR          reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_XOR         reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_AND         reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_LSHIFT      reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    BIT_RSHIFT      reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    AND_OP          reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    OR_OP           reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    IDENTICAL       reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    NOT_IDENTICAL   reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    EQ_EQ           reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    LESSER          reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    LESSER_EQ       reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    GREATER         reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    INSTANCEOF      reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    COND_OP         reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    COMMA           reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    RPAREN          reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    AS              reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    DOUBLE_ARROW    reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    RBRACE          reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)
    COLON           reduce using rule 167 (expr -> EVAL LPAREN expr RPAREN .)



state 225

    (64) static_var_list -> static_var_list COMMA static_var .

    SEMICOLON       reduce using rule 64 (static_var_list -> static_var_list COMMA static_var .)
    COMMA           reduce using rule 64 (static_var_list -> static_var_list COMMA static_var .)



state 226

    (98) scalar -> NULL .

    DOUBLE_ARROW    reduce using rule 98 (scalar -> NULL .)
    COMMA           reduce using rule 98 (scalar -> NULL .)
    RPAREN          reduce using rule 98 (scalar -> NULL .)
    SEMICOLON       reduce using rule 98 (scalar -> NULL .)



state 227

    (100) scalar -> FALSE .

    DOUBLE_ARROW    reduce using rule 100 (scalar -> FALSE .)
    COMMA           reduce using rule 100 (scalar -> FALSE .)
    RPAREN          reduce using rule 100 (scalar -> FALSE .)
    SEMICOLON       reduce using rule 100 (scalar -> FALSE .)



state 228

    (97) scalar -> CONST_STRING .

    DOUBLE_ARROW    reduce using rule 97 (scalar -> CONST_STRING .)
    COMMA           reduce using rule 97 (scalar -> CONST_STRING .)
    RPAREN          reduce using rule 97 (scalar -> CONST_STRING .)
    SEMICOLON       reduce using rule 97 (scalar -> CONST_STRING .)



state 229

    (95) scalar -> CONST_DECIMAL .

    DOUBLE_ARROW    reduce using rule 95 (scalar -> CONST_DECIMAL .)
    COMMA           reduce using rule 95 (scalar -> CONST_DECIMAL .)
    RPAREN          reduce using rule 95 (scalar -> CONST_DECIMAL .)
    SEMICOLON       reduce using rule 95 (scalar -> CONST_DECIMAL .)



state 230

    (96) scalar -> CONST_DOUBLE .

    DOUBLE_ARROW    reduce using rule 96 (scalar -> CONST_DOUBLE .)
    COMMA           reduce using rule 96 (scalar -> CONST_DOUBLE .)
    RPAREN          reduce using rule 96 (scalar -> CONST_DOUBLE .)
    SEMICOLON       reduce using rule 96 (scalar -> CONST_DOUBLE .)



state 231

    (66) static_var -> IDENTIFIER EQUAL scalar .

    SEMICOLON       reduce using rule 66 (static_var -> IDENTIFIER EQUAL scalar .)
    COMMA           reduce using rule 66 (static_var -> IDENTIFIER EQUAL scalar .)



state 232

    (101) scalar -> PLUS . scalar
    (95) scalar -> . CONST_DECIMAL
    (96) scalar -> . CONST_DOUBLE
    (97) scalar -> . CONST_STRING
    (98) scalar -> . NULL
    (99) scalar -> . TRUE
    (100) scalar -> . FALSE
    (101) scalar -> . PLUS scalar
    (102) scalar -> . MINUS scalar
    (103) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 229
    CONST_DOUBLE    shift and go to state 230
    CONST_STRING    shift and go to state 228
    NULL            shift and go to state 226
    TRUE            shift and go to state 234
    FALSE           shift and go to state 227
    PLUS            shift and go to state 232
    MINUS           shift and go to state 235
    ARRAY           shift and go to state 233


    scalar                         shift and go to state 275

state 233

    (103) scalar -> ARRAY . LPAREN scalar_array_pair_list RPAREN

    LPAREN          shift and go to state 276



state 234

    (99) scalar -> TRUE .

    DOUBLE_ARROW    reduce using rule 99 (scalar -> TRUE .)
    COMMA           reduce using rule 99 (scalar -> TRUE .)
    RPAREN          reduce using rule 99 (scalar -> TRUE .)
    SEMICOLON       reduce using rule 99 (scalar -> TRUE .)



state 235

    (102) scalar -> MINUS . scalar
    (95) scalar -> . CONST_DECIMAL
    (96) scalar -> . CONST_DOUBLE
    (97) scalar -> . CONST_STRING
    (98) scalar -> . NULL
    (99) scalar -> . TRUE
    (100) scalar -> . FALSE
    (101) scalar -> . PLUS scalar
    (102) scalar -> . MINUS scalar
    (103) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 229
    CONST_DOUBLE    shift and go to state 230
    CONST_STRING    shift and go to state 228
    NULL            shift and go to state 226
    TRUE            shift and go to state 234
    FALSE           shift and go to state 227
    PLUS            shift and go to state 232
    MINUS           shift and go to state 235
    ARRAY           shift and go to state 233


    scalar                         shift and go to state 277

state 236

    (166) expr -> EMPTY LPAREN expr RPAREN .

    DOT             reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    PLUS            reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    MINUS           reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    MULT            reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    DIV             reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    MOD             reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_OR          reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_XOR         reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_AND         reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_LSHIFT      reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    BIT_RSHIFT      reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    AND_OP          reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    OR_OP           reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    IDENTICAL       reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    NOT_IDENTICAL   reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    EQ_EQ           reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    LESSER          reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    LESSER_EQ       reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    GREATER         reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    INSTANCEOF      reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    COND_OP         reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    COMMA           reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    RPAREN          reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    AS              reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    DOUBLE_ARROW    reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    RBRACE          reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)
    COLON           reduce using rule 166 (expr -> EMPTY LPAREN expr RPAREN .)



state 237

    (7) func_decl -> FUNCTION goto_marker STRING func_table_marker . LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker

    LPAREN          shift and go to state 278



state 238

    (8) func_table_marker -> empty .

    LPAREN          reduce using rule 8 (func_table_marker -> empty .)



state 239

    (33) non_empty_for_expr -> non_empty_for_expr COMMA . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 279
    variable                       shift and go to state 53

state 240

    (30) stmt -> FOR LPAREN for_expr SEMICOLON . jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (177) jump_marker -> . empty
    (179) empty -> .

    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 280
    empty                          shift and go to state 68

state 241

    (69) echo_expr_list -> echo_expr_list COMMA expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    SEMICOLON       reduce using rule 69 (echo_expr_list -> echo_expr_list COMMA expr .)
    COMMA           reduce using rule 69 (echo_expr_list -> echo_expr_list COMMA expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 242

    (76) inner_stmt -> stmt .

    RBRACE          reduce using rule 76 (inner_stmt -> stmt .)
    WHILE           reduce using rule 76 (inner_stmt -> stmt .)
    DO              reduce using rule 76 (inner_stmt -> stmt .)
    FOR             reduce using rule 76 (inner_stmt -> stmt .)
    FOREACH         reduce using rule 76 (inner_stmt -> stmt .)
    SWITCH          reduce using rule 76 (inner_stmt -> stmt .)
    BREAK           reduce using rule 76 (inner_stmt -> stmt .)
    CONTINUE        reduce using rule 76 (inner_stmt -> stmt .)
    RETURN          reduce using rule 76 (inner_stmt -> stmt .)
    GLOBAL          reduce using rule 76 (inner_stmt -> stmt .)
    STATIC          reduce using rule 76 (inner_stmt -> stmt .)
    ECHO            reduce using rule 76 (inner_stmt -> stmt .)
    LBRACE          reduce using rule 76 (inner_stmt -> stmt .)
    SEMICOLON       reduce using rule 76 (inner_stmt -> stmt .)
    FUNCTION        reduce using rule 76 (inner_stmt -> stmt .)
    CLONE           reduce using rule 76 (inner_stmt -> stmt .)
    ARRAY           reduce using rule 76 (inner_stmt -> stmt .)
    PLUS            reduce using rule 76 (inner_stmt -> stmt .)
    MINUS           reduce using rule 76 (inner_stmt -> stmt .)
    BIT_NOT         reduce using rule 76 (inner_stmt -> stmt .)
    NOT             reduce using rule 76 (inner_stmt -> stmt .)
    CONST_DECIMAL   reduce using rule 76 (inner_stmt -> stmt .)
    CONST_DOUBLE    reduce using rule 76 (inner_stmt -> stmt .)
    CONST_STRING    reduce using rule 76 (inner_stmt -> stmt .)
    NULL            reduce using rule 76 (inner_stmt -> stmt .)
    TRUE            reduce using rule 76 (inner_stmt -> stmt .)
    FALSE           reduce using rule 76 (inner_stmt -> stmt .)
    INC             reduce using rule 76 (inner_stmt -> stmt .)
    DEC             reduce using rule 76 (inner_stmt -> stmt .)
    EMPTY           reduce using rule 76 (inner_stmt -> stmt .)
    EVAL            reduce using rule 76 (inner_stmt -> stmt .)
    LPAREN          reduce using rule 76 (inner_stmt -> stmt .)
    INCLUDE         reduce using rule 76 (inner_stmt -> stmt .)
    INCLUDE_ONCE    reduce using rule 76 (inner_stmt -> stmt .)
    REQUIRE         reduce using rule 76 (inner_stmt -> stmt .)
    REQUIRE_ONCE    reduce using rule 76 (inner_stmt -> stmt .)
    EXIT            reduce using rule 76 (inner_stmt -> stmt .)
    PRINT           reduce using rule 76 (inner_stmt -> stmt .)
    IF              reduce using rule 76 (inner_stmt -> stmt .)
    IDENTIFIER      reduce using rule 76 (inner_stmt -> stmt .)
    STRING          reduce using rule 76 (inner_stmt -> stmt .)
    ENDIF           reduce using rule 76 (inner_stmt -> stmt .)
    ELSE            reduce using rule 76 (inner_stmt -> stmt .)
    ELSEIF          reduce using rule 76 (inner_stmt -> stmt .)
    ENDWHILE        reduce using rule 76 (inner_stmt -> stmt .)
    ENDFOREACH      reduce using rule 76 (inner_stmt -> stmt .)
    CASE            reduce using rule 76 (inner_stmt -> stmt .)
    DEFAULT         reduce using rule 76 (inner_stmt -> stmt .)
    ENDSWITCH       reduce using rule 76 (inner_stmt -> stmt .)
    ENDFOR          reduce using rule 76 (inner_stmt -> stmt .)



state 243

    (77) inner_stmt -> func_decl .

    RBRACE          reduce using rule 77 (inner_stmt -> func_decl .)
    WHILE           reduce using rule 77 (inner_stmt -> func_decl .)
    DO              reduce using rule 77 (inner_stmt -> func_decl .)
    FOR             reduce using rule 77 (inner_stmt -> func_decl .)
    FOREACH         reduce using rule 77 (inner_stmt -> func_decl .)
    SWITCH          reduce using rule 77 (inner_stmt -> func_decl .)
    BREAK           reduce using rule 77 (inner_stmt -> func_decl .)
    CONTINUE        reduce using rule 77 (inner_stmt -> func_decl .)
    RETURN          reduce using rule 77 (inner_stmt -> func_decl .)
    GLOBAL          reduce using rule 77 (inner_stmt -> func_decl .)
    STATIC          reduce using rule 77 (inner_stmt -> func_decl .)
    ECHO            reduce using rule 77 (inner_stmt -> func_decl .)
    LBRACE          reduce using rule 77 (inner_stmt -> func_decl .)
    SEMICOLON       reduce using rule 77 (inner_stmt -> func_decl .)
    FUNCTION        reduce using rule 77 (inner_stmt -> func_decl .)
    CLONE           reduce using rule 77 (inner_stmt -> func_decl .)
    ARRAY           reduce using rule 77 (inner_stmt -> func_decl .)
    PLUS            reduce using rule 77 (inner_stmt -> func_decl .)
    MINUS           reduce using rule 77 (inner_stmt -> func_decl .)
    BIT_NOT         reduce using rule 77 (inner_stmt -> func_decl .)
    NOT             reduce using rule 77 (inner_stmt -> func_decl .)
    CONST_DECIMAL   reduce using rule 77 (inner_stmt -> func_decl .)
    CONST_DOUBLE    reduce using rule 77 (inner_stmt -> func_decl .)
    CONST_STRING    reduce using rule 77 (inner_stmt -> func_decl .)
    NULL            reduce using rule 77 (inner_stmt -> func_decl .)
    TRUE            reduce using rule 77 (inner_stmt -> func_decl .)
    FALSE           reduce using rule 77 (inner_stmt -> func_decl .)
    INC             reduce using rule 77 (inner_stmt -> func_decl .)
    DEC             reduce using rule 77 (inner_stmt -> func_decl .)
    EMPTY           reduce using rule 77 (inner_stmt -> func_decl .)
    EVAL            reduce using rule 77 (inner_stmt -> func_decl .)
    LPAREN          reduce using rule 77 (inner_stmt -> func_decl .)
    INCLUDE         reduce using rule 77 (inner_stmt -> func_decl .)
    INCLUDE_ONCE    reduce using rule 77 (inner_stmt -> func_decl .)
    REQUIRE         reduce using rule 77 (inner_stmt -> func_decl .)
    REQUIRE_ONCE    reduce using rule 77 (inner_stmt -> func_decl .)
    EXIT            reduce using rule 77 (inner_stmt -> func_decl .)
    PRINT           reduce using rule 77 (inner_stmt -> func_decl .)
    IF              reduce using rule 77 (inner_stmt -> func_decl .)
    IDENTIFIER      reduce using rule 77 (inner_stmt -> func_decl .)
    STRING          reduce using rule 77 (inner_stmt -> func_decl .)
    ENDIF           reduce using rule 77 (inner_stmt -> func_decl .)
    ELSE            reduce using rule 77 (inner_stmt -> func_decl .)
    ELSEIF          reduce using rule 77 (inner_stmt -> func_decl .)
    ENDWHILE        reduce using rule 77 (inner_stmt -> func_decl .)
    ENDFOREACH      reduce using rule 77 (inner_stmt -> func_decl .)
    CASE            reduce using rule 77 (inner_stmt -> func_decl .)
    DEFAULT         reduce using rule 77 (inner_stmt -> func_decl .)
    ENDSWITCH       reduce using rule 77 (inner_stmt -> func_decl .)
    ENDFOR          reduce using rule 77 (inner_stmt -> func_decl .)



state 244

    (74) inner_stmts -> inner_stmts jump_marker inner_stmt .

    ENDWHILE        reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    WHILE           reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    DO              reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    FOR             reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    FOREACH         reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    SWITCH          reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    BREAK           reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    CONTINUE        reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    RETURN          reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    GLOBAL          reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    STATIC          reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    ECHO            reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    LBRACE          reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    SEMICOLON       reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    FUNCTION        reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    CLONE           reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    ARRAY           reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    PLUS            reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    MINUS           reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    BIT_NOT         reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    NOT             reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    CONST_DECIMAL   reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    CONST_DOUBLE    reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    CONST_STRING    reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    NULL            reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    TRUE            reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    FALSE           reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    INC             reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    DEC             reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    EMPTY           reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    EVAL            reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    LPAREN          reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    INCLUDE         reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    INCLUDE_ONCE    reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    REQUIRE         reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    REQUIRE_ONCE    reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    EXIT            reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    PRINT           reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    IF              reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    IDENTIFIER      reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    STRING          reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    ENDIF           reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    ELSE            reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    ELSEIF          reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    RBRACE          reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    CASE            reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    DEFAULT         reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    ENDSWITCH       reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    ENDFOR          reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)
    ENDFOREACH      reduce using rule 74 (inner_stmts -> inner_stmts jump_marker inner_stmt .)



state 245

    (57) stmt -> CONTINUE expr goto_marker SEMICOLON .

    WHILE           reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    DO              reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    FOR             reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    FOREACH         reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    SWITCH          reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    BREAK           reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    CONTINUE        reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    RETURN          reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    GLOBAL          reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    STATIC          reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    ECHO            reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    LBRACE          reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    SEMICOLON       reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    FUNCTION        reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    CLONE           reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    ARRAY           reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    PLUS            reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    MINUS           reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    BIT_NOT         reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    NOT             reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    CONST_DECIMAL   reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    CONST_DOUBLE    reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    CONST_STRING    reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    NULL            reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    TRUE            reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    FALSE           reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    INC             reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    DEC             reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    EMPTY           reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    EVAL            reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    LPAREN          reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    INCLUDE         reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    REQUIRE         reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    EXIT            reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    PRINT           reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    IF              reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    IDENTIFIER      reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    STRING          reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    $end            reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    RBRACE          reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    ENDIF           reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    ELSE            reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    ELSEIF          reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    ENDWHILE        reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    ENDFOREACH      reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    CASE            reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    DEFAULT         reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    ENDSWITCH       reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)
    ENDFOR          reduce using rule 57 (stmt -> CONTINUE expr goto_marker SEMICOLON .)



state 246

    (61) global_var_list -> global_var_list COMMA IDENTIFIER .

    SEMICOLON       reduce using rule 61 (global_var_list -> global_var_list COMMA IDENTIFIER .)
    COMMA           reduce using rule 61 (global_var_list -> global_var_list COMMA IDENTIFIER .)



state 247

    (26) stmt -> WHILE LPAREN jump_marker expr . jump_marker RPAREN while_stmt goto_marker
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (177) jump_marker -> . empty
    (179) empty -> .

    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119
    RPAREN          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 281
    empty                          shift and go to state 68

state 248

    (44) stmt -> SWITCH LPAREN expr RPAREN . goto_marker switch_stmt jump_marker
    (178) goto_marker -> . empty
    (179) empty -> .

    LBRACE          reduce using rule 179 (empty -> .)
    COLON           reduce using rule 179 (empty -> .)


    empty                          shift and go to state 80
    goto_marker                    shift and go to state 282

state 249

    (112) array_pair_list -> non_empty_array_pair_list possible_comma .

    RPAREN          reduce using rule 112 (array_pair_list -> non_empty_array_pair_list possible_comma .)



state 250

    (115) non_empty_array_pair_list -> non_empty_array_pair_list COMMA . BIT_AND variable
    (116) non_empty_array_pair_list -> non_empty_array_pair_list COMMA . expr
    (119) non_empty_array_pair_list -> non_empty_array_pair_list COMMA . expr DOUBLE_ARROW BIT_AND variable
    (120) non_empty_array_pair_list -> non_empty_array_pair_list COMMA . expr DOUBLE_ARROW expr
    (114) possible_comma -> COMMA .
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    BIT_AND         shift and go to state 283
    RPAREN          reduce using rule 114 (possible_comma -> COMMA .)
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 284
    variable                       shift and go to state 53

state 251

    (113) possible_comma -> empty .

    RPAREN          reduce using rule 113 (possible_comma -> empty .)



state 252

    (117) non_empty_array_pair_list -> BIT_AND variable .

    COMMA           reduce using rule 117 (non_empty_array_pair_list -> BIT_AND variable .)
    RPAREN          reduce using rule 117 (non_empty_array_pair_list -> BIT_AND variable .)



state 253

    (110) expr -> ARRAY LPAREN array_pair_list RPAREN .

    DOT             reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    PLUS            reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    MINUS           reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    MULT            reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    DIV             reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    MOD             reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_OR          reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_XOR         reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_AND         reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_LSHIFT      reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    BIT_RSHIFT      reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    AND_OP          reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    OR_OP           reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    IDENTICAL       reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    NOT_IDENTICAL   reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    EQ_EQ           reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    NOT_EQ          reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    LESSER          reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    LESSER_EQ       reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    GREATER         reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    GREATER_EQ      reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    INSTANCEOF      reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    COND_OP         reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    SEMICOLON       reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    COMMA           reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    RPAREN          reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    AS              reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    DOUBLE_ARROW    reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    RBRACE          reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    RBRACKET        reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)
    COLON           reduce using rule 110 (expr -> ARRAY LPAREN array_pair_list RPAREN .)



state 254

    (121) non_empty_array_pair_list -> expr DOUBLE_ARROW . BIT_AND variable
    (122) non_empty_array_pair_list -> expr DOUBLE_ARROW . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    BIT_AND         shift and go to state 285
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 286
    variable                       shift and go to state 53

state 255

    (19) if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker . stmt
    (16) stmt -> . if_stmt
    (17) stmt -> . alt_if_stmt
    (26) stmt -> . WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker
    (29) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (30) stmt -> . FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (37) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (44) stmt -> . SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker
    (54) stmt -> . BREAK goto_marker SEMICOLON
    (55) stmt -> . BREAK expr goto_marker SEMICOLON
    (56) stmt -> . CONTINUE goto_marker SEMICOLON
    (57) stmt -> . CONTINUE expr goto_marker SEMICOLON
    (58) stmt -> . RETURN SEMICOLON
    (59) stmt -> . RETURN expr SEMICOLON
    (60) stmt -> . GLOBAL global_var_list SEMICOLON
    (63) stmt -> . STATIC static_var_list SEMICOLON
    (68) stmt -> . ECHO echo_expr_list SEMICOLON
    (71) stmt -> . LBRACE inner_stmts RBRACE
    (72) stmt -> . SEMICOLON
    (73) stmt -> . expr SEMICOLON
    (18) if_stmt -> . if_stmt_without_else
    (19) if_stmt -> . if_stmt_without_else ELSE goto_marker jump_marker stmt
    (22) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (23) alt_if_stmt -> . alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (20) if_stmt_without_else -> . IF LPAREN expr RPAREN jump_marker stmt
    (21) if_stmt_without_else -> . if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON jump_marker inner_stmts
    (25) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    WHILE           shift and go to state 33
    DO              shift and go to state 49
    FOR             shift and go to state 24
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 36
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 30
    RETURN          shift and go to state 16
    GLOBAL          shift and go to state 32
    STATIC          shift and go to state 18
    ECHO            shift and go to state 27
    LBRACE          shift and go to state 29
    SEMICOLON       shift and go to state 35
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    alt_if_stmt                    shift and go to state 25
    stmt                           shift and go to state 287
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 13
    expr                           shift and go to state 45

state 256

    (21) if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN . jump_marker expr RPAREN jump_marker stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 288
    empty                          shift and go to state 68

state 257

    (88) base_var -> base_var LBRACE expr RBRACE .

    EQUAL           reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    LBRACKET        reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    LBRACE          reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    PLUS_EQ         reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    MINUS_EQ        reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    MULTIPLY_EQ     reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    DIVIDE_EQ       reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    DOT_EQ          reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    MOD_EQ          reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    INC             reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    DEC             reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    DOT             reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    PLUS            reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    MINUS           reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    MULT            reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    DIV             reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    MOD             reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    BIT_OR          reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    BIT_XOR         reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    BIT_AND         reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    BIT_LSHIFT      reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    BIT_RSHIFT      reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    AND_OP          reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    OR_OP           reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    IDENTICAL       reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    NOT_IDENTICAL   reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    EQ_EQ           reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    NOT_EQ          reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    LESSER          reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    LESSER_EQ       reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    GREATER         reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    GREATER_EQ      reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    INSTANCEOF      reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    COND_OP         reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    COLON           reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    SEMICOLON       reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    COMMA           reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    RPAREN          reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    AS              reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    DOUBLE_ARROW    reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    RBRACE          reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)
    RBRACKET        reduce using rule 88 (base_var -> base_var LBRACE expr RBRACE .)



state 258

    (93) expr -> base_var EQUAL BIT_AND expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .)
    BIT_XOR         reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .)
    BIT_AND         reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .)
    SEMICOLON       reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .)
    COMMA           reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .)
    RPAREN          reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .)
    AS              reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .)
    DOUBLE_ARROW    reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .)
    RBRACE          reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .)
    RBRACKET        reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .)
    COLON           reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119

  ! DOT             [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! PLUS            [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! MINUS           [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! MULT            [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! DIV             [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! MOD             [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! AND_OP          [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! OR_OP           [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! IDENTICAL       [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! EQ_EQ           [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! NOT_EQ          [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! LESSER          [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! LESSER_EQ       [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! GREATER         [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! GREATER_EQ      [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! INSTANCEOF      [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! COND_OP         [ reduce using rule 93 (expr -> base_var EQUAL BIT_AND expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]


state 259

    (87) base_var -> base_var LBRACKET dim_offset RBRACKET .

    EQUAL           reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    LBRACKET        reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    LBRACE          reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    PLUS_EQ         reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    MINUS_EQ        reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    MULTIPLY_EQ     reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    DIVIDE_EQ       reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    DOT_EQ          reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    MOD_EQ          reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    INC             reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    DEC             reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    DOT             reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    PLUS            reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    MINUS           reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    MULT            reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    DIV             reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    MOD             reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    BIT_OR          reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    BIT_XOR         reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    BIT_AND         reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    BIT_LSHIFT      reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    BIT_RSHIFT      reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    AND_OP          reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    OR_OP           reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    IDENTICAL       reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    NOT_IDENTICAL   reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    EQ_EQ           reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    NOT_EQ          reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    LESSER          reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    LESSER_EQ       reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    GREATER         reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    GREATER_EQ      reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    INSTANCEOF      reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    COND_OP         reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    COLON           reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    SEMICOLON       reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    COMMA           reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    RPAREN          reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    AS              reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    DOUBLE_ARROW    reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    RBRACE          reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)
    RBRACKET        reduce using rule 87 (base_var -> base_var LBRACKET dim_offset RBRACKET .)



state 260

    (141) expr -> expr OR_OP jump_marker expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    BIT_XOR         reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    BIT_AND         reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    OR_OP           reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    COND_OP         reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    SEMICOLON       reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    COMMA           reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    RPAREN          reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    AS              reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    DOUBLE_ARROW    reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    RBRACE          reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    RBRACKET        reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    COLON           reduce using rule 141 (expr -> expr OR_OP jump_marker expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! PLUS            [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! MINUS           [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! MULT            [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! DIV             [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! MOD             [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! AND_OP          [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! IDENTICAL       [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! EQ_EQ           [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! NOT_EQ          [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! LESSER          [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! LESSER_EQ       [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! GREATER         [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! GREATER_EQ      [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! INSTANCEOF      [ reduce using rule 141 (expr -> expr OR_OP jump_marker expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! COND_OP         [ shift and go to state 119 ]


state 261

    (140) expr -> expr AND_OP jump_marker expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    BIT_XOR         reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    BIT_AND         reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    AND_OP          reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    OR_OP           reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    COND_OP         reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    SEMICOLON       reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    COMMA           reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    RPAREN          reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    AS              reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    DOUBLE_ARROW    reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    RBRACE          reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    RBRACKET        reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    COLON           reduce using rule 140 (expr -> expr AND_OP jump_marker expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! PLUS            [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! MINUS           [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! MULT            [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! DIV             [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! MOD             [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! IDENTICAL       [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! EQ_EQ           [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! NOT_EQ          [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! LESSER          [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! LESSER_EQ       [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! GREATER         [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! GREATER_EQ      [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! INSTANCEOF      [ reduce using rule 140 (expr -> expr AND_OP jump_marker expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! AND_OP          [ shift and go to state 116 ]
  ! OR_OP           [ shift and go to state 109 ]
  ! COND_OP         [ shift and go to state 119 ]


state 262

    (161) expr -> expr COND_OP jump_marker expr . goto_marker jump_marker COLON expr
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (178) goto_marker -> . empty
    (179) empty -> .

    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119
    COLON           reduce using rule 179 (empty -> .)


    empty                          shift and go to state 80
    goto_marker                    shift and go to state 289

state 263

    (55) stmt -> BREAK expr goto_marker SEMICOLON .

    WHILE           reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    DO              reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    FOR             reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    FOREACH         reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    SWITCH          reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    BREAK           reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    CONTINUE        reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    RETURN          reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    GLOBAL          reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    STATIC          reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    ECHO            reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    LBRACE          reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    SEMICOLON       reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    FUNCTION        reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    CLONE           reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    ARRAY           reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    PLUS            reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    MINUS           reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    BIT_NOT         reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    NOT             reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    CONST_DECIMAL   reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    CONST_DOUBLE    reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    CONST_STRING    reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    NULL            reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    TRUE            reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    FALSE           reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    INC             reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    DEC             reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    EMPTY           reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    EVAL            reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    LPAREN          reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    INCLUDE         reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    REQUIRE         reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    EXIT            reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    PRINT           reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    IF              reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    IDENTIFIER      reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    STRING          reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    $end            reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    RBRACE          reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    ENDIF           reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    ELSE            reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    ELSEIF          reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    ENDWHILE        reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    ENDFOREACH      reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    CASE            reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    DEFAULT         reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    ENDSWITCH       reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)
    ENDFOR          reduce using rule 55 (stmt -> BREAK expr goto_marker SEMICOLON .)



state 264

    (175) expr -> EXIT LPAREN expr RPAREN .

    DOT             reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    PLUS            reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    MINUS           reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    MULT            reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    DIV             reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    MOD             reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_OR          reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_XOR         reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_AND         reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_LSHIFT      reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    BIT_RSHIFT      reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    AND_OP          reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    OR_OP           reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    IDENTICAL       reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    NOT_IDENTICAL   reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    EQ_EQ           reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    LESSER          reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    LESSER_EQ       reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    GREATER         reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    INSTANCEOF      reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    COND_OP         reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    COMMA           reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    RPAREN          reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    AS              reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    DOUBLE_ARROW    reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    RBRACE          reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)
    COLON           reduce using rule 175 (expr -> EXIT LPAREN expr RPAREN .)



state 265

    (29) stmt -> DO stmt WHILE LPAREN . expr RPAREN SEMICOLON
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 290
    variable                       shift and go to state 53

state 266

    (81) func_call -> STRING LPAREN func_params RPAREN .

    PLUS_EQ         reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    MINUS_EQ        reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    MULTIPLY_EQ     reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    DIVIDE_EQ       reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    DOT_EQ          reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    MOD_EQ          reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    INC             reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    DEC             reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    DOT             reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    PLUS            reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    MINUS           reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    MULT            reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    DIV             reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    MOD             reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    BIT_OR          reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    BIT_XOR         reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    BIT_AND         reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    BIT_LSHIFT      reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    BIT_RSHIFT      reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    AND_OP          reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    OR_OP           reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    IDENTICAL       reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    NOT_IDENTICAL   reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    EQ_EQ           reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    NOT_EQ          reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    LESSER          reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    LESSER_EQ       reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    GREATER         reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    GREATER_EQ      reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    INSTANCEOF      reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    COND_OP         reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    SEMICOLON       reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    COMMA           reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    RPAREN          reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    AS              reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    DOUBLE_ARROW    reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    RBRACE          reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    RBRACKET        reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)
    COLON           reduce using rule 81 (func_call -> STRING LPAREN func_params RPAREN .)



state 267

    (82) func_params -> func_params COMMA . func_param
    (85) func_param -> . expr
    (86) func_param -> . BIT_AND variable
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    BIT_AND         shift and go to state 211
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    base_var                       shift and go to state 43
    func_param                     shift and go to state 291
    func_call                      shift and go to state 40
    expr                           shift and go to state 212
    variable                       shift and go to state 53

state 268

    (86) func_param -> BIT_AND variable .

    RPAREN          reduce using rule 86 (func_param -> BIT_AND variable .)
    COMMA           reduce using rule 86 (func_param -> BIT_AND variable .)



state 269

    (20) if_stmt_without_else -> IF LPAREN expr RPAREN . jump_marker stmt
    (24) alt_if_stmt_without_else -> IF LPAREN expr RPAREN . COLON jump_marker inner_stmts
    (177) jump_marker -> . empty
    (179) empty -> .

    COLON           shift and go to state 293
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 292
    empty                          shift and go to state 68

state 270

    (23) alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON . inner_stmts ENDIF SEMICOLON
    (74) inner_stmts -> . inner_stmts jump_marker inner_stmt
    (75) inner_stmts -> . empty
    (179) empty -> .

    ENDIF           reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    inner_stmts                    shift and go to state 294
    empty                          shift and go to state 86

state 271

    (25) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker . expr RPAREN COLON jump_marker inner_stmts
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 295
    variable                       shift and go to state 53

state 272

    (39) foreach_var -> BIT_AND . IDENTIFIER

    IDENTIFIER      shift and go to state 296



state 273

    (37) stmt -> FOREACH LPAREN expr AS foreach_var . foreach_arg RPAREN foreach_stmt
    (40) foreach_arg -> . empty
    (41) foreach_arg -> . DOUBLE_ARROW foreach_var
    (179) empty -> .

    DOUBLE_ARROW    shift and go to state 297
    RPAREN          reduce using rule 179 (empty -> .)


    foreach_arg                    shift and go to state 298
    empty                          shift and go to state 299

state 274

    (38) foreach_var -> IDENTIFIER .

    RPAREN          reduce using rule 38 (foreach_var -> IDENTIFIER .)
    DOUBLE_ARROW    reduce using rule 38 (foreach_var -> IDENTIFIER .)



state 275

    (101) scalar -> PLUS scalar .

    DOUBLE_ARROW    reduce using rule 101 (scalar -> PLUS scalar .)
    COMMA           reduce using rule 101 (scalar -> PLUS scalar .)
    RPAREN          reduce using rule 101 (scalar -> PLUS scalar .)
    SEMICOLON       reduce using rule 101 (scalar -> PLUS scalar .)



state 276

    (103) scalar -> ARRAY LPAREN . scalar_array_pair_list RPAREN
    (104) scalar_array_pair_list -> . empty
    (105) scalar_array_pair_list -> . scalar_non_empty_array_pair_list possible_comma
    (179) empty -> .
    (106) scalar_non_empty_array_pair_list -> . scalar_non_empty_array_pair_list COMMA scalar
    (107) scalar_non_empty_array_pair_list -> . scalar
    (108) scalar_non_empty_array_pair_list -> . scalar_non_empty_array_pair_list COMMA scalar DOUBLE_ARROW scalar
    (109) scalar_non_empty_array_pair_list -> . scalar DOUBLE_ARROW scalar
    (95) scalar -> . CONST_DECIMAL
    (96) scalar -> . CONST_DOUBLE
    (97) scalar -> . CONST_STRING
    (98) scalar -> . NULL
    (99) scalar -> . TRUE
    (100) scalar -> . FALSE
    (101) scalar -> . PLUS scalar
    (102) scalar -> . MINUS scalar
    (103) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    RPAREN          reduce using rule 179 (empty -> .)
    CONST_DECIMAL   shift and go to state 229
    CONST_DOUBLE    shift and go to state 230
    CONST_STRING    shift and go to state 228
    NULL            shift and go to state 226
    TRUE            shift and go to state 234
    FALSE           shift and go to state 227
    PLUS            shift and go to state 232
    MINUS           shift and go to state 235
    ARRAY           shift and go to state 233


    scalar                         shift and go to state 301
    scalar_non_empty_array_pair_list shift and go to state 300
    empty                          shift and go to state 303
    scalar_array_pair_list         shift and go to state 302

state 277

    (102) scalar -> MINUS scalar .

    DOUBLE_ARROW    reduce using rule 102 (scalar -> MINUS scalar .)
    COMMA           reduce using rule 102 (scalar -> MINUS scalar .)
    RPAREN          reduce using rule 102 (scalar -> MINUS scalar .)
    SEMICOLON       reduce using rule 102 (scalar -> MINUS scalar .)



state 278

    (7) func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN . jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker
    (177) jump_marker -> . empty
    (179) empty -> .

    IDENTIFIER      reduce using rule 179 (empty -> .)
    BIT_AND         reduce using rule 179 (empty -> .)
    RPAREN          reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 304
    empty                          shift and go to state 68

state 279

    (33) non_empty_for_expr -> non_empty_for_expr COMMA expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    COMMA           reduce using rule 33 (non_empty_for_expr -> non_empty_for_expr COMMA expr .)
    SEMICOLON       reduce using rule 33 (non_empty_for_expr -> non_empty_for_expr COMMA expr .)
    RPAREN          reduce using rule 33 (non_empty_for_expr -> non_empty_for_expr COMMA expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 280

    (30) stmt -> FOR LPAREN for_expr SEMICOLON jump_marker . for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (31) for_expr -> . empty
    (32) for_expr -> . non_empty_for_expr
    (179) empty -> .
    (33) non_empty_for_expr -> . non_empty_for_expr COMMA expr
    (34) non_empty_for_expr -> . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    SEMICOLON       reduce using rule 179 (empty -> .)
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    non_empty_for_expr             shift and go to state 153
    expr                           shift and go to state 155
    for_expr                       shift and go to state 305
    variable                       shift and go to state 53
    empty                          shift and go to state 154
    base_var                       shift and go to state 43

state 281

    (26) stmt -> WHILE LPAREN jump_marker expr jump_marker . RPAREN while_stmt goto_marker

    RPAREN          shift and go to state 306



state 282

    (44) stmt -> SWITCH LPAREN expr RPAREN goto_marker . switch_stmt jump_marker
    (45) switch_stmt -> . LBRACE case_stmt RBRACE
    (46) switch_stmt -> . LBRACE SEMICOLON case_stmt RBRACE
    (47) switch_stmt -> . COLON case_stmt ENDSWITCH SEMICOLON
    (48) switch_stmt -> . COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON

    LBRACE          shift and go to state 307
    COLON           shift and go to state 308


    switch_stmt                    shift and go to state 309

state 283

    (115) non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND . variable
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 76
    variable                       shift and go to state 310

state 284

    (116) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr .
    (119) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr . DOUBLE_ARROW BIT_AND variable
    (120) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr . DOUBLE_ARROW expr
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    COMMA           reduce using rule 116 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr .)
    RPAREN          reduce using rule 116 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr .)
    DOUBLE_ARROW    shift and go to state 311
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 285

    (121) non_empty_array_pair_list -> expr DOUBLE_ARROW BIT_AND . variable
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 76
    variable                       shift and go to state 312

state 286

    (122) non_empty_array_pair_list -> expr DOUBLE_ARROW expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    COMMA           reduce using rule 122 (non_empty_array_pair_list -> expr DOUBLE_ARROW expr .)
    RPAREN          reduce using rule 122 (non_empty_array_pair_list -> expr DOUBLE_ARROW expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 287

    (19) if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .

    WHILE           reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    DO              reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    FOR             reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    FOREACH         reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    SWITCH          reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    BREAK           reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    CONTINUE        reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    RETURN          reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    GLOBAL          reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    STATIC          reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    ECHO            reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    LBRACE          reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    SEMICOLON       reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    FUNCTION        reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    CLONE           reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    ARRAY           reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    PLUS            reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    MINUS           reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    BIT_NOT         reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    NOT             reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    CONST_DECIMAL   reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    CONST_DOUBLE    reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    CONST_STRING    reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    NULL            reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    TRUE            reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    FALSE           reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    INC             reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    DEC             reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    EMPTY           reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    EVAL            reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    LPAREN          reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    INCLUDE         reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    INCLUDE_ONCE    reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    REQUIRE         reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    REQUIRE_ONCE    reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    EXIT            reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    PRINT           reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    IF              reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    IDENTIFIER      reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    STRING          reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    $end            reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    RBRACE          reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    ENDIF           reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    ELSE            reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    ELSEIF          reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    ENDWHILE        reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    ENDFOREACH      reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    CASE            reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    DEFAULT         reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    ENDSWITCH       reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)
    ENDFOR          reduce using rule 19 (if_stmt -> if_stmt_without_else ELSE goto_marker jump_marker stmt .)



state 288

    (21) if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker . expr RPAREN jump_marker stmt
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 313
    variable                       shift and go to state 53

state 289

    (161) expr -> expr COND_OP jump_marker expr goto_marker . jump_marker COLON expr
    (177) jump_marker -> . empty
    (179) empty -> .

    COLON           reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 314
    empty                          shift and go to state 68

state 290

    (29) stmt -> DO stmt WHILE LPAREN expr . RPAREN SEMICOLON
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    RPAREN          shift and go to state 315
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 291

    (82) func_params -> func_params COMMA func_param .

    RPAREN          reduce using rule 82 (func_params -> func_params COMMA func_param .)
    COMMA           reduce using rule 82 (func_params -> func_params COMMA func_param .)



state 292

    (20) if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker . stmt
    (16) stmt -> . if_stmt
    (17) stmt -> . alt_if_stmt
    (26) stmt -> . WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker
    (29) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (30) stmt -> . FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (37) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (44) stmt -> . SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker
    (54) stmt -> . BREAK goto_marker SEMICOLON
    (55) stmt -> . BREAK expr goto_marker SEMICOLON
    (56) stmt -> . CONTINUE goto_marker SEMICOLON
    (57) stmt -> . CONTINUE expr goto_marker SEMICOLON
    (58) stmt -> . RETURN SEMICOLON
    (59) stmt -> . RETURN expr SEMICOLON
    (60) stmt -> . GLOBAL global_var_list SEMICOLON
    (63) stmt -> . STATIC static_var_list SEMICOLON
    (68) stmt -> . ECHO echo_expr_list SEMICOLON
    (71) stmt -> . LBRACE inner_stmts RBRACE
    (72) stmt -> . SEMICOLON
    (73) stmt -> . expr SEMICOLON
    (18) if_stmt -> . if_stmt_without_else
    (19) if_stmt -> . if_stmt_without_else ELSE goto_marker jump_marker stmt
    (22) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (23) alt_if_stmt -> . alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (20) if_stmt_without_else -> . IF LPAREN expr RPAREN jump_marker stmt
    (21) if_stmt_without_else -> . if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON jump_marker inner_stmts
    (25) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    WHILE           shift and go to state 33
    DO              shift and go to state 49
    FOR             shift and go to state 24
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 36
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 30
    RETURN          shift and go to state 16
    GLOBAL          shift and go to state 32
    STATIC          shift and go to state 18
    ECHO            shift and go to state 27
    LBRACE          shift and go to state 29
    SEMICOLON       shift and go to state 35
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    alt_if_stmt                    shift and go to state 25
    stmt                           shift and go to state 316
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 13
    expr                           shift and go to state 45

state 293

    (24) alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON . jump_marker inner_stmts
    (177) jump_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    ENDIF           reduce using rule 179 (empty -> .)
    ELSE            reduce using rule 179 (empty -> .)
    ELSEIF          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 317
    empty                          shift and go to state 68

state 294

    (23) alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts . ENDIF SEMICOLON
    (74) inner_stmts -> inner_stmts . jump_marker inner_stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    ENDIF           shift and go to state 318
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 160
    empty                          shift and go to state 68

state 295

    (25) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr . RPAREN COLON jump_marker inner_stmts
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    RPAREN          shift and go to state 319
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 296

    (39) foreach_var -> BIT_AND IDENTIFIER .

    RPAREN          reduce using rule 39 (foreach_var -> BIT_AND IDENTIFIER .)
    DOUBLE_ARROW    reduce using rule 39 (foreach_var -> BIT_AND IDENTIFIER .)



state 297

    (41) foreach_arg -> DOUBLE_ARROW . foreach_var
    (38) foreach_var -> . IDENTIFIER
    (39) foreach_var -> . BIT_AND IDENTIFIER

    IDENTIFIER      shift and go to state 274
    BIT_AND         shift and go to state 272


    foreach_var                    shift and go to state 320

state 298

    (37) stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg . RPAREN foreach_stmt

    RPAREN          shift and go to state 321



state 299

    (40) foreach_arg -> empty .

    RPAREN          reduce using rule 40 (foreach_arg -> empty .)



state 300

    (105) scalar_array_pair_list -> scalar_non_empty_array_pair_list . possible_comma
    (106) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list . COMMA scalar
    (108) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list . COMMA scalar DOUBLE_ARROW scalar
    (113) possible_comma -> . empty
    (114) possible_comma -> . COMMA
    (179) empty -> .

    COMMA           shift and go to state 323
    RPAREN          reduce using rule 179 (empty -> .)


    empty                          shift and go to state 251
    possible_comma                 shift and go to state 322

state 301

    (107) scalar_non_empty_array_pair_list -> scalar .
    (109) scalar_non_empty_array_pair_list -> scalar . DOUBLE_ARROW scalar

    COMMA           reduce using rule 107 (scalar_non_empty_array_pair_list -> scalar .)
    RPAREN          reduce using rule 107 (scalar_non_empty_array_pair_list -> scalar .)
    DOUBLE_ARROW    shift and go to state 324



state 302

    (103) scalar -> ARRAY LPAREN scalar_array_pair_list . RPAREN

    RPAREN          shift and go to state 325



state 303

    (104) scalar_array_pair_list -> empty .

    RPAREN          reduce using rule 104 (scalar_array_pair_list -> empty .)



state 304

    (7) func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker . params RPAREN LBRACE inner_stmts RBRACE jump_marker
    (9) params -> . params COMMA param
    (10) params -> . param
    (11) params -> . empty
    (12) param -> . IDENTIFIER
    (13) param -> . BIT_AND IDENTIFIER
    (14) param -> . IDENTIFIER EQUAL scalar
    (15) param -> . BIT_AND IDENTIFIER EQUAL scalar
    (179) empty -> .

    IDENTIFIER      shift and go to state 329
    BIT_AND         shift and go to state 326
    RPAREN          reduce using rule 179 (empty -> .)
    COMMA           reduce using rule 179 (empty -> .)


    param                          shift and go to state 327
    params                         shift and go to state 328
    empty                          shift and go to state 330

state 305

    (30) stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr . SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker

    SEMICOLON       shift and go to state 331



state 306

    (26) stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN . while_stmt goto_marker
    (27) while_stmt -> . stmt
    (28) while_stmt -> . COLON inner_stmts ENDWHILE SEMICOLON
    (16) stmt -> . if_stmt
    (17) stmt -> . alt_if_stmt
    (26) stmt -> . WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker
    (29) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (30) stmt -> . FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (37) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (44) stmt -> . SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker
    (54) stmt -> . BREAK goto_marker SEMICOLON
    (55) stmt -> . BREAK expr goto_marker SEMICOLON
    (56) stmt -> . CONTINUE goto_marker SEMICOLON
    (57) stmt -> . CONTINUE expr goto_marker SEMICOLON
    (58) stmt -> . RETURN SEMICOLON
    (59) stmt -> . RETURN expr SEMICOLON
    (60) stmt -> . GLOBAL global_var_list SEMICOLON
    (63) stmt -> . STATIC static_var_list SEMICOLON
    (68) stmt -> . ECHO echo_expr_list SEMICOLON
    (71) stmt -> . LBRACE inner_stmts RBRACE
    (72) stmt -> . SEMICOLON
    (73) stmt -> . expr SEMICOLON
    (18) if_stmt -> . if_stmt_without_else
    (19) if_stmt -> . if_stmt_without_else ELSE goto_marker jump_marker stmt
    (22) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (23) alt_if_stmt -> . alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (20) if_stmt_without_else -> . IF LPAREN expr RPAREN jump_marker stmt
    (21) if_stmt_without_else -> . if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON jump_marker inner_stmts
    (25) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    COLON           shift and go to state 332
    WHILE           shift and go to state 33
    DO              shift and go to state 49
    FOR             shift and go to state 24
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 36
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 30
    RETURN          shift and go to state 16
    GLOBAL          shift and go to state 32
    STATIC          shift and go to state 18
    ECHO            shift and go to state 27
    LBRACE          shift and go to state 29
    SEMICOLON       shift and go to state 35
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    alt_if_stmt                    shift and go to state 25
    stmt                           shift and go to state 333
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 13
    expr                           shift and go to state 45
    while_stmt                     shift and go to state 334

state 307

    (45) switch_stmt -> LBRACE . case_stmt RBRACE
    (46) switch_stmt -> LBRACE . SEMICOLON case_stmt RBRACE
    (49) case_stmt -> . empty
    (50) case_stmt -> . case_stmt CASE expr case_separator jump_marker inner_stmts
    (51) case_stmt -> . case_stmt DEFAULT case_separator jump_marker inner_stmts
    (179) empty -> .

    SEMICOLON       shift and go to state 336
    RBRACE          reduce using rule 179 (empty -> .)
    CASE            reduce using rule 179 (empty -> .)
    DEFAULT         reduce using rule 179 (empty -> .)


    case_stmt                      shift and go to state 335
    empty                          shift and go to state 337

state 308

    (47) switch_stmt -> COLON . case_stmt ENDSWITCH SEMICOLON
    (48) switch_stmt -> COLON . SEMICOLON case_stmt ENDSWITCH SEMICOLON
    (49) case_stmt -> . empty
    (50) case_stmt -> . case_stmt CASE expr case_separator jump_marker inner_stmts
    (51) case_stmt -> . case_stmt DEFAULT case_separator jump_marker inner_stmts
    (179) empty -> .

    SEMICOLON       shift and go to state 339
    ENDSWITCH       reduce using rule 179 (empty -> .)
    CASE            reduce using rule 179 (empty -> .)
    DEFAULT         reduce using rule 179 (empty -> .)


    case_stmt                      shift and go to state 338
    empty                          shift and go to state 337

state 309

    (44) stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt . jump_marker
    (177) jump_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    $end            reduce using rule 179 (empty -> .)
    RBRACE          reduce using rule 179 (empty -> .)
    ENDIF           reduce using rule 179 (empty -> .)
    ELSE            reduce using rule 179 (empty -> .)
    ELSEIF          reduce using rule 179 (empty -> .)
    ENDWHILE        reduce using rule 179 (empty -> .)
    ENDFOREACH      reduce using rule 179 (empty -> .)
    CASE            reduce using rule 179 (empty -> .)
    DEFAULT         reduce using rule 179 (empty -> .)
    ENDSWITCH       reduce using rule 179 (empty -> .)
    ENDFOR          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 340
    empty                          shift and go to state 68

state 310

    (115) non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND variable .

    COMMA           reduce using rule 115 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND variable .)
    RPAREN          reduce using rule 115 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA BIT_AND variable .)



state 311

    (119) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW . BIT_AND variable
    (120) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    BIT_AND         shift and go to state 341
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 342
    variable                       shift and go to state 53

state 312

    (121) non_empty_array_pair_list -> expr DOUBLE_ARROW BIT_AND variable .

    COMMA           reduce using rule 121 (non_empty_array_pair_list -> expr DOUBLE_ARROW BIT_AND variable .)
    RPAREN          reduce using rule 121 (non_empty_array_pair_list -> expr DOUBLE_ARROW BIT_AND variable .)



state 313

    (21) if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr . RPAREN jump_marker stmt
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    RPAREN          shift and go to state 343
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 314

    (161) expr -> expr COND_OP jump_marker expr goto_marker jump_marker . COLON expr

    COLON           shift and go to state 344



state 315

    (29) stmt -> DO stmt WHILE LPAREN expr RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 345



state 316

    (20) if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .

    WHILE           reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    DO              reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    FOR             reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    FOREACH         reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    SWITCH          reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    BREAK           reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    CONTINUE        reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    RETURN          reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    GLOBAL          reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    STATIC          reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    ECHO            reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    LBRACE          reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    SEMICOLON       reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    FUNCTION        reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    CLONE           reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    ARRAY           reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    PLUS            reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    MINUS           reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    BIT_NOT         reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    NOT             reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    CONST_DECIMAL   reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    CONST_DOUBLE    reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    CONST_STRING    reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    NULL            reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    TRUE            reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    FALSE           reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    INC             reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    DEC             reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    EMPTY           reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    EVAL            reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    LPAREN          reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    INCLUDE         reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    INCLUDE_ONCE    reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    REQUIRE         reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    REQUIRE_ONCE    reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    EXIT            reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    PRINT           reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    IF              reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    IDENTIFIER      reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    STRING          reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    $end            reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    RBRACE          reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    ENDIF           reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    ELSE            reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    ELSEIF          reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    ENDWHILE        reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    ENDFOREACH      reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    CASE            reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    DEFAULT         reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    ENDSWITCH       reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)
    ENDFOR          reduce using rule 20 (if_stmt_without_else -> IF LPAREN expr RPAREN jump_marker stmt .)



state 317

    (24) alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON jump_marker . inner_stmts
    (74) inner_stmts -> . inner_stmts jump_marker inner_stmt
    (75) inner_stmts -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    ENDIF           reduce using rule 179 (empty -> .)
    ELSE            reduce using rule 179 (empty -> .)
    ELSEIF          reduce using rule 179 (empty -> .)


    inner_stmts                    shift and go to state 346
    empty                          shift and go to state 86

state 318

    (23) alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF . SEMICOLON

    SEMICOLON       shift and go to state 347



state 319

    (25) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN . COLON jump_marker inner_stmts

    COLON           shift and go to state 348



state 320

    (41) foreach_arg -> DOUBLE_ARROW foreach_var .

    RPAREN          reduce using rule 41 (foreach_arg -> DOUBLE_ARROW foreach_var .)



state 321

    (37) stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN . foreach_stmt
    (42) foreach_stmt -> . stmt
    (43) foreach_stmt -> . COLON inner_stmts ENDFOREACH SEMICOLON
    (16) stmt -> . if_stmt
    (17) stmt -> . alt_if_stmt
    (26) stmt -> . WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker
    (29) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (30) stmt -> . FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (37) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (44) stmt -> . SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker
    (54) stmt -> . BREAK goto_marker SEMICOLON
    (55) stmt -> . BREAK expr goto_marker SEMICOLON
    (56) stmt -> . CONTINUE goto_marker SEMICOLON
    (57) stmt -> . CONTINUE expr goto_marker SEMICOLON
    (58) stmt -> . RETURN SEMICOLON
    (59) stmt -> . RETURN expr SEMICOLON
    (60) stmt -> . GLOBAL global_var_list SEMICOLON
    (63) stmt -> . STATIC static_var_list SEMICOLON
    (68) stmt -> . ECHO echo_expr_list SEMICOLON
    (71) stmt -> . LBRACE inner_stmts RBRACE
    (72) stmt -> . SEMICOLON
    (73) stmt -> . expr SEMICOLON
    (18) if_stmt -> . if_stmt_without_else
    (19) if_stmt -> . if_stmt_without_else ELSE goto_marker jump_marker stmt
    (22) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (23) alt_if_stmt -> . alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (20) if_stmt_without_else -> . IF LPAREN expr RPAREN jump_marker stmt
    (21) if_stmt_without_else -> . if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON jump_marker inner_stmts
    (25) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    COLON           shift and go to state 350
    WHILE           shift and go to state 33
    DO              shift and go to state 49
    FOR             shift and go to state 24
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 36
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 30
    RETURN          shift and go to state 16
    GLOBAL          shift and go to state 32
    STATIC          shift and go to state 18
    ECHO            shift and go to state 27
    LBRACE          shift and go to state 29
    SEMICOLON       shift and go to state 35
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    foreach_stmt                   shift and go to state 349
    alt_if_stmt                    shift and go to state 25
    stmt                           shift and go to state 351
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 13
    expr                           shift and go to state 45

state 322

    (105) scalar_array_pair_list -> scalar_non_empty_array_pair_list possible_comma .

    RPAREN          reduce using rule 105 (scalar_array_pair_list -> scalar_non_empty_array_pair_list possible_comma .)



state 323

    (106) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA . scalar
    (108) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA . scalar DOUBLE_ARROW scalar
    (114) possible_comma -> COMMA .
    (95) scalar -> . CONST_DECIMAL
    (96) scalar -> . CONST_DOUBLE
    (97) scalar -> . CONST_STRING
    (98) scalar -> . NULL
    (99) scalar -> . TRUE
    (100) scalar -> . FALSE
    (101) scalar -> . PLUS scalar
    (102) scalar -> . MINUS scalar
    (103) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    RPAREN          reduce using rule 114 (possible_comma -> COMMA .)
    CONST_DECIMAL   shift and go to state 229
    CONST_DOUBLE    shift and go to state 230
    CONST_STRING    shift and go to state 228
    NULL            shift and go to state 226
    TRUE            shift and go to state 234
    FALSE           shift and go to state 227
    PLUS            shift and go to state 232
    MINUS           shift and go to state 235
    ARRAY           shift and go to state 233


    scalar                         shift and go to state 352

state 324

    (109) scalar_non_empty_array_pair_list -> scalar DOUBLE_ARROW . scalar
    (95) scalar -> . CONST_DECIMAL
    (96) scalar -> . CONST_DOUBLE
    (97) scalar -> . CONST_STRING
    (98) scalar -> . NULL
    (99) scalar -> . TRUE
    (100) scalar -> . FALSE
    (101) scalar -> . PLUS scalar
    (102) scalar -> . MINUS scalar
    (103) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 229
    CONST_DOUBLE    shift and go to state 230
    CONST_STRING    shift and go to state 228
    NULL            shift and go to state 226
    TRUE            shift and go to state 234
    FALSE           shift and go to state 227
    PLUS            shift and go to state 232
    MINUS           shift and go to state 235
    ARRAY           shift and go to state 233


    scalar                         shift and go to state 353

state 325

    (103) scalar -> ARRAY LPAREN scalar_array_pair_list RPAREN .

    DOUBLE_ARROW    reduce using rule 103 (scalar -> ARRAY LPAREN scalar_array_pair_list RPAREN .)
    COMMA           reduce using rule 103 (scalar -> ARRAY LPAREN scalar_array_pair_list RPAREN .)
    RPAREN          reduce using rule 103 (scalar -> ARRAY LPAREN scalar_array_pair_list RPAREN .)
    SEMICOLON       reduce using rule 103 (scalar -> ARRAY LPAREN scalar_array_pair_list RPAREN .)



state 326

    (13) param -> BIT_AND . IDENTIFIER
    (15) param -> BIT_AND . IDENTIFIER EQUAL scalar

    IDENTIFIER      shift and go to state 354



state 327

    (10) params -> param .

    RPAREN          reduce using rule 10 (params -> param .)
    COMMA           reduce using rule 10 (params -> param .)



state 328

    (7) func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params . RPAREN LBRACE inner_stmts RBRACE jump_marker
    (9) params -> params . COMMA param

    RPAREN          shift and go to state 355
    COMMA           shift and go to state 356



state 329

    (12) param -> IDENTIFIER .
    (14) param -> IDENTIFIER . EQUAL scalar

    RPAREN          reduce using rule 12 (param -> IDENTIFIER .)
    COMMA           reduce using rule 12 (param -> IDENTIFIER .)
    EQUAL           shift and go to state 357



state 330

    (11) params -> empty .

    RPAREN          reduce using rule 11 (params -> empty .)
    COMMA           reduce using rule 11 (params -> empty .)



state 331

    (30) stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON . jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (177) jump_marker -> . empty
    (179) empty -> .

    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    RPAREN          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 358
    empty                          shift and go to state 68

state 332

    (28) while_stmt -> COLON . inner_stmts ENDWHILE SEMICOLON
    (74) inner_stmts -> . inner_stmts jump_marker inner_stmt
    (75) inner_stmts -> . empty
    (179) empty -> .

    ENDWHILE        reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    inner_stmts                    shift and go to state 359
    empty                          shift and go to state 86

state 333

    (27) while_stmt -> stmt .

    WHILE           reduce using rule 27 (while_stmt -> stmt .)
    DO              reduce using rule 27 (while_stmt -> stmt .)
    FOR             reduce using rule 27 (while_stmt -> stmt .)
    FOREACH         reduce using rule 27 (while_stmt -> stmt .)
    SWITCH          reduce using rule 27 (while_stmt -> stmt .)
    BREAK           reduce using rule 27 (while_stmt -> stmt .)
    CONTINUE        reduce using rule 27 (while_stmt -> stmt .)
    RETURN          reduce using rule 27 (while_stmt -> stmt .)
    GLOBAL          reduce using rule 27 (while_stmt -> stmt .)
    STATIC          reduce using rule 27 (while_stmt -> stmt .)
    ECHO            reduce using rule 27 (while_stmt -> stmt .)
    LBRACE          reduce using rule 27 (while_stmt -> stmt .)
    SEMICOLON       reduce using rule 27 (while_stmt -> stmt .)
    FUNCTION        reduce using rule 27 (while_stmt -> stmt .)
    CLONE           reduce using rule 27 (while_stmt -> stmt .)
    ARRAY           reduce using rule 27 (while_stmt -> stmt .)
    PLUS            reduce using rule 27 (while_stmt -> stmt .)
    MINUS           reduce using rule 27 (while_stmt -> stmt .)
    BIT_NOT         reduce using rule 27 (while_stmt -> stmt .)
    NOT             reduce using rule 27 (while_stmt -> stmt .)
    CONST_DECIMAL   reduce using rule 27 (while_stmt -> stmt .)
    CONST_DOUBLE    reduce using rule 27 (while_stmt -> stmt .)
    CONST_STRING    reduce using rule 27 (while_stmt -> stmt .)
    NULL            reduce using rule 27 (while_stmt -> stmt .)
    TRUE            reduce using rule 27 (while_stmt -> stmt .)
    FALSE           reduce using rule 27 (while_stmt -> stmt .)
    INC             reduce using rule 27 (while_stmt -> stmt .)
    DEC             reduce using rule 27 (while_stmt -> stmt .)
    EMPTY           reduce using rule 27 (while_stmt -> stmt .)
    EVAL            reduce using rule 27 (while_stmt -> stmt .)
    LPAREN          reduce using rule 27 (while_stmt -> stmt .)
    INCLUDE         reduce using rule 27 (while_stmt -> stmt .)
    INCLUDE_ONCE    reduce using rule 27 (while_stmt -> stmt .)
    REQUIRE         reduce using rule 27 (while_stmt -> stmt .)
    REQUIRE_ONCE    reduce using rule 27 (while_stmt -> stmt .)
    EXIT            reduce using rule 27 (while_stmt -> stmt .)
    PRINT           reduce using rule 27 (while_stmt -> stmt .)
    IF              reduce using rule 27 (while_stmt -> stmt .)
    IDENTIFIER      reduce using rule 27 (while_stmt -> stmt .)
    STRING          reduce using rule 27 (while_stmt -> stmt .)
    $end            reduce using rule 27 (while_stmt -> stmt .)
    RBRACE          reduce using rule 27 (while_stmt -> stmt .)
    ENDIF           reduce using rule 27 (while_stmt -> stmt .)
    ELSE            reduce using rule 27 (while_stmt -> stmt .)
    ELSEIF          reduce using rule 27 (while_stmt -> stmt .)
    ENDWHILE        reduce using rule 27 (while_stmt -> stmt .)
    ENDFOREACH      reduce using rule 27 (while_stmt -> stmt .)
    CASE            reduce using rule 27 (while_stmt -> stmt .)
    DEFAULT         reduce using rule 27 (while_stmt -> stmt .)
    ENDSWITCH       reduce using rule 27 (while_stmt -> stmt .)
    ENDFOR          reduce using rule 27 (while_stmt -> stmt .)



state 334

    (26) stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt . goto_marker
    (178) goto_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    $end            reduce using rule 179 (empty -> .)
    RBRACE          reduce using rule 179 (empty -> .)
    ENDIF           reduce using rule 179 (empty -> .)
    ELSE            reduce using rule 179 (empty -> .)
    ELSEIF          reduce using rule 179 (empty -> .)
    ENDWHILE        reduce using rule 179 (empty -> .)
    ENDFOREACH      reduce using rule 179 (empty -> .)
    CASE            reduce using rule 179 (empty -> .)
    DEFAULT         reduce using rule 179 (empty -> .)
    ENDSWITCH       reduce using rule 179 (empty -> .)
    ENDFOR          reduce using rule 179 (empty -> .)


    empty                          shift and go to state 80
    goto_marker                    shift and go to state 360

state 335

    (45) switch_stmt -> LBRACE case_stmt . RBRACE
    (50) case_stmt -> case_stmt . CASE expr case_separator jump_marker inner_stmts
    (51) case_stmt -> case_stmt . DEFAULT case_separator jump_marker inner_stmts

    RBRACE          shift and go to state 362
    CASE            shift and go to state 361
    DEFAULT         shift and go to state 363



state 336

    (46) switch_stmt -> LBRACE SEMICOLON . case_stmt RBRACE
    (49) case_stmt -> . empty
    (50) case_stmt -> . case_stmt CASE expr case_separator jump_marker inner_stmts
    (51) case_stmt -> . case_stmt DEFAULT case_separator jump_marker inner_stmts
    (179) empty -> .

    RBRACE          reduce using rule 179 (empty -> .)
    CASE            reduce using rule 179 (empty -> .)
    DEFAULT         reduce using rule 179 (empty -> .)


    case_stmt                      shift and go to state 364
    empty                          shift and go to state 337

state 337

    (49) case_stmt -> empty .

    RBRACE          reduce using rule 49 (case_stmt -> empty .)
    CASE            reduce using rule 49 (case_stmt -> empty .)
    DEFAULT         reduce using rule 49 (case_stmt -> empty .)
    ENDSWITCH       reduce using rule 49 (case_stmt -> empty .)



state 338

    (47) switch_stmt -> COLON case_stmt . ENDSWITCH SEMICOLON
    (50) case_stmt -> case_stmt . CASE expr case_separator jump_marker inner_stmts
    (51) case_stmt -> case_stmt . DEFAULT case_separator jump_marker inner_stmts

    ENDSWITCH       shift and go to state 365
    CASE            shift and go to state 361
    DEFAULT         shift and go to state 363



state 339

    (48) switch_stmt -> COLON SEMICOLON . case_stmt ENDSWITCH SEMICOLON
    (49) case_stmt -> . empty
    (50) case_stmt -> . case_stmt CASE expr case_separator jump_marker inner_stmts
    (51) case_stmt -> . case_stmt DEFAULT case_separator jump_marker inner_stmts
    (179) empty -> .

    ENDSWITCH       reduce using rule 179 (empty -> .)
    CASE            reduce using rule 179 (empty -> .)
    DEFAULT         reduce using rule 179 (empty -> .)


    case_stmt                      shift and go to state 366
    empty                          shift and go to state 337

state 340

    (44) stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .

    WHILE           reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    DO              reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    FOR             reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    FOREACH         reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    SWITCH          reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    BREAK           reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    CONTINUE        reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    RETURN          reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    GLOBAL          reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    STATIC          reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    ECHO            reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    LBRACE          reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    SEMICOLON       reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    FUNCTION        reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    CLONE           reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    ARRAY           reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    PLUS            reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    MINUS           reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    BIT_NOT         reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    NOT             reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    CONST_DECIMAL   reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    CONST_DOUBLE    reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    CONST_STRING    reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    NULL            reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    TRUE            reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    FALSE           reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    INC             reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    DEC             reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    EMPTY           reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    EVAL            reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    LPAREN          reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    INCLUDE         reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    INCLUDE_ONCE    reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    REQUIRE         reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    REQUIRE_ONCE    reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    EXIT            reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    PRINT           reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    IF              reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    IDENTIFIER      reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    STRING          reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    $end            reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    RBRACE          reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    ENDIF           reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    ELSE            reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    ELSEIF          reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    ENDWHILE        reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    ENDFOREACH      reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    CASE            reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    DEFAULT         reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    ENDSWITCH       reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)
    ENDFOR          reduce using rule 44 (stmt -> SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker .)



state 341

    (119) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW BIT_AND . variable
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 76
    variable                       shift and go to state 367

state 342

    (120) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    COMMA           reduce using rule 120 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW expr .)
    RPAREN          reduce using rule 120 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119



state 343

    (21) if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN . jump_marker stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 368
    empty                          shift and go to state 68

state 344

    (161) expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 369
    variable                       shift and go to state 53

state 345

    (29) stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .

    WHILE           reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    DO              reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    FOR             reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    FOREACH         reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    SWITCH          reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    BREAK           reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    RETURN          reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    GLOBAL          reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    STATIC          reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ECHO            reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    LBRACE          reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    CLONE           reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ARRAY           reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    PLUS            reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    MINUS           reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    BIT_NOT         reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    NOT             reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    CONST_DECIMAL   reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    CONST_DOUBLE    reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    CONST_STRING    reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    NULL            reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    TRUE            reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    FALSE           reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    INC             reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    DEC             reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    EMPTY           reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    EVAL            reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    LPAREN          reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    INCLUDE         reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    REQUIRE         reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    EXIT            reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    PRINT           reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    IF              reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    STRING          reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    $end            reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    RBRACE          reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ENDIF           reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ELSE            reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ELSEIF          reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ENDWHILE        reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ENDFOREACH      reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    CASE            reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    DEFAULT         reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ENDSWITCH       reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ENDFOR          reduce using rule 29 (stmt -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)



state 346

    (24) alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON jump_marker inner_stmts .
    (74) inner_stmts -> inner_stmts . jump_marker inner_stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    ENDIF           reduce using rule 24 (alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON jump_marker inner_stmts .)
    ELSE            reduce using rule 24 (alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON jump_marker inner_stmts .)
    ELSEIF          reduce using rule 24 (alt_if_stmt_without_else -> IF LPAREN expr RPAREN COLON jump_marker inner_stmts .)
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 160
    empty                          shift and go to state 68

state 347

    (23) alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .

    WHILE           reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    DO              reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    FOR             reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    FOREACH         reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    SWITCH          reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    BREAK           reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    CONTINUE        reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    RETURN          reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    GLOBAL          reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    STATIC          reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    ECHO            reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    LBRACE          reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    SEMICOLON       reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    FUNCTION        reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    CLONE           reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    ARRAY           reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    PLUS            reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    MINUS           reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    BIT_NOT         reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    NOT             reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    CONST_DECIMAL   reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    CONST_DOUBLE    reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    CONST_STRING    reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    NULL            reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    TRUE            reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    FALSE           reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    INC             reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    DEC             reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    EMPTY           reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    EVAL            reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    LPAREN          reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    INCLUDE         reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    REQUIRE         reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    EXIT            reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    PRINT           reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    IF              reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    IDENTIFIER      reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    STRING          reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    $end            reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    RBRACE          reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    ENDIF           reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    ELSE            reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    ELSEIF          reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    ENDWHILE        reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    ENDFOREACH      reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    CASE            reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    DEFAULT         reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    ENDSWITCH       reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)
    ENDFOR          reduce using rule 23 (alt_if_stmt -> alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON .)



state 348

    (25) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON . jump_marker inner_stmts
    (177) jump_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    ENDIF           reduce using rule 179 (empty -> .)
    ELSE            reduce using rule 179 (empty -> .)
    ELSEIF          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 370
    empty                          shift and go to state 68

state 349

    (37) stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .

    WHILE           reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    DO              reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    FOR             reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    FOREACH         reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    SWITCH          reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    BREAK           reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    CONTINUE        reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    RETURN          reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    GLOBAL          reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    STATIC          reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ECHO            reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    LBRACE          reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    SEMICOLON       reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    FUNCTION        reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    CLONE           reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ARRAY           reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    PLUS            reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    MINUS           reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    BIT_NOT         reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    NOT             reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    CONST_DECIMAL   reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    CONST_DOUBLE    reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    CONST_STRING    reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    NULL            reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    TRUE            reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    FALSE           reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    INC             reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    DEC             reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    EMPTY           reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    EVAL            reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    LPAREN          reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    INCLUDE         reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    INCLUDE_ONCE    reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    REQUIRE         reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    REQUIRE_ONCE    reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    EXIT            reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    PRINT           reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    IF              reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    IDENTIFIER      reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    STRING          reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    $end            reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    RBRACE          reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ENDIF           reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ELSE            reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ELSEIF          reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ENDWHILE        reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ENDFOREACH      reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    CASE            reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    DEFAULT         reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ENDSWITCH       reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)
    ENDFOR          reduce using rule 37 (stmt -> FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt .)



state 350

    (43) foreach_stmt -> COLON . inner_stmts ENDFOREACH SEMICOLON
    (74) inner_stmts -> . inner_stmts jump_marker inner_stmt
    (75) inner_stmts -> . empty
    (179) empty -> .

    ENDFOREACH      reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    inner_stmts                    shift and go to state 371
    empty                          shift and go to state 86

state 351

    (42) foreach_stmt -> stmt .

    WHILE           reduce using rule 42 (foreach_stmt -> stmt .)
    DO              reduce using rule 42 (foreach_stmt -> stmt .)
    FOR             reduce using rule 42 (foreach_stmt -> stmt .)
    FOREACH         reduce using rule 42 (foreach_stmt -> stmt .)
    SWITCH          reduce using rule 42 (foreach_stmt -> stmt .)
    BREAK           reduce using rule 42 (foreach_stmt -> stmt .)
    CONTINUE        reduce using rule 42 (foreach_stmt -> stmt .)
    RETURN          reduce using rule 42 (foreach_stmt -> stmt .)
    GLOBAL          reduce using rule 42 (foreach_stmt -> stmt .)
    STATIC          reduce using rule 42 (foreach_stmt -> stmt .)
    ECHO            reduce using rule 42 (foreach_stmt -> stmt .)
    LBRACE          reduce using rule 42 (foreach_stmt -> stmt .)
    SEMICOLON       reduce using rule 42 (foreach_stmt -> stmt .)
    FUNCTION        reduce using rule 42 (foreach_stmt -> stmt .)
    CLONE           reduce using rule 42 (foreach_stmt -> stmt .)
    ARRAY           reduce using rule 42 (foreach_stmt -> stmt .)
    PLUS            reduce using rule 42 (foreach_stmt -> stmt .)
    MINUS           reduce using rule 42 (foreach_stmt -> stmt .)
    BIT_NOT         reduce using rule 42 (foreach_stmt -> stmt .)
    NOT             reduce using rule 42 (foreach_stmt -> stmt .)
    CONST_DECIMAL   reduce using rule 42 (foreach_stmt -> stmt .)
    CONST_DOUBLE    reduce using rule 42 (foreach_stmt -> stmt .)
    CONST_STRING    reduce using rule 42 (foreach_stmt -> stmt .)
    NULL            reduce using rule 42 (foreach_stmt -> stmt .)
    TRUE            reduce using rule 42 (foreach_stmt -> stmt .)
    FALSE           reduce using rule 42 (foreach_stmt -> stmt .)
    INC             reduce using rule 42 (foreach_stmt -> stmt .)
    DEC             reduce using rule 42 (foreach_stmt -> stmt .)
    EMPTY           reduce using rule 42 (foreach_stmt -> stmt .)
    EVAL            reduce using rule 42 (foreach_stmt -> stmt .)
    LPAREN          reduce using rule 42 (foreach_stmt -> stmt .)
    INCLUDE         reduce using rule 42 (foreach_stmt -> stmt .)
    INCLUDE_ONCE    reduce using rule 42 (foreach_stmt -> stmt .)
    REQUIRE         reduce using rule 42 (foreach_stmt -> stmt .)
    REQUIRE_ONCE    reduce using rule 42 (foreach_stmt -> stmt .)
    EXIT            reduce using rule 42 (foreach_stmt -> stmt .)
    PRINT           reduce using rule 42 (foreach_stmt -> stmt .)
    IF              reduce using rule 42 (foreach_stmt -> stmt .)
    IDENTIFIER      reduce using rule 42 (foreach_stmt -> stmt .)
    STRING          reduce using rule 42 (foreach_stmt -> stmt .)
    $end            reduce using rule 42 (foreach_stmt -> stmt .)
    RBRACE          reduce using rule 42 (foreach_stmt -> stmt .)
    ENDIF           reduce using rule 42 (foreach_stmt -> stmt .)
    ELSE            reduce using rule 42 (foreach_stmt -> stmt .)
    ELSEIF          reduce using rule 42 (foreach_stmt -> stmt .)
    ENDWHILE        reduce using rule 42 (foreach_stmt -> stmt .)
    ENDFOREACH      reduce using rule 42 (foreach_stmt -> stmt .)
    CASE            reduce using rule 42 (foreach_stmt -> stmt .)
    DEFAULT         reduce using rule 42 (foreach_stmt -> stmt .)
    ENDSWITCH       reduce using rule 42 (foreach_stmt -> stmt .)
    ENDFOR          reduce using rule 42 (foreach_stmt -> stmt .)



state 352

    (106) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar .
    (108) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar . DOUBLE_ARROW scalar

    COMMA           reduce using rule 106 (scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar .)
    RPAREN          reduce using rule 106 (scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar .)
    DOUBLE_ARROW    shift and go to state 372



state 353

    (109) scalar_non_empty_array_pair_list -> scalar DOUBLE_ARROW scalar .

    COMMA           reduce using rule 109 (scalar_non_empty_array_pair_list -> scalar DOUBLE_ARROW scalar .)
    RPAREN          reduce using rule 109 (scalar_non_empty_array_pair_list -> scalar DOUBLE_ARROW scalar .)



state 354

    (13) param -> BIT_AND IDENTIFIER .
    (15) param -> BIT_AND IDENTIFIER . EQUAL scalar

    RPAREN          reduce using rule 13 (param -> BIT_AND IDENTIFIER .)
    COMMA           reduce using rule 13 (param -> BIT_AND IDENTIFIER .)
    EQUAL           shift and go to state 373



state 355

    (7) func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN . LBRACE inner_stmts RBRACE jump_marker

    LBRACE          shift and go to state 374



state 356

    (9) params -> params COMMA . param
    (12) param -> . IDENTIFIER
    (13) param -> . BIT_AND IDENTIFIER
    (14) param -> . IDENTIFIER EQUAL scalar
    (15) param -> . BIT_AND IDENTIFIER EQUAL scalar

    IDENTIFIER      shift and go to state 329
    BIT_AND         shift and go to state 326


    param                          shift and go to state 375

state 357

    (14) param -> IDENTIFIER EQUAL . scalar
    (95) scalar -> . CONST_DECIMAL
    (96) scalar -> . CONST_DOUBLE
    (97) scalar -> . CONST_STRING
    (98) scalar -> . NULL
    (99) scalar -> . TRUE
    (100) scalar -> . FALSE
    (101) scalar -> . PLUS scalar
    (102) scalar -> . MINUS scalar
    (103) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 229
    CONST_DOUBLE    shift and go to state 230
    CONST_STRING    shift and go to state 228
    NULL            shift and go to state 226
    TRUE            shift and go to state 234
    FALSE           shift and go to state 227
    PLUS            shift and go to state 232
    MINUS           shift and go to state 235
    ARRAY           shift and go to state 233


    scalar                         shift and go to state 376

state 358

    (30) stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker . for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (31) for_expr -> . empty
    (32) for_expr -> . non_empty_for_expr
    (179) empty -> .
    (33) non_empty_for_expr -> . non_empty_for_expr COMMA expr
    (34) non_empty_for_expr -> . expr
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    RPAREN          reduce using rule 179 (empty -> .)
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    non_empty_for_expr             shift and go to state 153
    expr                           shift and go to state 155
    for_expr                       shift and go to state 377
    variable                       shift and go to state 53
    empty                          shift and go to state 154
    base_var                       shift and go to state 43

state 359

    (28) while_stmt -> COLON inner_stmts . ENDWHILE SEMICOLON
    (74) inner_stmts -> inner_stmts . jump_marker inner_stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    ENDWHILE        shift and go to state 378
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 160
    empty                          shift and go to state 68

state 360

    (26) stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .

    WHILE           reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    DO              reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    FOR             reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    FOREACH         reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    SWITCH          reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    BREAK           reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    CONTINUE        reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    RETURN          reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    GLOBAL          reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    STATIC          reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    ECHO            reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    LBRACE          reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    SEMICOLON       reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    FUNCTION        reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    CLONE           reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    ARRAY           reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    PLUS            reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    MINUS           reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    BIT_NOT         reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    NOT             reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    CONST_DECIMAL   reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    CONST_DOUBLE    reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    CONST_STRING    reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    NULL            reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    TRUE            reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    FALSE           reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    INC             reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    DEC             reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    EMPTY           reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    EVAL            reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    LPAREN          reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    INCLUDE         reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    INCLUDE_ONCE    reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    REQUIRE         reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    REQUIRE_ONCE    reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    EXIT            reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    PRINT           reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    IF              reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    IDENTIFIER      reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    STRING          reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    $end            reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    RBRACE          reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    ENDIF           reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    ELSE            reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    ELSEIF          reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    ENDWHILE        reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    ENDFOREACH      reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    CASE            reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    DEFAULT         reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    ENDSWITCH       reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)
    ENDFOR          reduce using rule 26 (stmt -> WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker .)



state 361

    (50) case_stmt -> case_stmt CASE . expr case_separator jump_marker inner_stmts
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    expr                           shift and go to state 379
    variable                       shift and go to state 53

state 362

    (45) switch_stmt -> LBRACE case_stmt RBRACE .

    WHILE           reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    DO              reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    FOR             reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    FOREACH         reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    SWITCH          reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    BREAK           reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    CONTINUE        reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    RETURN          reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    GLOBAL          reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    STATIC          reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ECHO            reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    LBRACE          reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    SEMICOLON       reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    FUNCTION        reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    CLONE           reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ARRAY           reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    PLUS            reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    MINUS           reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    BIT_NOT         reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    NOT             reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    CONST_DECIMAL   reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    CONST_DOUBLE    reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    CONST_STRING    reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    NULL            reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    TRUE            reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    FALSE           reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    INC             reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    DEC             reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    EMPTY           reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    EVAL            reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    LPAREN          reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    INCLUDE         reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    INCLUDE_ONCE    reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    REQUIRE         reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    REQUIRE_ONCE    reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    EXIT            reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    PRINT           reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    IF              reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    IDENTIFIER      reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    STRING          reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    $end            reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    RBRACE          reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ENDIF           reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ELSE            reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ELSEIF          reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ENDWHILE        reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ENDFOREACH      reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    CASE            reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    DEFAULT         reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ENDSWITCH       reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)
    ENDFOR          reduce using rule 45 (switch_stmt -> LBRACE case_stmt RBRACE .)



state 363

    (51) case_stmt -> case_stmt DEFAULT . case_separator jump_marker inner_stmts
    (52) case_separator -> . COLON
    (53) case_separator -> . SEMICOLON

    COLON           shift and go to state 382
    SEMICOLON       shift and go to state 380


    case_separator                 shift and go to state 381

state 364

    (46) switch_stmt -> LBRACE SEMICOLON case_stmt . RBRACE
    (50) case_stmt -> case_stmt . CASE expr case_separator jump_marker inner_stmts
    (51) case_stmt -> case_stmt . DEFAULT case_separator jump_marker inner_stmts

    RBRACE          shift and go to state 383
    CASE            shift and go to state 361
    DEFAULT         shift and go to state 363



state 365

    (47) switch_stmt -> COLON case_stmt ENDSWITCH . SEMICOLON

    SEMICOLON       shift and go to state 384



state 366

    (48) switch_stmt -> COLON SEMICOLON case_stmt . ENDSWITCH SEMICOLON
    (50) case_stmt -> case_stmt . CASE expr case_separator jump_marker inner_stmts
    (51) case_stmt -> case_stmt . DEFAULT case_separator jump_marker inner_stmts

    ENDSWITCH       shift and go to state 385
    CASE            shift and go to state 361
    DEFAULT         shift and go to state 363



state 367

    (119) non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW BIT_AND variable .

    COMMA           reduce using rule 119 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW BIT_AND variable .)
    RPAREN          reduce using rule 119 (non_empty_array_pair_list -> non_empty_array_pair_list COMMA expr DOUBLE_ARROW BIT_AND variable .)



state 368

    (21) if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker . stmt
    (16) stmt -> . if_stmt
    (17) stmt -> . alt_if_stmt
    (26) stmt -> . WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker
    (29) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (30) stmt -> . FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (37) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (44) stmt -> . SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker
    (54) stmt -> . BREAK goto_marker SEMICOLON
    (55) stmt -> . BREAK expr goto_marker SEMICOLON
    (56) stmt -> . CONTINUE goto_marker SEMICOLON
    (57) stmt -> . CONTINUE expr goto_marker SEMICOLON
    (58) stmt -> . RETURN SEMICOLON
    (59) stmt -> . RETURN expr SEMICOLON
    (60) stmt -> . GLOBAL global_var_list SEMICOLON
    (63) stmt -> . STATIC static_var_list SEMICOLON
    (68) stmt -> . ECHO echo_expr_list SEMICOLON
    (71) stmt -> . LBRACE inner_stmts RBRACE
    (72) stmt -> . SEMICOLON
    (73) stmt -> . expr SEMICOLON
    (18) if_stmt -> . if_stmt_without_else
    (19) if_stmt -> . if_stmt_without_else ELSE goto_marker jump_marker stmt
    (22) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (23) alt_if_stmt -> . alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (20) if_stmt_without_else -> . IF LPAREN expr RPAREN jump_marker stmt
    (21) if_stmt_without_else -> . if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON jump_marker inner_stmts
    (25) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    WHILE           shift and go to state 33
    DO              shift and go to state 49
    FOR             shift and go to state 24
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 36
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 30
    RETURN          shift and go to state 16
    GLOBAL          shift and go to state 32
    STATIC          shift and go to state 18
    ECHO            shift and go to state 27
    LBRACE          shift and go to state 29
    SEMICOLON       shift and go to state 35
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    alt_if_stmt                    shift and go to state 25
    stmt                           shift and go to state 386
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 13
    expr                           shift and go to state 45

state 369

    (161) expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr

    BIT_OR          reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .)
    BIT_XOR         reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .)
    BIT_AND         reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .)
    COND_OP         reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .)
    SEMICOLON       reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .)
    COMMA           reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .)
    RPAREN          reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .)
    AS              reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .)
    DOUBLE_ARROW    reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .)
    RBRACE          reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .)
    RBRACKET        reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .)
    COLON           reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117

  ! DOT             [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! PLUS            [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! MINUS           [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! MULT            [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! DIV             [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! MOD             [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! BIT_LSHIFT      [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! BIT_RSHIFT      [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! AND_OP          [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! OR_OP           [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! IDENTICAL       [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! NOT_IDENTICAL   [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! EQ_EQ           [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! NOT_EQ          [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! LESSER          [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! LESSER_EQ       [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! GREATER         [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! GREATER_EQ      [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! INSTANCEOF      [ reduce using rule 161 (expr -> expr COND_OP jump_marker expr goto_marker jump_marker COLON expr .) ]
  ! BIT_OR          [ shift and go to state 121 ]
  ! BIT_XOR         [ shift and go to state 104 ]
  ! BIT_AND         [ shift and go to state 114 ]
  ! COND_OP         [ shift and go to state 119 ]


state 370

    (25) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker . inner_stmts
    (74) inner_stmts -> . inner_stmts jump_marker inner_stmt
    (75) inner_stmts -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    ENDIF           reduce using rule 179 (empty -> .)
    ELSE            reduce using rule 179 (empty -> .)
    ELSEIF          reduce using rule 179 (empty -> .)


    inner_stmts                    shift and go to state 387
    empty                          shift and go to state 86

state 371

    (43) foreach_stmt -> COLON inner_stmts . ENDFOREACH SEMICOLON
    (74) inner_stmts -> inner_stmts . jump_marker inner_stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    ENDFOREACH      shift and go to state 388
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 160
    empty                          shift and go to state 68

state 372

    (108) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar DOUBLE_ARROW . scalar
    (95) scalar -> . CONST_DECIMAL
    (96) scalar -> . CONST_DOUBLE
    (97) scalar -> . CONST_STRING
    (98) scalar -> . NULL
    (99) scalar -> . TRUE
    (100) scalar -> . FALSE
    (101) scalar -> . PLUS scalar
    (102) scalar -> . MINUS scalar
    (103) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 229
    CONST_DOUBLE    shift and go to state 230
    CONST_STRING    shift and go to state 228
    NULL            shift and go to state 226
    TRUE            shift and go to state 234
    FALSE           shift and go to state 227
    PLUS            shift and go to state 232
    MINUS           shift and go to state 235
    ARRAY           shift and go to state 233


    scalar                         shift and go to state 389

state 373

    (15) param -> BIT_AND IDENTIFIER EQUAL . scalar
    (95) scalar -> . CONST_DECIMAL
    (96) scalar -> . CONST_DOUBLE
    (97) scalar -> . CONST_STRING
    (98) scalar -> . NULL
    (99) scalar -> . TRUE
    (100) scalar -> . FALSE
    (101) scalar -> . PLUS scalar
    (102) scalar -> . MINUS scalar
    (103) scalar -> . ARRAY LPAREN scalar_array_pair_list RPAREN

    CONST_DECIMAL   shift and go to state 229
    CONST_DOUBLE    shift and go to state 230
    CONST_STRING    shift and go to state 228
    NULL            shift and go to state 226
    TRUE            shift and go to state 234
    FALSE           shift and go to state 227
    PLUS            shift and go to state 232
    MINUS           shift and go to state 235
    ARRAY           shift and go to state 233


    scalar                         shift and go to state 390

state 374

    (7) func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE . inner_stmts RBRACE jump_marker
    (74) inner_stmts -> . inner_stmts jump_marker inner_stmt
    (75) inner_stmts -> . empty
    (179) empty -> .

    RBRACE          reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    inner_stmts                    shift and go to state 391
    empty                          shift and go to state 86

state 375

    (9) params -> params COMMA param .

    RPAREN          reduce using rule 9 (params -> params COMMA param .)
    COMMA           reduce using rule 9 (params -> params COMMA param .)



state 376

    (14) param -> IDENTIFIER EQUAL scalar .

    RPAREN          reduce using rule 14 (param -> IDENTIFIER EQUAL scalar .)
    COMMA           reduce using rule 14 (param -> IDENTIFIER EQUAL scalar .)



state 377

    (30) stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr . goto_marker RPAREN jump_marker for_stmt goto_marker
    (178) goto_marker -> . empty
    (179) empty -> .

    RPAREN          reduce using rule 179 (empty -> .)


    goto_marker                    shift and go to state 392
    empty                          shift and go to state 80

state 378

    (28) while_stmt -> COLON inner_stmts ENDWHILE . SEMICOLON

    SEMICOLON       shift and go to state 393



state 379

    (50) case_stmt -> case_stmt CASE expr . case_separator jump_marker inner_stmts
    (129) expr -> expr . DOT expr
    (130) expr -> expr . PLUS expr
    (131) expr -> expr . MINUS expr
    (132) expr -> expr . MULT expr
    (133) expr -> expr . DIV expr
    (134) expr -> expr . MOD expr
    (135) expr -> expr . BIT_OR expr
    (136) expr -> expr . BIT_XOR expr
    (137) expr -> expr . BIT_AND expr
    (138) expr -> expr . BIT_LSHIFT expr
    (139) expr -> expr . BIT_RSHIFT expr
    (140) expr -> expr . AND_OP jump_marker expr
    (141) expr -> expr . OR_OP jump_marker expr
    (142) expr -> expr . IDENTICAL expr
    (143) expr -> expr . NOT_IDENTICAL expr
    (144) expr -> expr . EQ_EQ expr
    (145) expr -> expr . NOT_EQ expr
    (146) expr -> expr . LESSER expr
    (147) expr -> expr . LESSER_EQ expr
    (148) expr -> expr . GREATER expr
    (149) expr -> expr . GREATER_EQ expr
    (150) expr -> expr . INSTANCEOF expr
    (161) expr -> expr . COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (52) case_separator -> . COLON
    (53) case_separator -> . SEMICOLON

    DOT             shift and go to state 106
    PLUS            shift and go to state 110
    MINUS           shift and go to state 105
    MULT            shift and go to state 111
    DIV             shift and go to state 103
    MOD             shift and go to state 124
    BIT_OR          shift and go to state 121
    BIT_XOR         shift and go to state 104
    BIT_AND         shift and go to state 114
    BIT_LSHIFT      shift and go to state 123
    BIT_RSHIFT      shift and go to state 120
    AND_OP          shift and go to state 116
    OR_OP           shift and go to state 109
    IDENTICAL       shift and go to state 107
    NOT_IDENTICAL   shift and go to state 113
    EQ_EQ           shift and go to state 101
    NOT_EQ          shift and go to state 112
    LESSER          shift and go to state 122
    LESSER_EQ       shift and go to state 115
    GREATER         shift and go to state 118
    GREATER_EQ      shift and go to state 102
    INSTANCEOF      shift and go to state 117
    COND_OP         shift and go to state 119
    COLON           shift and go to state 382
    SEMICOLON       shift and go to state 380


    case_separator                 shift and go to state 394

state 380

    (53) case_separator -> SEMICOLON .

    WHILE           reduce using rule 53 (case_separator -> SEMICOLON .)
    DO              reduce using rule 53 (case_separator -> SEMICOLON .)
    FOR             reduce using rule 53 (case_separator -> SEMICOLON .)
    FOREACH         reduce using rule 53 (case_separator -> SEMICOLON .)
    SWITCH          reduce using rule 53 (case_separator -> SEMICOLON .)
    BREAK           reduce using rule 53 (case_separator -> SEMICOLON .)
    CONTINUE        reduce using rule 53 (case_separator -> SEMICOLON .)
    RETURN          reduce using rule 53 (case_separator -> SEMICOLON .)
    GLOBAL          reduce using rule 53 (case_separator -> SEMICOLON .)
    STATIC          reduce using rule 53 (case_separator -> SEMICOLON .)
    ECHO            reduce using rule 53 (case_separator -> SEMICOLON .)
    LBRACE          reduce using rule 53 (case_separator -> SEMICOLON .)
    SEMICOLON       reduce using rule 53 (case_separator -> SEMICOLON .)
    FUNCTION        reduce using rule 53 (case_separator -> SEMICOLON .)
    CLONE           reduce using rule 53 (case_separator -> SEMICOLON .)
    ARRAY           reduce using rule 53 (case_separator -> SEMICOLON .)
    PLUS            reduce using rule 53 (case_separator -> SEMICOLON .)
    MINUS           reduce using rule 53 (case_separator -> SEMICOLON .)
    BIT_NOT         reduce using rule 53 (case_separator -> SEMICOLON .)
    NOT             reduce using rule 53 (case_separator -> SEMICOLON .)
    CONST_DECIMAL   reduce using rule 53 (case_separator -> SEMICOLON .)
    CONST_DOUBLE    reduce using rule 53 (case_separator -> SEMICOLON .)
    CONST_STRING    reduce using rule 53 (case_separator -> SEMICOLON .)
    NULL            reduce using rule 53 (case_separator -> SEMICOLON .)
    TRUE            reduce using rule 53 (case_separator -> SEMICOLON .)
    FALSE           reduce using rule 53 (case_separator -> SEMICOLON .)
    INC             reduce using rule 53 (case_separator -> SEMICOLON .)
    DEC             reduce using rule 53 (case_separator -> SEMICOLON .)
    EMPTY           reduce using rule 53 (case_separator -> SEMICOLON .)
    EVAL            reduce using rule 53 (case_separator -> SEMICOLON .)
    LPAREN          reduce using rule 53 (case_separator -> SEMICOLON .)
    INCLUDE         reduce using rule 53 (case_separator -> SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 53 (case_separator -> SEMICOLON .)
    REQUIRE         reduce using rule 53 (case_separator -> SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 53 (case_separator -> SEMICOLON .)
    EXIT            reduce using rule 53 (case_separator -> SEMICOLON .)
    PRINT           reduce using rule 53 (case_separator -> SEMICOLON .)
    IF              reduce using rule 53 (case_separator -> SEMICOLON .)
    IDENTIFIER      reduce using rule 53 (case_separator -> SEMICOLON .)
    STRING          reduce using rule 53 (case_separator -> SEMICOLON .)
    RBRACE          reduce using rule 53 (case_separator -> SEMICOLON .)
    CASE            reduce using rule 53 (case_separator -> SEMICOLON .)
    DEFAULT         reduce using rule 53 (case_separator -> SEMICOLON .)
    ENDSWITCH       reduce using rule 53 (case_separator -> SEMICOLON .)



state 381

    (51) case_stmt -> case_stmt DEFAULT case_separator . jump_marker inner_stmts
    (177) jump_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    RBRACE          reduce using rule 179 (empty -> .)
    CASE            reduce using rule 179 (empty -> .)
    DEFAULT         reduce using rule 179 (empty -> .)
    ENDSWITCH       reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 395
    empty                          shift and go to state 68

state 382

    (52) case_separator -> COLON .

    WHILE           reduce using rule 52 (case_separator -> COLON .)
    DO              reduce using rule 52 (case_separator -> COLON .)
    FOR             reduce using rule 52 (case_separator -> COLON .)
    FOREACH         reduce using rule 52 (case_separator -> COLON .)
    SWITCH          reduce using rule 52 (case_separator -> COLON .)
    BREAK           reduce using rule 52 (case_separator -> COLON .)
    CONTINUE        reduce using rule 52 (case_separator -> COLON .)
    RETURN          reduce using rule 52 (case_separator -> COLON .)
    GLOBAL          reduce using rule 52 (case_separator -> COLON .)
    STATIC          reduce using rule 52 (case_separator -> COLON .)
    ECHO            reduce using rule 52 (case_separator -> COLON .)
    LBRACE          reduce using rule 52 (case_separator -> COLON .)
    SEMICOLON       reduce using rule 52 (case_separator -> COLON .)
    FUNCTION        reduce using rule 52 (case_separator -> COLON .)
    CLONE           reduce using rule 52 (case_separator -> COLON .)
    ARRAY           reduce using rule 52 (case_separator -> COLON .)
    PLUS            reduce using rule 52 (case_separator -> COLON .)
    MINUS           reduce using rule 52 (case_separator -> COLON .)
    BIT_NOT         reduce using rule 52 (case_separator -> COLON .)
    NOT             reduce using rule 52 (case_separator -> COLON .)
    CONST_DECIMAL   reduce using rule 52 (case_separator -> COLON .)
    CONST_DOUBLE    reduce using rule 52 (case_separator -> COLON .)
    CONST_STRING    reduce using rule 52 (case_separator -> COLON .)
    NULL            reduce using rule 52 (case_separator -> COLON .)
    TRUE            reduce using rule 52 (case_separator -> COLON .)
    FALSE           reduce using rule 52 (case_separator -> COLON .)
    INC             reduce using rule 52 (case_separator -> COLON .)
    DEC             reduce using rule 52 (case_separator -> COLON .)
    EMPTY           reduce using rule 52 (case_separator -> COLON .)
    EVAL            reduce using rule 52 (case_separator -> COLON .)
    LPAREN          reduce using rule 52 (case_separator -> COLON .)
    INCLUDE         reduce using rule 52 (case_separator -> COLON .)
    INCLUDE_ONCE    reduce using rule 52 (case_separator -> COLON .)
    REQUIRE         reduce using rule 52 (case_separator -> COLON .)
    REQUIRE_ONCE    reduce using rule 52 (case_separator -> COLON .)
    EXIT            reduce using rule 52 (case_separator -> COLON .)
    PRINT           reduce using rule 52 (case_separator -> COLON .)
    IF              reduce using rule 52 (case_separator -> COLON .)
    IDENTIFIER      reduce using rule 52 (case_separator -> COLON .)
    STRING          reduce using rule 52 (case_separator -> COLON .)
    RBRACE          reduce using rule 52 (case_separator -> COLON .)
    CASE            reduce using rule 52 (case_separator -> COLON .)
    DEFAULT         reduce using rule 52 (case_separator -> COLON .)
    ENDSWITCH       reduce using rule 52 (case_separator -> COLON .)



state 383

    (46) switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .

    WHILE           reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    DO              reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    FOR             reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    FOREACH         reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    SWITCH          reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    BREAK           reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    CONTINUE        reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    RETURN          reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    GLOBAL          reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    STATIC          reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ECHO            reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    LBRACE          reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    SEMICOLON       reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    FUNCTION        reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    CLONE           reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ARRAY           reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    PLUS            reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    MINUS           reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    BIT_NOT         reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    NOT             reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    CONST_DECIMAL   reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    CONST_DOUBLE    reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    CONST_STRING    reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    NULL            reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    TRUE            reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    FALSE           reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    INC             reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    DEC             reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    EMPTY           reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    EVAL            reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    LPAREN          reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    INCLUDE         reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    INCLUDE_ONCE    reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    REQUIRE         reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    REQUIRE_ONCE    reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    EXIT            reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    PRINT           reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    IF              reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    IDENTIFIER      reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    STRING          reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    $end            reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    RBRACE          reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ENDIF           reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ELSE            reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ELSEIF          reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ENDWHILE        reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ENDFOREACH      reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    CASE            reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    DEFAULT         reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ENDSWITCH       reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)
    ENDFOR          reduce using rule 46 (switch_stmt -> LBRACE SEMICOLON case_stmt RBRACE .)



state 384

    (47) switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .

    WHILE           reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    DO              reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    FOR             reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    FOREACH         reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    SWITCH          reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    BREAK           reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    CONTINUE        reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    RETURN          reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    GLOBAL          reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    STATIC          reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ECHO            reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    LBRACE          reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    SEMICOLON       reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    FUNCTION        reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    CLONE           reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ARRAY           reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    PLUS            reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    MINUS           reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    BIT_NOT         reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    NOT             reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    CONST_DECIMAL   reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    CONST_DOUBLE    reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    CONST_STRING    reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    NULL            reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    TRUE            reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    FALSE           reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    INC             reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    DEC             reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    EMPTY           reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    EVAL            reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    LPAREN          reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    INCLUDE         reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    REQUIRE         reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    EXIT            reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    PRINT           reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    IF              reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    IDENTIFIER      reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    STRING          reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    $end            reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    RBRACE          reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ENDIF           reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ELSE            reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ELSEIF          reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ENDWHILE        reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ENDFOREACH      reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    CASE            reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    DEFAULT         reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ENDSWITCH       reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)
    ENDFOR          reduce using rule 47 (switch_stmt -> COLON case_stmt ENDSWITCH SEMICOLON .)



state 385

    (48) switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH . SEMICOLON

    SEMICOLON       shift and go to state 396



state 386

    (21) if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .

    WHILE           reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    DO              reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    FOR             reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    FOREACH         reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    SWITCH          reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    BREAK           reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    CONTINUE        reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    RETURN          reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    GLOBAL          reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    STATIC          reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    ECHO            reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    LBRACE          reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    SEMICOLON       reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    FUNCTION        reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    CLONE           reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    ARRAY           reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    PLUS            reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    MINUS           reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    BIT_NOT         reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    NOT             reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    CONST_DECIMAL   reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    CONST_DOUBLE    reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    CONST_STRING    reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    NULL            reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    TRUE            reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    FALSE           reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    INC             reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    DEC             reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    EMPTY           reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    EVAL            reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    LPAREN          reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    INCLUDE         reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    INCLUDE_ONCE    reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    REQUIRE         reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    REQUIRE_ONCE    reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    EXIT            reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    PRINT           reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    IF              reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    IDENTIFIER      reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    STRING          reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    $end            reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    RBRACE          reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    ENDIF           reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    ELSE            reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    ELSEIF          reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    ENDWHILE        reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    ENDFOREACH      reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    CASE            reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    DEFAULT         reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    ENDSWITCH       reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)
    ENDFOR          reduce using rule 21 (if_stmt_without_else -> if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt .)



state 387

    (25) alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts .
    (74) inner_stmts -> inner_stmts . jump_marker inner_stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    ENDIF           reduce using rule 25 (alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts .)
    ELSE            reduce using rule 25 (alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts .)
    ELSEIF          reduce using rule 25 (alt_if_stmt_without_else -> alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts .)
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 160
    empty                          shift and go to state 68

state 388

    (43) foreach_stmt -> COLON inner_stmts ENDFOREACH . SEMICOLON

    SEMICOLON       shift and go to state 397



state 389

    (108) scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar DOUBLE_ARROW scalar .

    COMMA           reduce using rule 108 (scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar DOUBLE_ARROW scalar .)
    RPAREN          reduce using rule 108 (scalar_non_empty_array_pair_list -> scalar_non_empty_array_pair_list COMMA scalar DOUBLE_ARROW scalar .)



state 390

    (15) param -> BIT_AND IDENTIFIER EQUAL scalar .

    RPAREN          reduce using rule 15 (param -> BIT_AND IDENTIFIER EQUAL scalar .)
    COMMA           reduce using rule 15 (param -> BIT_AND IDENTIFIER EQUAL scalar .)



state 391

    (7) func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts . RBRACE jump_marker
    (74) inner_stmts -> inner_stmts . jump_marker inner_stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    RBRACE          shift and go to state 398
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 160
    empty                          shift and go to state 68

state 392

    (30) stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker . RPAREN jump_marker for_stmt goto_marker

    RPAREN          shift and go to state 399



state 393

    (28) while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .

    WHILE           reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    DO              reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    FOR             reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    FOREACH         reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    SWITCH          reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    BREAK           reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    CONTINUE        reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    RETURN          reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    GLOBAL          reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    STATIC          reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ECHO            reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    LBRACE          reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    SEMICOLON       reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    FUNCTION        reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    CLONE           reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ARRAY           reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    PLUS            reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    MINUS           reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    BIT_NOT         reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    NOT             reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    CONST_DECIMAL   reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    CONST_DOUBLE    reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    CONST_STRING    reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    NULL            reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    TRUE            reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    FALSE           reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    INC             reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    DEC             reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    EMPTY           reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    EVAL            reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    LPAREN          reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    INCLUDE         reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    REQUIRE         reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    EXIT            reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    PRINT           reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    IF              reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    IDENTIFIER      reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    STRING          reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    $end            reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    RBRACE          reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ENDIF           reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ELSE            reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ELSEIF          reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ENDWHILE        reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ENDFOREACH      reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    CASE            reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    DEFAULT         reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ENDSWITCH       reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)
    ENDFOR          reduce using rule 28 (while_stmt -> COLON inner_stmts ENDWHILE SEMICOLON .)



state 394

    (50) case_stmt -> case_stmt CASE expr case_separator . jump_marker inner_stmts
    (177) jump_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    RBRACE          reduce using rule 179 (empty -> .)
    CASE            reduce using rule 179 (empty -> .)
    DEFAULT         reduce using rule 179 (empty -> .)
    ENDSWITCH       reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 400
    empty                          shift and go to state 68

state 395

    (51) case_stmt -> case_stmt DEFAULT case_separator jump_marker . inner_stmts
    (74) inner_stmts -> . inner_stmts jump_marker inner_stmt
    (75) inner_stmts -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    RBRACE          reduce using rule 179 (empty -> .)
    CASE            reduce using rule 179 (empty -> .)
    DEFAULT         reduce using rule 179 (empty -> .)
    ENDSWITCH       reduce using rule 179 (empty -> .)


    inner_stmts                    shift and go to state 401
    empty                          shift and go to state 86

state 396

    (48) switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .

    WHILE           reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    DO              reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    FOR             reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    FOREACH         reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    SWITCH          reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    BREAK           reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    CONTINUE        reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    RETURN          reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    GLOBAL          reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    STATIC          reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ECHO            reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    LBRACE          reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    SEMICOLON       reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    FUNCTION        reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    CLONE           reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ARRAY           reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    PLUS            reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    MINUS           reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    BIT_NOT         reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    NOT             reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    CONST_DECIMAL   reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    CONST_DOUBLE    reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    CONST_STRING    reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    NULL            reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    TRUE            reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    FALSE           reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    INC             reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    DEC             reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    EMPTY           reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    EVAL            reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    LPAREN          reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    INCLUDE         reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    REQUIRE         reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    EXIT            reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    PRINT           reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    IF              reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    IDENTIFIER      reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    STRING          reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    $end            reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    RBRACE          reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ENDIF           reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ELSE            reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ELSEIF          reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ENDWHILE        reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ENDFOREACH      reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    CASE            reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    DEFAULT         reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ENDSWITCH       reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)
    ENDFOR          reduce using rule 48 (switch_stmt -> COLON SEMICOLON case_stmt ENDSWITCH SEMICOLON .)



state 397

    (43) foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .

    WHILE           reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    DO              reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    FOR             reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    FOREACH         reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    SWITCH          reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    BREAK           reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    CONTINUE        reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    RETURN          reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    GLOBAL          reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    STATIC          reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ECHO            reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    LBRACE          reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    SEMICOLON       reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    FUNCTION        reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    CLONE           reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ARRAY           reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    PLUS            reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    MINUS           reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    BIT_NOT         reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    NOT             reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    CONST_DECIMAL   reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    CONST_DOUBLE    reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    CONST_STRING    reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    NULL            reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    TRUE            reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    FALSE           reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    INC             reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    DEC             reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    EMPTY           reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    EVAL            reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    LPAREN          reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    INCLUDE         reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    REQUIRE         reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    EXIT            reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    PRINT           reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    IF              reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    IDENTIFIER      reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    STRING          reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    $end            reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    RBRACE          reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ENDIF           reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ELSE            reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ELSEIF          reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ENDWHILE        reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ENDFOREACH      reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    CASE            reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    DEFAULT         reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ENDSWITCH       reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)
    ENDFOR          reduce using rule 43 (foreach_stmt -> COLON inner_stmts ENDFOREACH SEMICOLON .)



state 398

    (7) func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE . jump_marker
    (177) jump_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    $end            reduce using rule 179 (empty -> .)
    RBRACE          reduce using rule 179 (empty -> .)
    ENDIF           reduce using rule 179 (empty -> .)
    ELSE            reduce using rule 179 (empty -> .)
    ELSEIF          reduce using rule 179 (empty -> .)
    ENDWHILE        reduce using rule 179 (empty -> .)
    ENDFOREACH      reduce using rule 179 (empty -> .)
    CASE            reduce using rule 179 (empty -> .)
    DEFAULT         reduce using rule 179 (empty -> .)
    ENDSWITCH       reduce using rule 179 (empty -> .)
    ENDFOR          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 402
    empty                          shift and go to state 68

state 399

    (30) stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN . jump_marker for_stmt goto_marker
    (177) jump_marker -> . empty
    (179) empty -> .

    COLON           reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 403
    empty                          shift and go to state 68

state 400

    (50) case_stmt -> case_stmt CASE expr case_separator jump_marker . inner_stmts
    (74) inner_stmts -> . inner_stmts jump_marker inner_stmt
    (75) inner_stmts -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    RBRACE          reduce using rule 179 (empty -> .)
    CASE            reduce using rule 179 (empty -> .)
    DEFAULT         reduce using rule 179 (empty -> .)
    ENDSWITCH       reduce using rule 179 (empty -> .)


    inner_stmts                    shift and go to state 404
    empty                          shift and go to state 86

state 401

    (51) case_stmt -> case_stmt DEFAULT case_separator jump_marker inner_stmts .
    (74) inner_stmts -> inner_stmts . jump_marker inner_stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    RBRACE          reduce using rule 51 (case_stmt -> case_stmt DEFAULT case_separator jump_marker inner_stmts .)
    CASE            reduce using rule 51 (case_stmt -> case_stmt DEFAULT case_separator jump_marker inner_stmts .)
    DEFAULT         reduce using rule 51 (case_stmt -> case_stmt DEFAULT case_separator jump_marker inner_stmts .)
    ENDSWITCH       reduce using rule 51 (case_stmt -> case_stmt DEFAULT case_separator jump_marker inner_stmts .)
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 160
    empty                          shift and go to state 68

state 402

    (7) func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .

    RBRACE          reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    WHILE           reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    DO              reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    FOR             reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    FOREACH         reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    SWITCH          reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    BREAK           reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    CONTINUE        reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    RETURN          reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    GLOBAL          reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    STATIC          reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    ECHO            reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    LBRACE          reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    SEMICOLON       reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    FUNCTION        reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    CLONE           reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    ARRAY           reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    PLUS            reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    MINUS           reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    BIT_NOT         reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    NOT             reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    CONST_DECIMAL   reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    CONST_DOUBLE    reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    CONST_STRING    reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    NULL            reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    TRUE            reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    FALSE           reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    INC             reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    DEC             reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    EMPTY           reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    EVAL            reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    LPAREN          reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    INCLUDE         reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    INCLUDE_ONCE    reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    REQUIRE         reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    REQUIRE_ONCE    reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    EXIT            reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    PRINT           reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    IF              reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    IDENTIFIER      reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    STRING          reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    ENDIF           reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    ELSE            reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    ELSEIF          reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    ENDWHILE        reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    ENDFOREACH      reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    CASE            reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    DEFAULT         reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    ENDSWITCH       reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    ENDFOR          reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)
    $end            reduce using rule 7 (func_decl -> FUNCTION goto_marker STRING func_table_marker LPAREN jump_marker params RPAREN LBRACE inner_stmts RBRACE jump_marker .)



state 403

    (30) stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker . for_stmt goto_marker
    (35) for_stmt -> . stmt
    (36) for_stmt -> . COLON inner_stmts ENDFOR SEMICOLON
    (16) stmt -> . if_stmt
    (17) stmt -> . alt_if_stmt
    (26) stmt -> . WHILE LPAREN jump_marker expr jump_marker RPAREN while_stmt goto_marker
    (29) stmt -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (30) stmt -> . FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker
    (37) stmt -> . FOREACH LPAREN expr AS foreach_var foreach_arg RPAREN foreach_stmt
    (44) stmt -> . SWITCH LPAREN expr RPAREN goto_marker switch_stmt jump_marker
    (54) stmt -> . BREAK goto_marker SEMICOLON
    (55) stmt -> . BREAK expr goto_marker SEMICOLON
    (56) stmt -> . CONTINUE goto_marker SEMICOLON
    (57) stmt -> . CONTINUE expr goto_marker SEMICOLON
    (58) stmt -> . RETURN SEMICOLON
    (59) stmt -> . RETURN expr SEMICOLON
    (60) stmt -> . GLOBAL global_var_list SEMICOLON
    (63) stmt -> . STATIC static_var_list SEMICOLON
    (68) stmt -> . ECHO echo_expr_list SEMICOLON
    (71) stmt -> . LBRACE inner_stmts RBRACE
    (72) stmt -> . SEMICOLON
    (73) stmt -> . expr SEMICOLON
    (18) if_stmt -> . if_stmt_without_else
    (19) if_stmt -> . if_stmt_without_else ELSE goto_marker jump_marker stmt
    (22) alt_if_stmt -> . alt_if_stmt_without_else ENDIF SEMICOLON
    (23) alt_if_stmt -> . alt_if_stmt_without_else ELSE goto_marker jump_marker COLON inner_stmts ENDIF SEMICOLON
    (78) expr -> . variable
    (92) expr -> . base_var EQUAL expr
    (93) expr -> . base_var EQUAL BIT_AND expr
    (94) expr -> . CLONE expr
    (110) expr -> . ARRAY LPAREN array_pair_list RPAREN
    (123) expr -> . variable PLUS_EQ expr
    (124) expr -> . variable MINUS_EQ expr
    (125) expr -> . variable MULTIPLY_EQ expr
    (126) expr -> . variable DIVIDE_EQ expr
    (127) expr -> . variable DOT_EQ expr
    (128) expr -> . variable MOD_EQ expr
    (129) expr -> . expr DOT expr
    (130) expr -> . expr PLUS expr
    (131) expr -> . expr MINUS expr
    (132) expr -> . expr MULT expr
    (133) expr -> . expr DIV expr
    (134) expr -> . expr MOD expr
    (135) expr -> . expr BIT_OR expr
    (136) expr -> . expr BIT_XOR expr
    (137) expr -> . expr BIT_AND expr
    (138) expr -> . expr BIT_LSHIFT expr
    (139) expr -> . expr BIT_RSHIFT expr
    (140) expr -> . expr AND_OP jump_marker expr
    (141) expr -> . expr OR_OP jump_marker expr
    (142) expr -> . expr IDENTICAL expr
    (143) expr -> . expr NOT_IDENTICAL expr
    (144) expr -> . expr EQ_EQ expr
    (145) expr -> . expr NOT_EQ expr
    (146) expr -> . expr LESSER expr
    (147) expr -> . expr LESSER_EQ expr
    (148) expr -> . expr GREATER expr
    (149) expr -> . expr GREATER_EQ expr
    (150) expr -> . expr INSTANCEOF expr
    (151) expr -> . PLUS expr
    (152) expr -> . MINUS expr
    (153) expr -> . BIT_NOT expr
    (154) expr -> . NOT expr
    (155) expr -> . CONST_DECIMAL
    (156) expr -> . CONST_DOUBLE
    (157) expr -> . CONST_STRING
    (158) expr -> . NULL
    (159) expr -> . TRUE
    (160) expr -> . FALSE
    (161) expr -> . expr COND_OP jump_marker expr goto_marker jump_marker COLON expr
    (162) expr -> . INC variable
    (163) expr -> . DEC variable
    (164) expr -> . variable INC
    (165) expr -> . variable DEC
    (166) expr -> . EMPTY LPAREN expr RPAREN
    (167) expr -> . EVAL LPAREN expr RPAREN
    (168) expr -> . LPAREN expr RPAREN
    (169) expr -> . INCLUDE expr
    (170) expr -> . INCLUDE_ONCE expr
    (171) expr -> . REQUIRE expr
    (172) expr -> . REQUIRE_ONCE expr
    (173) expr -> . EXIT
    (174) expr -> . EXIT LPAREN RPAREN
    (175) expr -> . EXIT LPAREN expr RPAREN
    (176) expr -> . PRINT expr
    (20) if_stmt_without_else -> . IF LPAREN expr RPAREN jump_marker stmt
    (21) if_stmt_without_else -> . if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN jump_marker stmt
    (24) alt_if_stmt_without_else -> . IF LPAREN expr RPAREN COLON jump_marker inner_stmts
    (25) alt_if_stmt_without_else -> . alt_if_stmt_without_else ELSEIF goto_marker LPAREN jump_marker expr RPAREN COLON jump_marker inner_stmts
    (79) variable -> . base_var
    (80) variable -> . func_call
    (87) base_var -> . base_var LBRACKET dim_offset RBRACKET
    (88) base_var -> . base_var LBRACE expr RBRACE
    (89) base_var -> . IDENTIFIER
    (81) func_call -> . STRING LPAREN func_params RPAREN

    COLON           shift and go to state 406
    WHILE           shift and go to state 33
    DO              shift and go to state 49
    FOR             shift and go to state 24
    FOREACH         shift and go to state 10
    SWITCH          shift and go to state 36
    BREAK           shift and go to state 47
    CONTINUE        shift and go to state 30
    RETURN          shift and go to state 16
    GLOBAL          shift and go to state 32
    STATIC          shift and go to state 18
    ECHO            shift and go to state 27
    LBRACE          shift and go to state 29
    SEMICOLON       shift and go to state 35
    CLONE           shift and go to state 14
    ARRAY           shift and go to state 37
    PLUS            shift and go to state 8
    MINUS           shift and go to state 6
    BIT_NOT         shift and go to state 9
    NOT             shift and go to state 31
    CONST_DECIMAL   shift and go to state 7
    CONST_DOUBLE    shift and go to state 22
    CONST_STRING    shift and go to state 46
    NULL            shift and go to state 50
    TRUE            shift and go to state 5
    FALSE           shift and go to state 44
    INC             shift and go to state 56
    DEC             shift and go to state 20
    EMPTY           shift and go to state 21
    EVAL            shift and go to state 11
    LPAREN          shift and go to state 52
    INCLUDE         shift and go to state 34
    INCLUDE_ONCE    shift and go to state 12
    REQUIRE         shift and go to state 17
    REQUIRE_ONCE    shift and go to state 28
    EXIT            shift and go to state 48
    PRINT           shift and go to state 19
    IF              shift and go to state 54
    IDENTIFIER      shift and go to state 38
    STRING          shift and go to state 51


    alt_if_stmt_without_else       shift and go to state 4
    alt_if_stmt                    shift and go to state 25
    stmt                           shift and go to state 407
    for_stmt                       shift and go to state 405
    variable                       shift and go to state 53
    if_stmt_without_else           shift and go to state 42
    func_call                      shift and go to state 40
    base_var                       shift and go to state 43
    if_stmt                        shift and go to state 13
    expr                           shift and go to state 45

state 404

    (50) case_stmt -> case_stmt CASE expr case_separator jump_marker inner_stmts .
    (74) inner_stmts -> inner_stmts . jump_marker inner_stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    RBRACE          reduce using rule 50 (case_stmt -> case_stmt CASE expr case_separator jump_marker inner_stmts .)
    CASE            reduce using rule 50 (case_stmt -> case_stmt CASE expr case_separator jump_marker inner_stmts .)
    DEFAULT         reduce using rule 50 (case_stmt -> case_stmt CASE expr case_separator jump_marker inner_stmts .)
    ENDSWITCH       reduce using rule 50 (case_stmt -> case_stmt CASE expr case_separator jump_marker inner_stmts .)
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 160
    empty                          shift and go to state 68

state 405

    (30) stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt . goto_marker
    (178) goto_marker -> . empty
    (179) empty -> .

    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)
    $end            reduce using rule 179 (empty -> .)
    RBRACE          reduce using rule 179 (empty -> .)
    ENDIF           reduce using rule 179 (empty -> .)
    ELSE            reduce using rule 179 (empty -> .)
    ELSEIF          reduce using rule 179 (empty -> .)
    ENDWHILE        reduce using rule 179 (empty -> .)
    ENDFOREACH      reduce using rule 179 (empty -> .)
    CASE            reduce using rule 179 (empty -> .)
    DEFAULT         reduce using rule 179 (empty -> .)
    ENDSWITCH       reduce using rule 179 (empty -> .)
    ENDFOR          reduce using rule 179 (empty -> .)


    goto_marker                    shift and go to state 408
    empty                          shift and go to state 80

state 406

    (36) for_stmt -> COLON . inner_stmts ENDFOR SEMICOLON
    (74) inner_stmts -> . inner_stmts jump_marker inner_stmt
    (75) inner_stmts -> . empty
    (179) empty -> .

    ENDFOR          reduce using rule 179 (empty -> .)
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    inner_stmts                    shift and go to state 409
    empty                          shift and go to state 86

state 407

    (35) for_stmt -> stmt .

    WHILE           reduce using rule 35 (for_stmt -> stmt .)
    DO              reduce using rule 35 (for_stmt -> stmt .)
    FOR             reduce using rule 35 (for_stmt -> stmt .)
    FOREACH         reduce using rule 35 (for_stmt -> stmt .)
    SWITCH          reduce using rule 35 (for_stmt -> stmt .)
    BREAK           reduce using rule 35 (for_stmt -> stmt .)
    CONTINUE        reduce using rule 35 (for_stmt -> stmt .)
    RETURN          reduce using rule 35 (for_stmt -> stmt .)
    GLOBAL          reduce using rule 35 (for_stmt -> stmt .)
    STATIC          reduce using rule 35 (for_stmt -> stmt .)
    ECHO            reduce using rule 35 (for_stmt -> stmt .)
    LBRACE          reduce using rule 35 (for_stmt -> stmt .)
    SEMICOLON       reduce using rule 35 (for_stmt -> stmt .)
    FUNCTION        reduce using rule 35 (for_stmt -> stmt .)
    CLONE           reduce using rule 35 (for_stmt -> stmt .)
    ARRAY           reduce using rule 35 (for_stmt -> stmt .)
    PLUS            reduce using rule 35 (for_stmt -> stmt .)
    MINUS           reduce using rule 35 (for_stmt -> stmt .)
    BIT_NOT         reduce using rule 35 (for_stmt -> stmt .)
    NOT             reduce using rule 35 (for_stmt -> stmt .)
    CONST_DECIMAL   reduce using rule 35 (for_stmt -> stmt .)
    CONST_DOUBLE    reduce using rule 35 (for_stmt -> stmt .)
    CONST_STRING    reduce using rule 35 (for_stmt -> stmt .)
    NULL            reduce using rule 35 (for_stmt -> stmt .)
    TRUE            reduce using rule 35 (for_stmt -> stmt .)
    FALSE           reduce using rule 35 (for_stmt -> stmt .)
    INC             reduce using rule 35 (for_stmt -> stmt .)
    DEC             reduce using rule 35 (for_stmt -> stmt .)
    EMPTY           reduce using rule 35 (for_stmt -> stmt .)
    EVAL            reduce using rule 35 (for_stmt -> stmt .)
    LPAREN          reduce using rule 35 (for_stmt -> stmt .)
    INCLUDE         reduce using rule 35 (for_stmt -> stmt .)
    INCLUDE_ONCE    reduce using rule 35 (for_stmt -> stmt .)
    REQUIRE         reduce using rule 35 (for_stmt -> stmt .)
    REQUIRE_ONCE    reduce using rule 35 (for_stmt -> stmt .)
    EXIT            reduce using rule 35 (for_stmt -> stmt .)
    PRINT           reduce using rule 35 (for_stmt -> stmt .)
    IF              reduce using rule 35 (for_stmt -> stmt .)
    IDENTIFIER      reduce using rule 35 (for_stmt -> stmt .)
    STRING          reduce using rule 35 (for_stmt -> stmt .)
    $end            reduce using rule 35 (for_stmt -> stmt .)
    RBRACE          reduce using rule 35 (for_stmt -> stmt .)
    ENDIF           reduce using rule 35 (for_stmt -> stmt .)
    ELSE            reduce using rule 35 (for_stmt -> stmt .)
    ELSEIF          reduce using rule 35 (for_stmt -> stmt .)
    ENDWHILE        reduce using rule 35 (for_stmt -> stmt .)
    ENDFOREACH      reduce using rule 35 (for_stmt -> stmt .)
    CASE            reduce using rule 35 (for_stmt -> stmt .)
    DEFAULT         reduce using rule 35 (for_stmt -> stmt .)
    ENDSWITCH       reduce using rule 35 (for_stmt -> stmt .)
    ENDFOR          reduce using rule 35 (for_stmt -> stmt .)



state 408

    (30) stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .

    WHILE           reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    DO              reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    FOR             reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    FOREACH         reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    SWITCH          reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    BREAK           reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    CONTINUE        reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    RETURN          reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    GLOBAL          reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    STATIC          reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    ECHO            reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    LBRACE          reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    SEMICOLON       reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    FUNCTION        reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    CLONE           reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    ARRAY           reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    PLUS            reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    MINUS           reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    BIT_NOT         reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    NOT             reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    CONST_DECIMAL   reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    CONST_DOUBLE    reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    CONST_STRING    reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    NULL            reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    TRUE            reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    FALSE           reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    INC             reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    DEC             reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    EMPTY           reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    EVAL            reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    LPAREN          reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    INCLUDE         reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    INCLUDE_ONCE    reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    REQUIRE         reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    REQUIRE_ONCE    reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    EXIT            reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    PRINT           reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    IF              reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    IDENTIFIER      reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    STRING          reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    $end            reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    RBRACE          reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    ENDIF           reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    ELSE            reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    ELSEIF          reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    ENDWHILE        reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    ENDFOREACH      reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    CASE            reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    DEFAULT         reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    ENDSWITCH       reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)
    ENDFOR          reduce using rule 30 (stmt -> FOR LPAREN for_expr SEMICOLON jump_marker for_expr SEMICOLON jump_marker for_expr goto_marker RPAREN jump_marker for_stmt goto_marker .)



state 409

    (36) for_stmt -> COLON inner_stmts . ENDFOR SEMICOLON
    (74) inner_stmts -> inner_stmts . jump_marker inner_stmt
    (177) jump_marker -> . empty
    (179) empty -> .

    ENDFOR          shift and go to state 410
    WHILE           reduce using rule 179 (empty -> .)
    DO              reduce using rule 179 (empty -> .)
    FOR             reduce using rule 179 (empty -> .)
    FOREACH         reduce using rule 179 (empty -> .)
    SWITCH          reduce using rule 179 (empty -> .)
    BREAK           reduce using rule 179 (empty -> .)
    CONTINUE        reduce using rule 179 (empty -> .)
    RETURN          reduce using rule 179 (empty -> .)
    GLOBAL          reduce using rule 179 (empty -> .)
    STATIC          reduce using rule 179 (empty -> .)
    ECHO            reduce using rule 179 (empty -> .)
    LBRACE          reduce using rule 179 (empty -> .)
    SEMICOLON       reduce using rule 179 (empty -> .)
    FUNCTION        reduce using rule 179 (empty -> .)
    CLONE           reduce using rule 179 (empty -> .)
    ARRAY           reduce using rule 179 (empty -> .)
    PLUS            reduce using rule 179 (empty -> .)
    MINUS           reduce using rule 179 (empty -> .)
    BIT_NOT         reduce using rule 179 (empty -> .)
    NOT             reduce using rule 179 (empty -> .)
    CONST_DECIMAL   reduce using rule 179 (empty -> .)
    CONST_DOUBLE    reduce using rule 179 (empty -> .)
    CONST_STRING    reduce using rule 179 (empty -> .)
    NULL            reduce using rule 179 (empty -> .)
    TRUE            reduce using rule 179 (empty -> .)
    FALSE           reduce using rule 179 (empty -> .)
    INC             reduce using rule 179 (empty -> .)
    DEC             reduce using rule 179 (empty -> .)
    EMPTY           reduce using rule 179 (empty -> .)
    EVAL            reduce using rule 179 (empty -> .)
    LPAREN          reduce using rule 179 (empty -> .)
    INCLUDE         reduce using rule 179 (empty -> .)
    INCLUDE_ONCE    reduce using rule 179 (empty -> .)
    REQUIRE         reduce using rule 179 (empty -> .)
    REQUIRE_ONCE    reduce using rule 179 (empty -> .)
    EXIT            reduce using rule 179 (empty -> .)
    PRINT           reduce using rule 179 (empty -> .)
    IF              reduce using rule 179 (empty -> .)
    IDENTIFIER      reduce using rule 179 (empty -> .)
    STRING          reduce using rule 179 (empty -> .)


    jump_marker                    shift and go to state 160
    empty                          shift and go to state 68

state 410

    (36) for_stmt -> COLON inner_stmts ENDFOR . SEMICOLON

    SEMICOLON       shift and go to state 411



state 411

    (36) for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .

    WHILE           reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    DO              reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    FOR             reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    FOREACH         reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    SWITCH          reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    BREAK           reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    CONTINUE        reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    RETURN          reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    GLOBAL          reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    STATIC          reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ECHO            reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    LBRACE          reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    SEMICOLON       reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    FUNCTION        reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    CLONE           reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ARRAY           reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    PLUS            reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    MINUS           reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    BIT_NOT         reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    NOT             reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    CONST_DECIMAL   reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    CONST_DOUBLE    reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    CONST_STRING    reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    NULL            reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    TRUE            reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    FALSE           reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    INC             reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    DEC             reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    EMPTY           reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    EVAL            reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    LPAREN          reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    INCLUDE         reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    INCLUDE_ONCE    reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    REQUIRE         reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    REQUIRE_ONCE    reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    EXIT            reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    PRINT           reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    IF              reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    IDENTIFIER      reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    STRING          reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    $end            reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    RBRACE          reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ENDIF           reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ELSE            reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ELSEIF          reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ENDWHILE        reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ENDFOREACH      reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    CASE            reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    DEFAULT         reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ENDSWITCH       reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)
    ENDFOR          reduce using rule 36 (for_stmt -> COLON inner_stmts ENDFOR SEMICOLON .)


